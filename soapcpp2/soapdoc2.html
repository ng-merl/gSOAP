<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.00">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

<body bgcolor="#FFFFFF">



<title> gSOAP 2.2.2 User Guide</title>
    
<h1 align="center">gSOAP 2.2.2 User Guide </h1>

<h3 align="center">Robert A. van Engelen <br />Genivia inc. and Florida State University <br />engelen@acm.org </h3>

<h3 align="center">Jan 27, 2003
<br /><a href="soapdoc2.pdf"><font color="#FF0000"><b>[This document is also available in PDF format (black and white only)]</b></font></a></h3>
 <br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; <font color="#0000FF">Introduction</font></a><br />
<a href="#tth_sEc2"
>2&nbsp; <font color="#0000FF">Notational Conventions</font></a><br />
<a href="#tth_sEc3"
>3&nbsp; <font color="#0000FF">Differences Between gSOAP Versions 2.1 (and Earlier) and 2.2</font></a><br />
<a href="#tth_sEc4"
>4&nbsp; <font color="#0000FF">Differences Between gSOAP Versions 1.X and 2.X</font></a><br />
<a href="#tth_sEc5"
>5&nbsp; <font color="#0000FF">Interoperability</font></a><br />
<a href="#tth_sEc6"
>6&nbsp; <font color="#0000FF">Quick User Guide</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; <font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Clients</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.1"
>6.1.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.2"
>6.1.2&nbsp; <font color="#0000FF">Namespace Considerations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.3"
>6.1.3&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.4"
>6.1.4&nbsp; <font color="#0000FF">How to Generate C++ Client Proxy Classes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.5"
>6.1.5&nbsp; <font color="#0000FF">XSD Type Encoding Considerations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.6"
>6.1.6&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.7"
>6.1.7&nbsp; <font color="#0000FF">How to Change the Response Element Name</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.8"
>6.1.8&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.9"
>6.1.9&nbsp; <font color="#0000FF">How to Specify Multiple Output Parameters</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.10"
>6.1.10&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.11"
>6.1.11&nbsp; <font color="#0000FF">How to Specify Output Parameters With struct/class Compound Data Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.12"
>6.1.12&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.13"
>6.1.13&nbsp; <font color="#0000FF">How to Specify Anonymous Parameter Names</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.14"
>6.1.14&nbsp; <font color="#0000FF">How to Specify a Method with No Input Parameters</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1.15"
>6.1.15&nbsp; <font color="#0000FF">How to Specify a Method with No Output Parameters</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; <font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Web Services</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.1"
>6.2.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.2"
>6.2.2&nbsp; <font color="#0000FF">How to Create a Stand-Alone gSOAP Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.3"
>6.2.3&nbsp; <font color="#0000FF">How to Create a Multi-Threaded Stand-Alone Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.4"
>6.2.4&nbsp; <font color="#0000FF">Some Web Service Implementation Issues</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.5"
>6.2.5&nbsp; <font color="#0000FF">How to Generate WSDL Service Descriptions</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.6"
>6.2.6&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.7"
>6.2.7&nbsp; <font color="#0000FF">How to Import WSDL Service Descriptions</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.8"
>6.2.8&nbsp; <font color="#0000FF">How to Use Client Functionalities Within a Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; <font color="#0000FF">How to Use gSOAP for Asynchronous One-Way Message Passing</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; <font color="#0000FF">How to Use the SOAP Serializers and Deserializers to Save and Load Application Data</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4.1"
>6.4.1&nbsp; <font color="#0000FF">Serializing a Data Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4.2"
>6.4.2&nbsp; <font color="#0000FF">Deserializing a Data Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4.3"
>6.4.3&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4.4"
>6.4.4&nbsp; <font color="#0000FF">How to Specify Default Values for Omitted Data</font></a><br />
<a href="#tth_sEc7"
>7&nbsp; <font color="#0000FF">Using the gSOAP Stub and Skeleton Compiler</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; <font color="#0000FF">Compiler Options</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; <font color="#0000FF">SOAP 1.1 Versus SOAP 1.2</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; <font color="#0000FF">The soapdefs.h Header File</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; <font color="#0000FF">The gSOAP #import Directive</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.5"
>7.5&nbsp; <font color="#0000FF">How to Use #include and #define Directives</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.6"
>7.6&nbsp; <font color="#0000FF">Compiling a gSOAP Client</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.7"
>7.7&nbsp; <font color="#0000FF">Compiling a gSOAP Web Service</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.8"
>7.8&nbsp; <font color="#0000FF">Using gSOAP for Creating Web Services and Clients in Pure C</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.9"
>7.9&nbsp; <font color="#0000FF">Limitations of gSOAP</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.10"
>7.10&nbsp; <font color="#0000FF">Runtime Flags</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.11"
>7.11&nbsp; <font color="#0000FF">Memory Management</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.11.1"
>7.11.1&nbsp; <font color="#0000FF">Memory Management Policies</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.11.2"
>7.11.2&nbsp; <font color="#0000FF">Intra-Class Memory Management</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.12"
>7.12&nbsp; <font color="#0000FF">Debugging</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.13"
>7.13&nbsp; <font color="#0000FF">Libraries</font></a><br />
<a href="#tth_sEc8"
>8&nbsp; <font color="#0000FF">The gSOAP Remote Method Specification Format</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; <font color="#0000FF">Remote Method Parameter Passing</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; <font color="#0000FF">Stub and Skeleton Routine Error Codes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; <font color="#0000FF">C/C++ Identifier Name to XML Name Translations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4"
>8.4&nbsp; <font color="#0000FF">Namespace Mapping Table</font></a><br />
<a href="#tth_sEc9"
>9&nbsp; <font color="#0000FF">gSOAP Serialization and Deserialization Rules</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1"
>9.1&nbsp; <font color="#0000FF">Primitive Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2"
>9.2&nbsp; <font color="#0000FF">How to Encode and Decode Primitive Types as XSD Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.1"
>9.2.1&nbsp; <font color="#0000FF">How to Use Multiple C/C++ Types for a Single Primitive XSD Type</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.2"
>9.2.2&nbsp; <font color="#0000FF">How to use Wrapper Classes to Specify Polymorphic Primitive Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.3"
>9.2.3&nbsp; <font color="#0000FF">XML Schema Type Decoding Rules</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.4"
>9.2.4&nbsp; <font color="#0000FF">Multi-Reference Strings</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.5"
>9.2.5&nbsp; <font color="#0000FF">``Smart String'' Mixed-Content Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.6"
>9.2.6&nbsp; <font color="#0000FF">Changing the Encoding Precision of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.7"
>9.2.7&nbsp; <font color="#0000FF">INF, -INF, and NaN Values of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3"
>9.3&nbsp; <font color="#0000FF">Enumeration Type Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.1"
>9.3.1&nbsp; <font color="#0000FF">Symbolic Encoding of Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.2"
>9.3.2&nbsp; <font color="#0000FF">Literal Encoding of Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.3"
>9.3.3&nbsp; <font color="#0000FF">Initialized Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.4"
>9.3.4&nbsp; <font color="#0000FF">How to ``Reuse'' Symbolic Enumeration Constants</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.5"
>9.3.5&nbsp; <font color="#0000FF">Boolean Enumeration Type Encoding and Decoding for C Compilers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.6"
>9.3.6&nbsp; <font color="#0000FF">Bitmask Enumeration Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.4"
>9.4&nbsp; <font color="#0000FF">Struct Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5"
>9.5&nbsp; <font color="#0000FF">Class Instance Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5.1"
>9.5.1&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5.2"
>9.5.2&nbsp; <font color="#0000FF">Initialized <b>static</b>&nbsp;<b>const</b>&nbsp;Fields</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5.3"
>9.5.3&nbsp; <font color="#0000FF">Class Methods</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5.4"
>9.5.4&nbsp; <font color="#0000FF">Polymorphism, Derived Classes, and Dynamic Binding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5.5"
>9.5.5&nbsp; <font color="#0000FF">Struct/Class Encoding With XML Attributes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.6"
>9.6&nbsp; <font color="#0000FF">Pointer Encoding and Decoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.6.1"
>9.6.1&nbsp; <font color="#0000FF">Multi-Reference Data</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.6.2"
>9.6.2&nbsp; <font color="#0000FF">NULL Pointers and Nil Elements</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.7"
>9.7&nbsp; <font color="#0000FF">Fixed-Size Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8"
>9.8&nbsp; <font color="#0000FF">Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.1"
>9.8.1&nbsp; <font color="#0000FF">One-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.2"
>9.8.2&nbsp; <font color="#0000FF">Example</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.3"
>9.8.3&nbsp; <font color="#0000FF">One-Dimensional Dynamic Arrays With Non-Zero Offset</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.4"
>9.8.4&nbsp; <font color="#0000FF">Nested One-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.5"
>9.8.5&nbsp; <font color="#0000FF">Multi-Dimensional Dynamic Arrays</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.6"
>9.8.6&nbsp; <font color="#0000FF">Dynamic Array as List Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.7"
>9.8.7&nbsp; <font color="#0000FF">Polymorphic Dynamic Arrays and Lists</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.8"
>9.8.8&nbsp; <font color="#0000FF">How to Change the Tag Names of the Elements of a SOAP Array or List</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.8.9"
>9.8.9&nbsp; <font color="#0000FF">Embedded Arrays and Lists</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.9"
>9.9&nbsp; <font color="#0000FF">Base64Binary XML Schema Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.10"
>9.10&nbsp; <font color="#0000FF">hexBinary XML Schema Type Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.11"
>9.11&nbsp; <font color="#0000FF">Doc/Literal XML Encoding Style</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.11.1"
>9.11.1&nbsp; <font color="#0000FF">Serializing and Deserializing XML Into Strings</font></a><br />
<a href="#tth_sEc10"
>10&nbsp; <font color="#0000FF">SOAP Fault Processing</font></a><br />
<a href="#tth_sEc11"
>11&nbsp; <font color="#0000FF">SOAP Header Processing</font></a><br />
<a href="#tth_sEc12"
>12&nbsp; <font color="#0000FF">DIME Attachment Processing</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.1"
>12.1&nbsp; <font color="#0000FF">Non-Streaming DIME</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.2"
>12.2&nbsp; <font color="#0000FF">Streaming DIME</font></a><br />
<a href="#tth_sEc13"
>13&nbsp; <font color="#0000FF">Advanced Features</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.1"
>13.1&nbsp; <font color="#0000FF">Internationalization</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.2"
>13.2&nbsp; <font color="#0000FF">Customizing the WSDL and Namespace Mapping Table File Contents</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.3"
>13.3&nbsp; <font color="#0000FF">How to Specify minOccurs and maxOccurs Schema Attributes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.4"
>13.4&nbsp; <font color="#0000FF">Transient Data Types</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.5"
>13.5&nbsp; <font color="#0000FF">How to Declare User-Defined Serializers and Deserializers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.6"
>13.6&nbsp; <font color="#0000FF">How to Serialize Data Without XSD Type Attributes</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.7"
>13.7&nbsp; <font color="#0000FF">Function Callbacks for Customized I/O and HTTP Handling</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.8"
>13.8&nbsp; <font color="#0000FF">HTTP 1.0 and 1.1</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.9"
>13.9&nbsp; <font color="#0000FF">HTTP Keep-Alive</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.10"
>13.10&nbsp; <font color="#0000FF">HTTP Chunked Transfer Encoding</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.11"
>13.11&nbsp; <font color="#0000FF">HTTP Buffered Sends</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.12"
>13.12&nbsp; <font color="#0000FF">HTTP Authentication</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.13"
>13.13&nbsp; <font color="#0000FF">HTTP Proxy Authentication</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.14"
>13.14&nbsp; <font color="#0000FF">Timeout Management for Non-Blocking Operations</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.15"
>13.15&nbsp; <font color="#0000FF">Socket Options and Flags</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.16"
>13.16&nbsp; <font color="#0000FF">Secure SOAP Clients with HTTPS/SSL</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.17"
>13.17&nbsp; <font color="#0000FF">Secure SOAP Web Services with HTTPS/SSL</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.18"
>13.18&nbsp; <font color="#0000FF">SSL Certificates</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.19"
>13.19&nbsp; <font color="#0000FF">Zlib Compressed Messages</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.20"
>13.20&nbsp; <font color="#0000FF">Client-Side Cookie Support</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.21"
>13.21&nbsp; <font color="#0000FF">Server-Side Cookie Support</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.22"
>13.22&nbsp; <font color="#0000FF">Connecting Clients Through Proxy Servers</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.23"
>13.23&nbsp; <font color="#0000FF">FastCGI Support</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.24"
>13.24&nbsp; <font color="#0000FF">How to Create Separate Client/Server DLLs</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.24.1"
>13.24.1&nbsp; <font color="#0000FF">Create Base stdsoap2.dll</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.24.2"
>13.24.2&nbsp; <font color="#0000FF">Creating Client and Service DLLs</font></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.24.3"
>13.24.3&nbsp; <font color="#0000FF">gSOAP Plug-ins</font></a><br />
 
</td></tr></table><br></span>
<i>Copyright (C) 2000-2003 Robert A. van Engelen, Genivia inc. All Rights Reserved.</i>


<p>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;<font color="#0000FF">Introduction</font></h2>

<p>
The gSOAP toolkit provides a unique SOAP-to-C/C++ language binding for the
development of SOAP Web Services and clients.  Other SOAP C++ implementations
adopt a SOAP-centric view and offer SOAP APIs for C++ that require the use of
class libraries for SOAP-like data structures.  This often forces a user to
adapt the application logic to these libraries.  In contrast, gSOAP provides a
C/C++ transparent SOAP API through the use of compiler technology that hides
irrelevant SOAP-specific details from the user.  The gSOAP stub and skeleton
compiler automatically maps native and user-defined C and C++ data types to
semantically equivalent SOAP data types and vice-versa.  As a result, full SOAP
interoperability is achieved with a simple API relieving the user from the
burden of SOAP details and enables him or her to concentrate on the
application-essential logic.  The compiler enables the integration of (legacy)
C/C++ and Fortran codes (through a Fortran-to-C interface), embedded systems,
and real-time software in SOAP applications that share computational resources
and information with other SOAP applications, possibly across different
platforms, language environments, and disparate organizations located behind
firewalls.

<p>
gSOAP minimizes application adaptation for building SOAP clients and Web
Services.  The gSOAP compiler generates SOAP marshalling routines that
(de)serialize application-specific C/C++ data structures.  gSOAP includes a
WSDL generator to generate Web service descriptions for your Web services.  The
gSOAP WSDL importer "closes the circle" in that it enables client development
without the need for users to analyze Web service details to implement a
client.

<p>
Some of the highlights of gSOAP are:

<ul><p>
<li>Unique interoperability features: the gSOAP compiler generates SOAP marshalling routines that (de)serialize native and
user-defined C/C++ data structures.  gSOAP is also one of the few SOAP toolkits that support the full range of SOAP 1.1 features
including multi-dimensional arrays and polymorphic types. For example, a remote method with a base class parameter may accept
derived class instances from a client. Derived class instances keep their identity through dynamic binding.</li>
<p>
<li>
gSOAP includes a WSDL generator for convenient Web Service publishing.</li>
<p>
<li>
gSOAP includes a WSDL importer for automated client development.</li>
<p>
<li>
Generates source code for stand-alone Web Services and clients.</li>
<p>
<li>
Ideal for building web services that are compute-intensive and are therefore best written in C and C++.</li>
<p>
<li>
Platform independent: Windows, Unix, Linux, Mac OS X, Pocket PC, etc.</li>
<p>
<li>
Fast <em>in situ</em> serialization and deserialization with SOAP encoding of arbitrary user-defined and built-in C and C++ data
structures.</li>
<p>
<li>
Fully SOAP 1.1 compliant data encoding and decoding. Also SOAP 1.2 compliant, but the SOAP 1.2 specification is in a drafting stage.</li>
<p>
<li>
DIME compliant attachments with streaming capabilities.</li>
<p>
<li>
Zlib deflate and gzip compression.</li>
<p>
<li>
Includes HTTP, TCP/IP, XML, and DIME stacks.</li>
<p>
<li>
Supports one-way messaging, including asynchronous send and receive operations.</li>
<p>
<li>
Supports saving and loading of XML serialized C/C++ data structures to/from files.</li>
<p>
<li>
The schema-specific XML pull parser is fast and efficient and does not require intermediate data storage for
demarshalling to save space and time.</li>
<p>
<li>
Selective input and output buffering is used to increase efficiency, but full message buffering to determine HTTP message length
is not used. Instead, a three-phase serialization method is used to determine message length. As a result, large data sets
such as base64-encoded images can be transmitted with or without DIME attachments by small-memory devices such as PDAs.</li>
<p>
<li>
Supports C++ single class inheritance, dynamic binding, overloading, arbitrary pointer structures such as lists, trees, graphs,
cyclic graphs, fixed-size arrays, (multi-dimensional) dynamic arrays, enumerations, built-in XML schema types including
base64Binary encoding, and hexBinary encoding.</li>
<p>
<li>
No need to rewrite existing C/C++ applications for Web service deployment. However, parts of an application that use unions,
pointers to sequences of elements in memory, and <i><b>void</b>*</i> need to be modified, but <b>only</b> if the data structures that
adopt them are required to be serialized or deserialized as part of a remote method invocation.</li>
<p>
<li>
Three-phase marshalling: 1) analysis of pointers, single-reference, multi-reference, and cyclic data structures, 2) HTTP
message-length determination, and 3) serialization as per SOAP 1.1 encoding style or user-defined encoding styles.</li>
<p>
<li>
Two-phase demarshalling: 1) SOAP parsing and decoding, which involves the reconstruction of multi-reference and cyclic data
structures from the payload, and 2) resolution of "forward" pointers (i.e. resolution of the forward <tt>href</tt> attributes in SOAP).</li>
<p>
<li>
Full and customizable SOAP Fault processing (client receive and service send).</li>
<p>
<li>
Customizable SOAP Header processing (send and receive), which for example enables easy transaction processing for the service to
keep state information.</li>
</ul>

<p>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;<font color="#0000FF">Notational Conventions</font></h2>

<p>
The typographical conventions used by this document are:

<dl compact="compact">
 <dt><b><span class="roman"><i>Sans serif or italics font</i></b></dt>
	<dd> denotes C and C++ source code, file names, and shell/batch commands.</span></dd>
 <dt><b><i><b>Bold font</b></i></b></dt>
	<dd> denotes C and C++ keywords.</dd>
 <dt><b><tt>Courier font</tt></b></dt>
	<dd> denotes HTTP header content, HTML, XML, XML schema content and WSDL content.</dd>
 <dt><b><span class="roman"><font size="+1"><span class="roman">[</span></font>Optional<font size="+1"><span class="roman">]</span></font></b></dt>
	<dd> denotes an optional construct.</span></dd>
</dl>

<p>
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in RFC-2119.

<p>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;<font color="#0000FF">Differences Between gSOAP Versions 2.1 (and Earlier) and 2.2</font></h2>

<p>
Run-time options and flags have been changed to enable separate recv/send
settings for transport, content encodings, and mappings.  The flags are divided
into four classes: transport (IO), content encoding (ENC), XML marshalling
(XML), and C/C++ data mapping (C).  The old-style flags <i>soap_disable_X</i>
and <i>soap_enable_X</i>, where <i>X</i> is a particular feature, are
depricated.  See Section&nbsp;<a href="#sec:flags">7.10</a> for more details.

<p>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;<font color="#0000FF">Differences Between gSOAP Versions 1.X and 2.X</font></h2>

<p>
gSOAP versions 2.0 and higher have been rewritten based on versions 1.X. gSOAP 2.0 and higher is thread-safe, while 1.X is not.
All files in the gSOAP 2.X distribution are renamed to avoid confusion with gSOAP version 1.X files:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>gSOAP 1.X</b></font>	</td><td><font color="#FF0000"><b>gSOAP 2.X</b></font> </td></tr>
<tr><td>soapcpp		</td><td>soapcpp2 </td></tr>
<tr><td>soapcpp.exe	</td><td>soapcpp2.exe </td></tr>
<tr><td>stdsoap.h	</td><td>stdsoap2.h </td></tr>
<tr><td>stdsoap.c	</td><td>stdsoap2.c </td></tr>
<tr><td>stdsoap.cpp	</td><td>stdsoap2.cpp </td></tr></table>

</td></tr></table><br></span>
Changing the version 1.X application codes to accomodate gSOAP 2.X does not require a significant amount of recoding.
The change to gSOAP 2.X affects all functions defined in <i>stdsoap2.c[pp]</i> (the gSOAP runtime environment API) and the functions in the
sources generated by the gSOAP compiler (the gSOAP RPC+marshalling API).
Therefore, clients and services developed with gSOAP 1.X need to be modified to accomodate a change in the calling convention used in 2.X:
In 2.X, <b>all</b> gSOAP functions (including the remote method proxy routines) take an additional parameter which is an instance of the gSOAP runtime
environment that includes file descriptors, tables, buffers, and flags.
This additional parameter is <b>always</b> the first parameter of any gSOAP function.

<p>
The gSOAP runtime environment is stored in a <i><b>struct</b>&nbsp;soap</i> type. A <i><b>struct</b></i> was chosen to support application development in
C without the need for a separate gSOAP implementation.  An object-oriented approach with a class for the gSOAP runtime environment would have prohibited the implementation of pure C applications.
Before a client can invoke remote methods or before a service can accept requests, a runtime environment need to be allocated and
initialized.
Three new functions are added to gSOAP 2.X:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td width="351"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Initializes a runtime environment (required only once) </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_new()</i> </td><td width="351">Allocates, initializes, and returns a pointer to a runtime environment </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_copy(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Allocates a new runtime invironment and copies contents of
the argument environment such that the new environment does not share any data
with the original environment </td></tr></table>

</td></tr></table><br></span>
An environment can be reused as many times as necessary and does not need to be reinitialized in doing so.
A new environment is only required for each new thread to guarantee exclusive access
to a new runtime environment by each thread.
For example, the following code stack-allocates the runtime environment which is used for multiple remote method calls:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // initialize runtime environment <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method1(&amp;soap, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method2(&amp;soap, ...); // make another remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // clean up <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
The runtime environment can also be heap allocated:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap = soap_new(); // allocate and initialize runtime environment <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap) // couldn't allocate: stop <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method1(soap, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method2(soap, ...); // make another remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(soap); // clean up <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;free(soap); // deallocate runtime environment <br />
}
</td></tr></table><br></i>
A service need to allocate and initialize an environment before calling <i>soap_serve</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
}
</td></tr></table><br></i>
Or alternatively:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
}
</td></tr></table><br></i>
A service can use multi-threading to handle requests while running some other code that invokes remote methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap1, soap2; <br />
&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap1); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_bind(&amp;soap1, host, port, backlog)  &lt;  0) exit(1); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_accept(&amp;soap1)  &lt;  0) exit(1); <br />
&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, (<b>void</b>*(*)(<b>void</b>*))soap_serve, (<b>void</b>*)&amp;soap1]); <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap2); <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method(&amp;soap2, ...); // make a remote call <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap2); <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;pthread_join(tid); // wait for thread to terminate <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap1); // release its data <br />
}
</td></tr></table><br></i>
In the example above, two runtime environments are required.
In comparison, gSOAP 1.X statically allocates the runtime environment, which prohibits multi-threading (only one thread can invoke
remote methods and/or accept requests due to the single runtime environment).

<p>
Section&nbsp;<a href="#sec:mt">6.2.3</a> presents a multi-threaded stand-alone Web Service that handles multiple SOAP requests by spawning a thread for each request.

<p>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;<font color="#0000FF">Interoperability</font></h2>

<p>
gSOAP interoperability has been verified with the following SOAP implementations and toolkits:

<dl compact="compact">
 <dt><b>Apache 2.2</b></dt>
	<dd></dd>
 <dt><b>Apache Axis</b></dt>
	<dd></dd>
 <dt><b>ASP.NET</b></dt>
	<dd></dd>
 <dt><b>Cape Connect</b></dt>
	<dd></dd>
 <dt><b>Delphi</b></dt>
	<dd></dd>
 <dt><b>easySOAP++</b></dt>
	<dd></dd>
 <dt><b>eSOAP</b></dt>
	<dd></dd>
 <dt><b>Frontier</b></dt>
	<dd></dd>
 <dt><b>GLUE</b></dt>
	<dd></dd>
 <dt><b>Iona XMLBus</b></dt>
	<dd></dd>
 <dt><b>kSOAP</b></dt>
	<dd></dd>
 <dt><b>MS SOAP</b></dt>
	<dd></dd>
 <dt><b>Phalanx</b></dt>
	<dd></dd>
 <dt><b>SIM</b></dt>
	<dd></dd>
 <dt><b>SOAP::Lite</b></dt>
	<dd></dd>
 <dt><b>SOAP4R</b></dt>
	<dd></dd>
 <dt><b>Spray</b></dt>
	<dd></dd>
 <dt><b>SQLData</b></dt>
	<dd></dd>
 <dt><b>Wasp Adv.</b></dt>
	<dd></dd>
 <dt><b>Wasp C++</b></dt>
	<dd></dd>
 <dt><b>White Mesa</b></dt>
	<dd></dd>
 <dt><b>xSOAP</b></dt>
	<dd></dd>
 <dt><b>ZSI</b></dt>
	<dd></dd>
 <dt><b>4S4C</b></dt>
	<dd></dd>
</dl>

<p>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;<font color="#0000FF">Quick User Guide</font></h2>

<p>
This user guide offers a quick way to get started with gSOAP.  This section requires a basic understanding of the SOAP 1.1
protocol and some familiarity with C and/or C++. In principle, SOAP clients and SOAP Web services can be developed in C and C++
with the gSOAP compiler without a detailed understanding of the SOAP protocol when gSOAP client-server applications
are build as an ensamble and only communicate within this group (i.e.&nbsp;meaning that you don't have to worry about
interoperability with other SOAP implementations).  This section is intended to illustrate the implementation of gSOAP Web
services and clients that connect to and interoperate with other SOAP implementations such as Apache Axis, SOAP::Lite, and .NET.
This requires some details of the SOAP and WSDL protocols to be understood.

<p>
	     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;<font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Clients</font></h3><a name="sec:client">
</a>

<p>
In general, the implementation of a SOAP client application requires a <b>stub</b> routine for each remote method that the client
application needs to invoke.  The primary stub's responsibility is to marshall the input data, send the request to the designated
SOAP service over the wire, to wait for the response, and to demarshall the output data when it arrives. The client application
invokes the stub routine for a remote method as if it would invoke a local method.  To write a stub routine in C or C++ by hand is
a tedious task, especially if the input and/or output parameters of a remote method contain elaborate data structures such as records,
arrays, and graphs.

<p>
The generation of stub routines for a SOAP client is fully automated with gSOAP.  The gSOAP stub and skeleton compiler is a <b>
preprocessor</b> that generates the necessary C++ sources to build SOAP C++ clients. The input to the gSOAP stub and skeleton
compiler consists of a standard C/C++ <b>header file</b>.  The header file can be generated from a WSDL (Web Service
Description Language) documentation of a service with the gSOAP WSDL importer, see&nbsp;<a href="#sec:wsdlin">6.2.7</a>.  The SOAP remote methods are specified in this header file as <b>function prototypes</b>. Stub routines in
C/C++ source form are automatically generated by the gSOAP compiler for these function prototypes of remote methods.  The
resulting stub routines allow C and C++ client applications to seamlessly interact with existing SOAP Web services.

<p>
The gSOAP stub and skeleton compiler also generates <b>skeleton</b> routines for each of the remote methods specified in the header
file. The skeleton routines can be readily used to implement one or more of the remote methods in a new SOAP Web service. These
skeleton routines are not used for building SOAP clients in C++, although they can be used to build mixed SOAP client/server
applications (peer applications).

<p>
The input and output parameters of a SOAP remote method may be simple data types or compound data types.  The necessary <b>type
declarations</b> of C/C++ user-defined data structures such as structs, classes, enumerations, arrays, and pointer-based data
structures (graphs) are to be provided in the header file.  The gSOAP stub and skeleton compiler automatically generates <b>
serializers</b> and <b>deserializers</b> for the data types to enable the generated stub routines to encode and decode the contents of
the parameters of the remote methods in XML.

<p>
The remote method name and its parameterization can be found with a SOAP Web service description, typically in the form of an XML
schema. For SOAP 1.1 RPC encoding, there is a one-to-one correspondence between the XML schema description of a SOAP remote method and the C/C++ type
declarations required to build a client application for the Web service. There is also an almost one-to-one correspondence between the schemas and the C/C++ type declarations for SOAP literal encoding.
The schemas are typically part of the WSDL  specification of a SOAP Web service.  The gSOAP WSDL importer converts WSDL service descriptions into header files.

<p>
		      <h4><a name="tth_sEc6.1.1">
6.1.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example1">
</a>

<p>
The <i>getQuote</i> remote method of XMethods Delayed Stock Quote service provides a delayed stock quote for a given ticker name.
The WSDL description of the XMethods Delayed Stock Quote service provides the following details:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td>Endpoint URL: </td><td><tt>http://services.xmethods.net:80/soap</tt> </td></tr>
<tr><td>SOAP action: </td><td>"" (2 quotes) </td></tr>
<tr><td>Remote method namespace: </td><td><tt>urn:xmethods-delayed-quotes</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>getQuote</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameter: </td><td><tt>symbol</tt> of type <tt>xsd:string</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>Result</tt> of type <tt>xsd:float</tt>
</td></tr></table>

</td></tr></table><br></span>
The following <i>getQuote.h</i> <b>header file</b> is created from the WSDL description with the WSDL importer:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Content of file <tt>"getQuote.h"</tt>: <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The header file essentially specifies the service details in C/C++ with directives for the gSOAP compiler.
The remote method is declared as a <i>ns1__getQuote</i> <b>function prototype</b> which specifies all of the necessary details for
the gSOAP compiler to generate the stub routine for a client application to interact with the Delayed Stock Quote service.

<p>
The Delayed Stock Quote service description requires that the <b>input parameter</b> of the <i>getQuote</i> remote method is a
<i>symbol</i> parameter of type string. The description also indicates that the <i>Result</i> <b>output parameter</b> is a floating
point number that represents the current unit price of the stock in dollars. The gSOAP compiler uses the convention the <b>last
parameter</b> of the function prototype must be the output parameter of the remote method, which is required to be passed by
reference using the reference operator (<i>&amp;</i>) or by using a pointer type. All other parameters except the last are input
parameters of the remote method, which are required to be passed by value or passed using a pointer to a value (by reference is
not allowed). The function prototype associated with a remote method is required to return an <i><b>int</b></i>, whose value indicates to
the caller whether the connection to a SOAP Web service was successful or resulted in an exception, see Section&nbsp;<a href="#sec:errcodes">8.2</a>
for the error codes. 

<p>
The use of the namespace prefix <i>ns1__</i> in the remote method name in the function prototype declaration is discussed in
detail in&nbsp;<a href="#sec:namespace">6.1.2</a>.  Basically, a namespace prefix is distinghuished by a <b>pair of underscores</b> in the function
name, as in <i>ns1__getQuote</i> where <i>ns1</i> is the namespace prefix and <i>getQuote</i> is the remote method name.  (A single
underscore in an identifier name will be translated into a dash in XML, because dashes are more frequently used in XML compared to underscores, see Section&nbsp;<a href="#sec:idtrans">8.3</a>.)

<p>
The gSOAP compiler is invoked from the command line with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 getQuote.h</i>
</td></tr></table><br></span>
The compiler generates the stub routine for the <i>getQuote</i> remote method specified in the <i>getQuote.h</i> header file. This
stub routine can be called by a client program at any time to request a stock quote from the Delayed Stock Quote service. The
interface to the generated stub routine is the following function prototype generated by the gSOAP compiler:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_ns1__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The stub routine is saved in <i>soapClient.cpp</i>. The file <i>soapC.cpp</i> contains the <b>serializer</b> and <b>
deserializer</b> routines for the data types used by the stub.

<p>
Note that the parameters of the <i>soap_call_ns1__getQuote</i> function are identical to the
<i>ns1__getQuote</i> function prototype with three additional input parameters: <i>soap</i> must be a valid pointer to a gSOAP
runtime environment, <i>URL</i> is the SOAP Web service <b>endpoint URL</b>
passed as a string, and <i>action</i> is a string that denotes the <b>SOAP action</b> required by the Web service.

<p>
The following example C++ client program invokes the stub to retrieve the latest AOL stock quote from the XMethods Delayed Stock
Quote service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include <tt>"soapH.h"</tt> // obtain the generated stub <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; // gSOAP runtime environment <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;quote; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // initialize runtime environment (only once) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(&amp;soap, <tt>"http://services.xmethods.net:80/soap"</tt>, <tt>""</tt>, <tt>"AOL"</tt>, quote) == SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "Current AOL Stock Quote = "  &lt;&lt;  quote; <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;// an error occurred <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); // display the SOAP fault message on the stderr stream <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // clean up <br />
}
</td></tr></table><br></i>
The XMethods Delayed Stock Quote service endpoint URL is <tt>http://services.xmethods.net/soap</tt> port 80 and the SOAP action required
is <tt>""</tt> (two quotes).  If successful, the stub returns <i>SOAP_OK</i> and <i>quote</i> contains the latest stock quote.
Otherwise, an error occurred and the SOAP fault is displayed with the <i>soap_print_fault</i> function.

<p>
The following functions can be used to setup a gSOAP runtime environment (<i><b>struct</b>&nbsp;soap</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td width="351"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Initializes a runtime environment (required only once) </td></tr>
<tr><td><i>soap_init2(<b>struct</b>&nbsp;soap *soap, int imode, int omode)</i> </td><td width="351">Initializes a runtime environment and set in/out mode flags </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_new()</i> </td><td width="351">Allocates, initializes, and returns a pointer to a runtime environment </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_copy(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Allocates a new runtime invironment and copies contents of
the argument environment such that the new environment does not share data with the argument environment </td></tr>
<tr><td><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Reset, close communications, and remove callbacks </td></tr></table>

</td></tr></table><br></span>
An environment can be reused as many times as necessary for client-side remote calls and does not need to be reinitialized in doing so.
A new environment is required for each new thread to guarantee exclusive access
to runtime environments by threads.  Also the use of any client calls within an active service method requires a new environment.

<p>
When the example client application is invoked, the SOAP request is performed by the stub routine <i>soap_call_ns1__getQuote</i>, which
generates the following SOAP RPC request message:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /soap HTTP/1.1 <br />
Host: services.xmethods.net <br />
Content-Type: text/xml <br />
Content-Length: 529 <br />
SOAPAction: "" <br />
<br />
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns1="urn:xmethods-delayed-quotes" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getQuote&#62; <br />
&lt;symbol&#62;AOL&lt;/symbol&#62; <br />
&lt;/ns1:getQuote&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The XMethods Delayed Stock Quote service responds with the SOAP response message:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 OK <br />
Date: Sat, 25 Aug 2001 19:28:59 GMT <br />
Content-Type: text/xml <br />
Server: Electric/1.0 <br />
Connection: Keep-Alive <br />
Content-Length: 491 <br />
<br />
&lt;?xml version='1.0' encoding='UTF-8'?&#62; <br />
&lt;soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance' <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd='http://www.w3.org/1999/XMLSchema' <br />
&nbsp;&nbsp;&nbsp;xmlns:soapenc='http://schemas.xmlsoap.org/soap/encoding/' <br />
&nbsp;&nbsp;&nbsp;soap:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'&#62; <br />
&lt;soap:Body&#62; <br />
&lt;n:getQuoteResponse xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;Result xsi:type='xsd:float'&#62;41.81&lt;/Result&#62; <br />
&lt;/n:getQuoteResponse&#62; <br />
&lt;/soap:Body&#62; <br />
&lt;/soap:Envelope&#62;
</td></tr></table><br></tt>
The server's SOAP RPC response is parsed by the stub. The stub routine further demarshalls the data of <tt>Result</tt>
element of the SOAP response and stores it in the <i>quote</i> parameter of <i>soap_call_ns1__getQuote</i>.

<p>
A client program can invoke a remote method at any time and multiple times if necessary. Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
<b>struct</b>&nbsp;soap soap; <br />
<b>float</b>&nbsp;quotes[3]; char *myportfolio[] = {<tt>"IBM"</tt>, <tt>"AOL"</tt>, <tt>"MSDN"</tt>}; <br />
soap_init(&amp;soap); // need to initialize only once <br />
<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 0; i  &lt;  3; i++) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(&amp;soap, <tt>"http://services.xmethods.net:80/soap"</tt>, <tt>""</tt>, myportfolio[i], quotes[i]) != SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
<b>if</b>&nbsp;(soap.error) // an error occurred <br />
&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
soap_end(&amp;soap); // clean up all deserialized data <br />
...
</td></tr></table><br></i>
This client composes an array of stock quotes by calling the <i>ns1__getQuote</i> stub routine for each symbol in a portfolio array.

<p>
This example demonstrated how easy it is to build a SOAP client with gSOAP once the details of a Web service are available 
in the form of a WSDL document.

<p>
		      <h4><a name="tth_sEc6.1.2">
6.1.2</a>&nbsp;&nbsp;<font color="#0000FF">Namespace Considerations</font></h4><a name="sec:namespace">
</a>

<p>
The declaration of the <i>ns1__getQuote</i> function prototype (discussed in the previous section) uses the namespace prefix
<i>ns1__</i> of the remote method namespace, which is distinghuished by a <b>pair of underscores</b> in the function name to
separate the namespace prefix from the remote method name.  The purpose of a namespace prefix is to associate a remote
method name with a service in order to prevent naming conflicts, e.g.&nbsp;to distinguish identical remote method names used
by different services.

<p>
Note that the XML response of the XMethods Delayed Stock Quote service example uses the <b>namespace prefix</b> <tt>n</tt> which is
bound to the <b>namespace name</b> <tt>urn:xmethods-delayed-quotes</tt> through the <tt>xmlns:n="urn:xmethods-delayed-quotes</tt>
binding.  The use of namespace prefixes and namespace names is also required to enable SOAP applications to validate the content of
SOAP messages.  The namespace name in the service response is verified by the stub routine by using the
information supplied in a <b>namespace mapping table</b> that is required to be part of gSOAP client and service application codes.  The table is accessed
at run time to resolve namespace bindings, both by the generated stub's data structure serializer for encoding the client request
and by the generated stub's data structure deserializer to decode and validate the service response. The namespace mapping table
should <b>not</b> be part of the header file input to the gSOAP stub and skeleton compiler. Service details including namespace bindings may be provided with gSOAP directives in a header file, see Section&nbsp;<a href="#sec:directives">13.2</a>.

<p>
The namespace mapping table for the Delayed Stock Quote client is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{<font color="#FF0000">"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"</font>}, // MUST be first <br />
&nbsp;&nbsp;&nbsp;{<font color="#0000FF">"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"</font>}, // MUST be second <br />
&nbsp;&nbsp;&nbsp;{<font color="#FF00FF">"xsi",      "http://www.w3.org/2001/XMLSchema-instance"</font>}, // MUST be third <br />
&nbsp;&nbsp;&nbsp;{<font color="#00FFFF">"xsd",      "http://www.w3.org/2001/XMLSchema"</font>}, // 2001 XML schema <br />
&nbsp;&nbsp;&nbsp;{<font color="#00FF00">"ns1",      "urn:xmethods-delayed-quotes"</font>}, // given by the service description <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} // end of table <br />
};
</td></tr></table><br></i> 
The first four namespace entries in the table consist of the standard namespaces used by the SOAP 1.1 protocol. In fact, the
namespace mapping table is explicitly declared to enable a programmer to specify the SOAP encoding style and to allow the
inclusion of namespace-prefix with namespace-name bindings to comply to the namespace requirements of a specific SOAP service. For
example, the namespace prefix <tt>ns1</tt>, which is bound to <tt>urn:xmethods-delayed-quotes</tt> by the namespace mapping table shown
above, is used by the generated stub routine to encode the <i>getQuote</i> request. This is performed automatically by the gSOAP
compiler by using the <i>ns1</i> prefix of the <i>ns1__getQuote</i> method name specified in the <i>getQuote.h</i> header file. In
general, if a function name of a remote method, <i><b>struct</b></i> name, <i><b>class</b></i> name, <i><b>enum</b></i> name, or field name of a
<i><b>struct</b></i> or <i><b>class</b></i> has a pair of underscores, the name has a namespace prefix that must be defined in the namespace
mapping table.

<p>
The namespace mapping table will be output as part of the SOAP Envelope by the stub routine. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope xmlns:<font color="#FF0000">SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#0000FF">SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#FF00FF">xsi="http://www.w3.org/1999/XMLSchema-instance"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#00FFFF">xsd="http://www.w3.org/1999/XMLSchema"</font> <br />
&nbsp;&nbsp;&nbsp;xmlns:<font color="#00FF00">ns1="urn:xmethods-delayed-quotes"</font> <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle=<font color="#0000FF">"http://schemas.xmlsoap.org/soap/encoding/"</font>&#62; <br />
...
</td></tr></table><br></tt>
The namespace bindings will be used by a SOAP service to validate the SOAP request.

<p>
		      <h4><a name="tth_sEc6.1.3">
6.1.3</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example2">
</a>

<p>
The incorporation of namespace prefixes into C++ identifier names is necessary to distinguish remote methods that
share the same name but are provided by separate Web services and/or organizations. Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getQuote.h": <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result); <br />
<b>int</b>&nbsp;ns2__getQuote(<b>char</b>&nbsp;*ticker, <b>char</b>&nbsp;*&amp;quote);
</td></tr></table><br></i>
Recall that the namespace prefix is always separated from the name of a remote method by a pair of underscores (<i>__</i>).

<p>
This example enables a client program to connect to a (hypothetical) Stock Quote service with remote methods that can only be
distinghuished by their namespaces. Consequently, two different namespace prefixes had to be used as part of the remote method
names.

<p>
The namespace prefix convention can also be applied to <i><b>class</b></i> declarations that contain SOAP compound values
that share the same name but have different namespaces that refer to different XML schemas. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;<font color="#FF0000">e__Address</font> // an electronic address <br />
{ <br />
&nbsp;&nbsp;&nbsp;char *email; <br />
&nbsp;&nbsp;&nbsp;char *url; <br />
}; <br />
<b>class</b>&nbsp;<font color="#0000FF">s__Address</font> // a street address <br />
{ <br />
&nbsp;&nbsp;&nbsp;char *street; <br />
&nbsp;&nbsp;&nbsp;int number; <br />
&nbsp;&nbsp;&nbsp;char *city; <br />
};
</td></tr></table><br></i>
The namespace prefix is separated from the name of a data type by a pair of underscores (<i>__</i>).

<p>
An instance of <i><font color="#FF0000">e__Address</font></i> is encoded by the generated serializer for this type as an Address element with namespace prefix <i><font color="#FF0000">e</font></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font color="#FF0000">e:Address</font> xsi:type="<font color="#FF0000">e:Address</font>"&#62; <br />
&lt;email xsi:type="string"&#62;me@home&lt;/email&#62; <br />
&lt;url xsi:type="string"&#62;www.me.com&lt;/url&#62; <br />
&lt;/<font color="#FF0000">e:Address</font>&#62;
</td></tr></table><br></tt>
While an instance of <i><font color="#0000FF">s__Address</font></i> is encoded by the generated serializer for this type as an Address element with namespace prefix <i><font color="#0000FF">s</font></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font color="#0000FF">s:Address</font> xsi:type="<font color="#0000FF">s:Address</font>"&#62; <br />
&lt;street xsi:type="string"&#62;Technology Drive&lt;/street&#62; <br />
&lt;number xsi:type="int"&#62;5&lt;/number&#62; <br />
&lt;city xsi:type="string"&#62;Softcity&lt;/city&#62; <br />
&lt;/<font color="#0000FF">s:Address</font>&#62;
</td></tr></table><br></tt>
The namespace mapping table of the client program must have entries for <i><font color="#FF0000">e</font></i> and <i><font color="#0000FF">s</font></i> that refer to the XML schemas of the data types:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;{"<font color="#FF0000">e</font>", "http://www.me.com/schemas/electronic-address"}, <br />
&nbsp;&nbsp;&nbsp;{"<font color="#0000FF">s</font>", "http://www.me.com/schemas/street-address"}, <br />
...
</td></tr></table><br></i> 
This table is required to be part of the client application to allow access by the serializers and deserializers of the data types at run time.

<p>
		      <h4><a name="tth_sEc6.1.4">
6.1.4</a>&nbsp;&nbsp;<font color="#0000FF">How to Generate C++ Client Proxy Classes</font></h4><a name="sec:proxy">
</a>

<p>
Proxy classes for C++ client applications are automatically generated by the gSOAP compiler provided that the WSDL importer is used or
sufficient server details are given in the header file in the form of <i>//gsoap</i> directives, see Section&nbsp;<a href="#sec:directives">13.2</a> for more
details on these directives.

<p>
To illustrate the generation of a proxy class, the <i>getQuote.h</i> header file example of the previous section is augmented with the appropriate directives to enable the gSOAP compiler to
generate the proxy class. Similar directives are included in the header file by the WSDL importer.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Content of file <tt>"getQuote.h"</tt>: <br />
//gsoap ns1 service name: Quote <br />
//gsoap ns1 service location: http://services.xmethods.net/soap <br />
//gsoap ns1 schema namespace: urn:xmethods-delayed-quotes <br />
//gsoap ns1 service method-action: getQuote "" <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The first three directives provide the service name which is used to name the proxy class, the service location (endpoint), and
the schema. The fourth directive defines the optional SOAPAction, which is a string associated with SOAP 1.1 operations.
This directive must be provided for each remote method when the SOAPAction is required.
Compilation of this header file with the gSOAP compiler <i>soapcpp2</i> creates a new file <i>soapQuoteProxy.h</i> with the
following contents:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
<b>class</b>&nbsp;Quote <br />
{ <b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint; <br />
&nbsp;&nbsp;&nbsp;Quote() { soap = soap_new(); endpoint = "http://services.xmethods.net/soap"; }; <br />
&nbsp;&nbsp;&nbsp;~Quote() { <b>if</b>&nbsp;(soap) { soap_destroy(soap); soap_end(soap); soap_done(soap); free((void*)soap); }}; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result) { <b>return</b>&nbsp;soap ? soap_call_ns__getQuote(soap, endpoint, "", symbol, result) : SOAP_EOM; }; <br />
};
</td></tr></table><br></i>
The gSOAP environment and endpoint are declared public to enable access for run-time customization.

<p>
This generated proxy class can be included into a client application together with the generated namespace table as shown in this example:
<i>Quote.nsmap</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include  &lt; iostream.h &gt;  <br />
#include "soapQuoteProxy.h"	// get proxy <br />
#include "Quote.nsmap"		// get namespace bindings <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;Quote q; <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;r; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(q.getQuote("AOL", r) == SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  r  &lt;&lt;  endl; <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(q.soap, stderr); <br />
}
</td></tr></table><br></i>
The <i>Quote</i> constructor allocates and initializes a gSOAP environment for the instance.
All the HTTP and SOAP/XML processing is hidden and performed on the background.

<p>
		      <h4><a name="tth_sEc6.1.5">
6.1.5</a>&nbsp;&nbsp;<font color="#0000FF">XSD Type Encoding Considerations</font></h4><a name="sec:encoding">
</a>

<p>
Many SOAP services require the explicit use of XML schema types in the SOAP payload. The default encoding, which is also adopted
by the gSOAP compiler, assumes SOAP RPC encoding which only requires the use of types to handle polymorphic cases.
Nevertheless, the use of XSD typed messages is adviced to improve interoperability.
XSD types are introduced with <i><b>typedef</b></i> definitions in
the header file input to the gSOAP compiler. The type name defined by a <i><b>typedef</b></i> definition corresponds to an XML schema
type (XSD type). For example, the following <i><b>typedef</b></i> declarations
define various built-in XSD types implemented as primitive C/C++ types:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file: <br />
... <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; // encode xsd__string value as the <span class="roman"><tt>xsd:string</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; // encode xsd__anyURI value as the <span class="roman"><tt>xsd:anyURI</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; // encode xsd__float value as the <span class="roman"><tt>xsd:float</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; // encode xsd__int value as the <span class="roman"><tt>xsd:int</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean; // encode xsd__boolean value as the <span class="roman"><tt>xsd:boolean</tt></span> schema type <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__positiveInteger; // encode xsd__positiveInteger value as the <span class="roman"><tt>xsd:positiveInteger</tt></span>  schema type<br />
...
</td></tr></table><br></i>
This simple mechanism informs the gSOAP compiler to generate serializers and deserializers that explicitly encode and decode the
primitive C++ types as built-in primitive XSD types when the <i>typedef</i>ed type is used in the parameter signature of a
remote method (or when used nested within structs, classes, and arrays).  At the same time, the use of <i><b>typedef</b></i> 
does not force any recoding of a C++ client or Web service application as the internal C++ types used by the application
are not required to be changed (but still have to be primitive C++ types, see Section&nbsp;<a href="#sec:primclass">9.2.2</a> for alternative class
implementations of primitive XSD types which allows for the marshalling of polymorphic primitive types).

<p>
		      <h4><a name="tth_sEc6.1.6">
6.1.6</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example3">
</a>

<p>
Reconsider the <i>getQuote</i> example, now rewritten with explicit XSD types to illustrate the effect:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <font color="#0000FF">xsd__float</font> &amp;<font color="#00FFFF">Result</font>);
</td></tr></table><br></i>
This header file is compiled by the gSOAP stub and skeleton compiler and the compiler generates source code for the function
<i>soap_call_ns1__getQuote</i>, which is identical to the ``old'' proxy:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_ns1__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;Result);
</td></tr></table><br></i>
The client application does not need to be rewritten and can still call the proxy using the ``old'' parameter signature. In contrast to
the previous implementation of the stub however, the encoding and decoding of the data types by the stub has been changed to
explicitly use the XSD types in the message payload.

<p>
For example, when the client application calls the proxy, the proxy produces a SOAP request with an <tt>xsd:string</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;<font color="#00FF00">ns1:getQuote</font>&#62;&lt;<font color="#FF00FF">symbol</font> xsi:type="<font color="#FF0000">xsd:string</font>"&#62;AOL&lt;/<font color="#FF00FF">symbol</font>&#62; <br />
&lt;/<font color="#00FF00">ns1:getQuote</font>&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
...
</td></tr></table><br></tt>
The service response is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;soap:Body&#62; <br />
&lt;<font color="#00FF00">n:getQuote</font>Response xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;<font color="#00FFFF">Result</font> xsi:type='<font color="#0000FF">xsd:float</font>'&#62;41.81&lt;/<font color="#00FFFF">Result</font>&#62; <br />
&lt;/<font color="#00FF00">n:getQuote</font>Response&#62; <br />
&lt;/soap:Body&#62; <br />
...
</td></tr></table><br></tt>
The validation of this service response by the stub routine takes place by matching the namespace names (URIs) that are bound to the
<tt>xsd</tt> namespace prefix. The stub also expects the <tt>getQuoteResponse</tt> element to be associated with URI
<tt>urn:xmethods-delayed-quotes</tt> through the binding of the namespace prefix <tt>ns1</tt> in the namespace mapping table. The
service response uses namespace prefix <tt>n</tt> for the <tt>getQuoteResponse</tt> element. This namespace prefix is bound to the same
URI <tt>urn:xmethods-delayed-quotes</tt> and therefore the service response is assumed to be valid.  The response is
rejected and a SOAP fault is generated when the URIs do not match.

<p>
		      <h4><a name="tth_sEc6.1.7">
6.1.7</a>&nbsp;&nbsp;<font color="#0000FF">How to Change the Response Element Name</font></h4><a name="sec:response">
</a>

<p>
There is no standardized convention for the response element name in a SOAP response message, although it is recommended that the response
element name is the method name ending with ``<tt>Response</tt>''. For example, the response element of <tt>getQuote</tt> is
<tt>getQuoteResponse</tt>.

<p>
The response element name can be specified explicitly using a <i><b>struct</b></i> or <i><b>class</b></i> declaration in the header file. The
<i><b>struct</b></i> or <i><b>class</b></i> name represents the SOAP response element name used by the service. Consequently, the output
parameter of the remote method must be declared as a field of the <i><b>struct</b></i> or <i><b>class</b></i>.  The use of a <i><b>struct</b></i> or a
<i><b>class</b></i> for the service response is fully SOAP 1.1 compliant. In fact, the absence of a <i><b>struct</b></i> or <i><b>class</b></i>
indicates to the gSOAP compiler to automatically generate a <i>struct</i> for the response which is internally used by a stub.

<p>
		      <h4><a name="tth_sEc6.1.8">
6.1.8</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example4">
</a>

<p>
Reconsider the <i>getQuote</i> remote method specification which can be rewritten with an explicit declaration of a SOAP response
element as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> {<font color="#0000FF">xsd__float</font> <font color="#00FFFF">Result</font>;}; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> &amp;r);
</td></tr></table><br></i>
The SOAP request is the same as before:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;<font color="#00FF00">ns1:getQuote</font>&#62;&lt;<font color="#FF00FF">symbol</font> xsi:type="<font color="#FF0000">xsd:string</font>"&#62;AOL&lt;/<font color="#FF00FF">symbol</font>&#62; <br />
&lt;/<font color="#00FF00">ns1:getQuote</font>&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
...
</td></tr></table><br></tt>
The difference is that the service response is required to match the specified <i>getQuoteResponse</i> name and its namespace URI:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;soap:Body&#62; <br />
&lt;<font color="#FFFF00">n:getQuoteResponse</font> xmlns:n='urn:xmethods-delayed-quotes'&#62; <br />
&lt;<font color="#00FFFF">Result</font> xsi:type='<font color="#0000FF">xsd:float</font>'&#62;41.81&lt;/<font color="#00FFFF">Result</font>&#62; <br />
&lt;/<font color="#FFFF00">n:getQuoteResponse</font>&#62; <br />
&lt;/soap:Body&#62; <br />
...
</td></tr></table><br></tt>
This use of a <i><b>struct</b></i> or <i><b>class</b></i> enables the adaptation of the default SOAP response element name and/or namespace URI when required.

<p>
Note that the <i><b>struct</b></i> (or <i><b>class</b></i>) declaration may appear within the function prototype declaration. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*<font color="#FF0000">xsd__string</font>; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;<font color="#0000FF">xsd__float</font>; <br />
<b>int</b>&nbsp;<font color="#00FF00">ns1__getQuote</font>(<font color="#FF0000">xsd__string</font> <font color="#FF00FF">symbol</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns1__getQuoteResponse</font> {<font color="#0000FF">xsd__float</font> <font color="#00FFFF">Result</font>;} &amp;r);
</td></tr></table><br></i>
This example combines the declaration of the response element of the remote method with the function prototype of the remote method.

<p>
		      <h4><a name="tth_sEc6.1.9">
6.1.9</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Multiple Output Parameters</font></h4><a name="sec:multiple">
</a>

<p>
The gSOAP stub and skeleton compiler uses the convention that the 
<b>last parameter</b> of the function prototype declaration of a remove method in a header file
is also the <b>only single output parameter</b> of the method.
All other parameters are considered input parameters of the remote method. To specify a remote method
with <b>multiple output parameters</b>, a <i><b>struct</b></i> or <i><b>class</b></i> must be declared for the remote method response, see
also&nbsp;<a href="#sec:response">6.1.7</a>.  The fields of the <i><b>struct</b></i> or <i><b>class</b></i> are the output parameters of the remote method.
Both the order of the input parameters in the function prototype and the order of the output parameters (the fields in the
<i><b>struct</b></i> or <i><b>class</b></i>) is not significant. However, the SOAP 1.1 specification states that input and output parameters may be
treated as having anonymous parameter names which requires a particular ordering, see Section&nbsp;<a href="#sec:anonymous">6.1.13</a>.

<p>
		      <h4><a name="tth_sEc6.1.10">
6.1.10</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example5">
</a>

<p>
As an example, consider a hypothetical remote method <i>getNames</i> with a single input parameter <i><font color="#FF00FF">SSN</font></i> 
and two output parameters <i><font color="#FF0000">first</font></i> and <i><font color="#0000FF">last</font></i>. This can be specified as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "getNames.h": <br />
<b>int</b>&nbsp;<font color="#00FF00">ns3__getNames</font>(<b>char</b>&nbsp;*<font color="#FF00FF">SSN</font>, <b>struct</b>&nbsp;<font color="#FFFF00">ns3__getNamesResponse</font> {<b>char</b>&nbsp;*<font color="#FF0000">first</font>; <b>char</b>&nbsp;*<font color="#0000FF">last</font>;} &amp;r);
</td></tr></table><br></i>
The gSOAP stub and skeleton compiler takes this header file as input and generates source code for the function <i>soap_call_ns3__getNames</i>. When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ... xmlns:ns3="urn:names" ...&#62; <br />
... <br />
&lt;<font color="#00FF00">ns3:getNames</font>&#62; <br />
&lt;<font color="#FF00FF">SSN</font>&#62;999 99 9999&lt;/<font color="#FF00FF">SSN</font>&#62; <br />
&lt;/<font color="#00FF00">ns3:getNames</font>&#62; <br />
...
</td></tr></table><br></tt>
The response by a SOAP service could be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;<font color="#FFFF00">m:getNamesResponse</font> xmlns:m="urn:names"&#62; <br />
&lt;<font color="#FF0000">first</font>&#62;John&lt;/<font color="#FF0000">first</font>&#62; <br />
&lt;<font color="#0000FF">last</font>&#62;Doe&lt;/<font color="#0000FF">last</font>&#62; <br />
&lt;/<font color="#FFFF00">m:getNamesResponse</font>&#62; <br />
...
</td></tr></table><br></tt>
where <tt><font color="#FF0000">first</font></tt> and <tt><font color="#0000FF">last</font></tt> are the output parameters of the <i>getNames</i> remote method of the service.

<p>
As another example, consider a remote method <i>copy</i> with an input parameter and an output parameter with identical
parameter names (this is not prohibited by the SOAP 1.1 protocol). This can be specified as well using a response <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contente of file "copy.h": <br />
<b>int</b>&nbsp;<font color="#00FF00">X_rox__copy_name</font>(<b>char</b>&nbsp;*<font color="#FF00FF">name</font>, <b>struct</b>&nbsp;<font color="#FFFF00">X_rox__copy_nameResponse</font> {<b>char</b>&nbsp;*<font color="#FF0000">name</font>;} &amp;r);
</td></tr></table><br></i>
The use of a <i><b>struct</b></i> or <i><b>class</b></i> for the remote method response enables the declaration of remote methods that have
parameters that are passed both as input and output parameters.

<p>
The gSOAP compiler takes the <i>copy.h</i> header file as input and generates the <i>soap_call_X_rox__copy_name</i> proxy. When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ... xmlns:X-rox="urn:copy" ...&#62; <br />
... <br />
&lt;<font color="#00FF00">X-rox:copy-name</font>&#62; <br />
&lt;<font color="#FF00FF">name</font>&#62;SOAP&lt;/<font color="#FF00FF">name</font>&#62; <br />
&lt;/<font color="#00FF00">X-rox:copy-name</font>&#62; <br />
...
</td></tr></table><br></tt>
The response by a SOAP copy service could be something like:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;<font color="#FFFF00">m:copy-nameResponse</font> xmlns:m="urn:copy"&#62; <br />
&lt;<font color="#FF0000">name</font>&#62;SOAP&lt;/<font color="#FF0000">name</font>&#62; <br />
&lt;/<font color="#FFFF00">m:copy-nameResponse</font>&#62; <br />
...
</td></tr></table><br></tt>
The name will be parsed and decoded by the proxy and returned in the <i>name</i> field of the <i><b>struct</b>&nbsp;X_rox__copy_nameResponse &amp;r</i> parameter.

<p>
		      <h4><a name="tth_sEc6.1.11">
6.1.11</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Output Parameters With struct/class Compound Data Types</font></h4><a name="sec:compound">
</a>

<p>
If the single output parameter of a remote method is a complex data type such as a <i><b>struct</b></i> or <i><b>class</b></i> it is necessary to
specify the response element of the remote method as a <i><b>struct</b></i> or <i><b>class</b></i> <b>at all times</b>.
Otherwise, the output parameter will
be considered the response element (!), because of the response element specification convention used by gSOAP,
as discussed in&nbsp;<a href="#sec:response">6.1.7</a>.

<p>
		      <h4><a name="tth_sEc6.1.12">
6.1.12</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example6">
</a>

<p>
This is is best illustrated with an example. The Flighttracker service by ObjectSpace provides real time flight information for
flights in the air. It requires an airline code and flight number as parameters.
The remote method name is <i>getFlightInfo</i> and
the method has two string parameters: the airline code and flight number, both of which must be encoded as <tt>xsd:string</tt> types.
The method returns a <i>getFlightResponse</i> response element with a <i>return</i> output parameter that is of complex type
<i>FlightInfo</i>. The type <i>FlightInfo</i> is represented by a <i><b>class</b></i> in the header file, whose field names correspond to
the <i>FlightInfo</i> accessors:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "flight.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>class</b>&nbsp;ns2__FlightInfo <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__string airline; <br />
&nbsp;&nbsp;&nbsp;xsd__string flightNumber; <br />
&nbsp;&nbsp;&nbsp;xsd__string altitude; <br />
&nbsp;&nbsp;&nbsp;xsd__string currentLocation; <br />
&nbsp;&nbsp;&nbsp;xsd__string equipment; <br />
&nbsp;&nbsp;&nbsp;xsd__string speed; <br />
}; <br />
<b>struct</b>&nbsp;ns1__getFlightInfoResponse {ns2__FlightInfo _return;}; <br />
<b>int</b>&nbsp;ns1__getFlightInfo(xsd__string param1, xsd__string param2, <b>struct</b>&nbsp;ns1__getFlightInfoResponse &amp;r);
</td></tr></table><br></i>
The response element <i>ns1__getFlightInfoResponse</i> is explicitly declared and it has one field: <i>return_</i> of type
<i>ns2__FlightInfo</i>.  Note that <i>return_</i> has a trailing underscore to avoid a name clash with the <i><b>return</b></i> keyword,
see Section&nbsp;<a href="#sec:idtrans">8.3</a> for details on the translation of C++ identifiers to XML element names.

<p>
The gSOAP compiler generates the <i>soap_call_ns1__getFlightInfo</i> proxy. Here is an example fragment of a client application that uses this proxy to request flight information:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); <br />
... <br />
soap_call_ns1__getFlightInfo(&amp;soap, <tt>"testvger.objectspace.com/soap/servlet/rpcrouter"</tt>, <br />
&nbsp;&nbsp;&nbsp;<tt>"urn:galdemo:flighttracker"</tt>, <tt>"UAL"</tt>, <tt>"184"</tt>, r); <br />
... <br />
struct Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1", "urn:galdemo:flighttracker"}, <br />
&nbsp;&nbsp;&nbsp;{"ns2", "http://galdemo.flighttracker.com"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
When invoked by a client application, the proxy produces the SOAP request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /soap/servlet/rpcrouter HTTP/1.1 <br />
Host: testvger.objectspace.com <br />
Content-Type: text/xml <br />
Content-Length: 634 <br />
SOAPAction: "urn:galdemo:flighttracker" <br />
<br />
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns1="urn:galdemo:flighttracker" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns2="http://galdemo.flighttracker.com" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getFlightInfo xsi:type="ns1:getFlightInfo"&#62; <br />
&lt;param1 xsi:type="xsd:string"&#62;UAL&lt;/param1&#62; <br />
&lt;param2 xsi:type="xsd:string"&#62;184&lt;/param2&#62; <br />
&lt;/ns1:getFlightInfo&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The Flighttracker service responds with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 ok <br />
Date: Thu, 30 Aug 2001 00:34:17 GMT <br />
Server: IBM_HTTP_Server/1.3.12.3 Apache/1.3.12 (Win32) <br />
Set-Cookie: sesessionid=2GFVTOGC30D0LGRGU2L4HFA;Path=/ <br />
Cache-Control: no-cache="set-cookie,set-cookie2" <br />
Expires: Thu, 01 Dec 1994 16:00:00 GMT <br />
Content-Length: 861 <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Language: en <br />
<br />
&lt;?xml version='1.0' encoding='UTF-8'?&#62; <br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema"&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;ns1:getFlightInfoResponse xmlns:ns1="urn:galdemo:flighttracker" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;return xmlns:ns2="http://galdemo.flighttracker.com" xsi:type="ns2:FlightInfo"&#62; <br />
&lt;equipment xsi:type="xsd:string"&#62;A320&lt;/equipment&#62; <br />
&lt;airline xsi:type="xsd:string"&#62;UAL&lt;/airline&#62; <br />
&lt;currentLocation xsi:type="xsd:string"&#62;188 mi W of Lincoln, NE&lt;/currentLocation&#62; <br />
&lt;altitude xsi:type="xsd:string"&#62;37000&lt;/altitude&#62; <br />
&lt;speed xsi:type="xsd:string"&#62;497&lt;/speed&#62; <br />
&lt;flightNumber xsi:type="xsd:string"&#62;184&lt;/flightNumber&#62; <br />
&lt;/return&#62; <br />
&lt;/ns1:getFlightInfoResponse&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
The proxy returns the service response in variable <i>r</i> of type <i><b>struct</b>&nbsp;ns1__getFlightInfoResponse</i> and this information can be displayed by the client application with the following code fragment:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
cout  &lt;&lt;  r.return_.equipment  &lt;&lt;  " flight "  &lt;&lt;  r.return_.airline  &lt;&lt;  r.return_.flightNumber <br />
&nbsp;&nbsp;&nbsp; &lt;&lt;  " traveling "  &lt;&lt;  r.return_.speed  &lt;&lt;  " mph "  &lt;&lt;  " at "  &lt;&lt;  r.return_.altitude <br />
&nbsp;&nbsp;&nbsp; &lt;&lt;  " ft, is located "  &lt;&lt;  r.return_.currentLocation &lt;&lt; endl;
</td></tr></table><br></i>
This code displays the service response as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<tt>A320 flight UAL184 traveling 497 mph at 37000 ft, is located 188 mi W of Lincoln, NE</tt>
</td></tr></table><br></span>
Note: the flight tracker service is no longer available since 9/11/2001. It is kept in the documentation as an example to illustrate the use of structs/classes and response types.

<p>
		      <h4><a name="tth_sEc6.1.13">
6.1.13</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Anonymous Parameter Names</font></h4><a name="sec:anonymous">
</a>

<p>
The SOAP 1.1 protocol allows parameter names to be anonymous.  That is, the name(s) of the output
parameters of a remote method are not strictly required to match a client's view of the parameters names.  Also, the
input parameter names of a remote method are not striclty required to match a service's view of the parameter names.  Although
this convention is likely to be deprecated in SOAP 1.2, the gSOAP compiler can generate stub and skeleton
routines that support anonymous parameters.  Parameter names are implicitly
anonymous by omitting the parameter names in the function prototype of the
remote method. For
example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>int</b>&nbsp;ns1__getQuote(xsd__string, xsd__float&amp;);
</td></tr></table><br></i>
To make parameter names explicitly anonymous on the receiving side (client or service),
the parameter names should start with an underscore (<i>_</i>) in the function prototype in the header file.

<p>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>int</b>&nbsp;ns1__getQuote(xsd__string symbol, xsd__float &amp;_return);
</td></tr></table><br></i>
Or, alternatively with a response <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of "getQuote.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>struct</b>&nbsp;ns1__getQuoteResponse {xsd__float _return;}; <br />
<b>int</b>&nbsp;ns1__getQuote(xsd__string symbol, <b>struct</b>&nbsp;ns1__getQuoteResponse &amp;r);
</td></tr></table><br></i>
In this example, <i>_return</i> is an anonymous output parameter.
As a consequence, the service response to a request made by a client created with gSOAP using this header file specification
may include any name for the output parameter in the SOAP payload.
The input parameters may also be anonymous. This affects the implementation of Web services in gSOAP
and the matching of parameter names by the service.

<p>
<font color="#FF0000"><b>Caution</b></font>: when anonymous parameter names are used, the order of the parameters in the function prototype of a remote method is
significant.

<p>
		      <h4><a name="tth_sEc6.1.14">
6.1.14</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify a Method with No Input Parameters</font></h4>

<p>
To specify a remote method that has no input parameters, just provide a function prototype with one parameter which is the output
parameter.  However, some C/C++ compilers (notably Visual C++<sup><span class="roman">TM</span></sup>) will not compile and complain about an empty
<i><b>struct</b></i>.  This <i><b>struct</b></i> is generated by gSOAP to contain the SOAP request message.  To fix this, provide one input
parameter of type <i><b>void</b>*</i> (gSOAP can not serialize <i>void*</i> data).  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns3__SOAPService <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;ID; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*owner; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*description; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*homepageURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*endpoint; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAPAction; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodNamespaceURI; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serviceStatus; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*dateCreated; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*downloadURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*wsdlURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*instructions; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*contactEmail; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serverImplementation; <br />
}; <br />
<b>struct</b>&nbsp;ArrayOfSOAPService {<b>struct</b>&nbsp;ns3__SOAPService *__ptr; <b>int</b>&nbsp;__size;}; <br />
<b>int</b>&nbsp;ns__getAllSOAPServices(<b>void</b>&nbsp;*_, <b>struct</b>&nbsp;ArrayOfSOAPService &amp;_return);
</td></tr></table><br></i>
The <i>ns__getAllSOAPServices</i> method has one <i><b>void</b>*</i> input parameter which is ignored by the serializer to produce the
request message.

<p>
Most C/C++ compilers allow empty <i><b>struct</b></i>s and therefore the <i><b>void</b>*</i> parameter is not required.

<p>
		      <h4><a name="tth_sEc6.1.15">
6.1.15</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify a Method with No Output Parameters</font></h4>

<p>
To specify a remote method that has no output parameters, just provide a function prototype with a response struct that is
empty. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns__event { off, on, stand_by }; <br />
<b>int</b>&nbsp;ns__signal(<b>enum</b>&nbsp;ns__event in, <b>struct</b>&nbsp;ns__signalResponse { } *out);
</td></tr></table><br></i>
Since the response struct is empty, no output parameters are specified.
Most C/C++ compilers allow empty <i><b>struct</b></i>s. For those that don't, use a <i><b>void</b>*</i> parameter in the struct.
This parameter is not (de)serialized.

<p>
Some SOAP resources refer to SOAP RPC with empty responses as <b>one way</b> SOAP messaging. However, we refer to one-way massaging
by asynchronous explicit send and receive operations as described in Section&nbsp;<a href="#sec:oneway">6.3</a>. We found
this view of one-way SOAP messaging more useful by providing a message passing alternative to SOAP RPC.

<p>
	     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Use the gSOAP Stub and Skeleton Compiler to Build SOAP Web Services</font></h3>

<p>
The gSOAP stub and skeleton compiler generates <b>skeleton</b> routines in C++ source form for each of the remote methods specified
as function prototypes in the header file processed by the gSOAP compiler.  The skeleton routines can be readily used to implement
the remote methods in a new SOAP Web service. The compound data types used by the input and output parameters of SOAP remote
methods must be declared in the header file, such as structs, classes, arrays, and pointer-based data structures (graphs) that are
used as the data types of the parameters of a remote method. The gSOAP compiler automatically generates serializers and
deserializers for the data types to enable the generated skeleton routines to encode and decode the contents of the parameters of
the remote methods.  The gSOAP compiler also generates a remote method request dispatcher routine that will serve requests by
calling the appropriate skeleton when the SOAP service application is installed as a CGI application on a Web server.

<p>
		      <h4><a name="tth_sEc6.2.1">
6.2.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example7">
</a>

<p>
The following example specifies three remote methods to be implemented by a new SOAP Web service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "calc.h": <br />
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>int</b>&nbsp;ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sqrt(xsd__double a, xsd__double &amp;result); <br />
</td></tr></table><br></i>
The <i>add</i> and <i>sub</i> methods are intended to add and subtract two double floating point numbers stored in input parameters
<i>a</i> and <i>b</i> and should return the result of the operation in the <i>result</i> output parameter. The <i>qsrt</i> method is
intended to take the square root of input parameter <i>a</i> and to return the result in the output parameter <i>result</i>.
The <i>xsd__double</i> type is recognized by the gSOAP compiler as the <tt>xsd:double</tt> XML schema data type.
The use of <i><b>typedef</b></i> is a convenient way to associate primitive C types with primitive XML schema data types.

<p>
To generate the skeleton routines, the gSOAP compiler is invoked from the command line with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 calc.h</i>
</td></tr></table><br></span>
The compiler generates the skeleton routines for the <i>add</i>, <i>sub</i>, and <i>sqrt</i> remote methods specified in the
<i>calc.h</i> header file. The skeleton routines are respectively, <i>soap_serve_ns__add</i>, <i>soap_serve_ns__sub</i>, and
<i>soap_serve_ns__sqrt</i> and saved in the file <i>soapServer.cpp</i>. The generated file <i>soapC.cpp</i> contains serializers
and deserializers for the skeleton. The compiler also generates a service dispatcher: the <i>soap_serve</i> function handles
client requests on the standard input stream and dispatches the remote method requests to the appropriate skeletons to serve the
requests. The skeleton in turn calls the remote method implementation function. The function prototype of the remote method
implementation function is specified in the header file that is input to the gSOAP compiler.

<p>
Here is an example Calculator service application that uses the generated <i>soap_serve</i> routine to handle client requests:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "calc.cpp": <br />
#include "soapH.h" <br />
#include  &lt; math.h &gt;  // for sqrt() <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); // use the remote method request dispatcher <br />
} <br />
// Implementation of the "add" remote method: <br />
<b>int</b>&nbsp;ns__add(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;b, <b>double</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;result = a + b; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// Implementation of the "sub" remote method: <br />
<b>int</b>&nbsp;ns__sub(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;b, <b>double</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;result = a - b; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// Implementation of the "sqrt" remote method: <br />
<b>int</b>&nbsp;ns__sqrt(<b>struct</b>&nbsp;soap *soap, <b>double</b>&nbsp;a, <b>double</b>&nbsp;&amp;result); <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(a  &gt; = 0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = sqrt(a); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;soap_receiver_fault(soap, "Square root of negative number", "I can only take the square root of a non-negative number"); <br />
} <br />
// As always, a namespace mapping table is needed: <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns",       "urn:simple-calc"}, // bind "ns" namespace prefix <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
Note that the remote methods have an extra input parameter which is a pointer to the gSOAP runtime environment.
The implementation of the remote methods MUST return a SOAP error code. The code <i>SOAP_OK</i> denotes success, while
<i>SOAP_FAULT</i> denotes an exception with details that can be defined by the user. The exception description can be assigned to
the <i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>faultstring</i> string and details can be assigned to the
<i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>detail</i> string. This is SOAP 1.1 specific. SOAP 1.2 requires
the <i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>SOAP_ENV__Reason</i> and the
<i>soap</i><tt>-&gt;</tt><i>fault</i><tt>-&gt;</tt><i>SOAP_ENV__Detail</i> strings to be assigned.
Better is to use the
<i>soap_receiver_fault</i> function that allocates a fault struct and sets the SOAP Fault string and details
regardless of the SOAP 1.1 or SOAP 1.2 version used. The <i>soap_receiver_fault</i> function returns
<i>SOAP_FAULT</i>, i.e.&nbsp;an application-specific fault. The fault exception will be passed on to the client of this service.

<p>
This service application can be readily installed as a CGI application. The service description would be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td>Endpoint URL: </td><td>the URL of the CGI application </td></tr>
<tr><td>SOAP action: </td><td>"" (2 quotes) </td></tr>
<tr><td>Remote method namespace: </td><td><tt>urn:simple-calc</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>add</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameters: </td><td><tt>a</tt> of type <tt>xsd:double</tt> and <tt>b</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>sub</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameters: </td><td><tt>a</tt> of type <tt>xsd:double</tt> and <tt>b</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>Remote method name: </td><td><tt>sqrt</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Input parameter: </td><td><tt>a</tt> of type <tt>xsd:double</tt> </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;Output parameter: </td><td><tt>result</tt> of type <tt>xsd:double</tt> or a SOAP Fault
</td></tr></table>

</td></tr></table><br></span>
The <i>soapcpp2</i> compile generates a WSDL file for this service, see Section&nbsp;<a href="#sec:wsdl">6.2.5</a>.

<p>
Unless the CGI application inspects and checks the environment variable <i>SOAPAction</i> which contains the SOAP action request by
a client, the SOAP action is ignored by the CGI application.  SOAP actions are specific to the SOAP protocol and provide a means
for routing requests and for security reasons (e.g.&nbsp;firewall software can inspect SOAP action headers to grant or deny the
SOAP request. Note that this requires the SOAP service to check the SOAP action header as well to match it with the remote method.)

<p>
The header file input to the gSOAP compiler does not need to be modified to generate client stubs for accessing this
service.  Client applications can be developed by using the same header file as for which the service application
was developed.  For example, the <i>soap_call_ns__add</i> proxy is available from the <i>soapClient.cpp</i> file after invoking
the gSOAP compiler on the <i>calc.h</i> header file. As a result, client and service applications can be developed without
the need to know the details of the SOAP encoding used.

<p>
		      <h4><a name="tth_sEc6.2.2">
6.2.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Create a Stand-Alone gSOAP Service</font></h4>

<p>
The deployment of a Web service as a CGI application is an easy means to provide your service on the Internet.
gSOAP services can also run as stand-alone services on any port by utilizing the built-in HTTP and TCP/IP stacks.
The stand-alone services can be run on port 80 thereby providing Web server capabilities restricted to SOAP RPC.

<p>
To create a stand-alone service, only the <i>main</i> routine of the service needs to be modified as follows.  Instead of just calling the
<i>soap_serve</i> routine, the <i>main</i> routine is changed into:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; // master and slave sockets <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, <tt>"machine.cs.fsu.edu"</tt>, 18083, 100); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful: master socket = %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 1; ; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"%d: accepted connection from IP=%d.%d.%d.%d socket=%d"</tt>, i, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(soap.ip &lt;&lt; 24)&amp;0xFF, (soap.ip &lt;&lt; 16)&amp;0xFF, (soap.ip &lt;&lt; 8)&amp;0xFF, soap.ip&amp;0xFF, s); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap);	// process RPC request <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"request served\n"</tt>); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_destroy(&amp;soap);	// clean up class instances <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap);	// clean up everything and close socket <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_done(&amp;soap); // close master socket <br />
}
</td></tr></table><br></i>
The gSOAP functions that can be used are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="301"><font color="#FF0000"><b>Function</b></font> </td><td width="301"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td width="301"><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Initializes gSOAP runtime environment (required once) </td></tr>
<tr><td width="301"><i>soap_bind(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*host, <b>int</b>&nbsp;port, <b>int</b>&nbsp;backlog)</i> </td><td width="301">Returns master socket (backlog = max.&nbsp;queue
size for requests). When <i>host==NULL</i>: host is the machine on which the service runs </td></tr>
<tr><td width="301"><i>soap_accept(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Returns slave socket </td></tr>
<tr><td width="301"><i>soap_end(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up deserialized data (except class instances) and temporary data </td></tr>
<tr><td width="301"><i>soap_free(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up temporary data only </td></tr>
<tr><td width="301"><i>soap_destroy(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Clean up deserialized class instances </td></tr>
<tr><td width="301"><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="301">Reset: close master/slave sockets and remove callbacks </td></tr>
<tr><td width="301"></td><td width="301">(see Section&nbsp;<a href="#sec:callback">13.7</a> </td></tr></table>

</td></tr></table><br></span>
The <i>host</i> name in <i>soap_bind</i> may be NULL to indicate that the current host should be used.

<p>
The <i>soap.accept_timeout</i> attribute of the gSOAP run-time environment specifies the timeout value for a non-blocking
<i>soap_accept(&amp;soap)</i> call. See Section&nbsp;<a href="#sec:timeout">13.14</a> for more details on timeout management.

<p>
See Section&nbsp;<a href="#sec:memory">7.11</a> for more details on memory management.

<p>
A client application connects to this stand-alone service with the endpoint
<i>machine.cs.fsu.edu:18083</i>.
A client may use the <i>http://</i> prefix. When absent, no HTTP header is send and no HTTP-based information will be communicated
to the service.

<p>
		      <h4><a name="tth_sEc6.2.3">
6.2.3</a>&nbsp;&nbsp;<font color="#0000FF">How to Create a Multi-Threaded Stand-Alone Service</font></h4><a name="sec:mt">
</a>

<p>
Multi-threading a Web Service is essential when the response times for handling requests by the service are (potentially) long or when keep-alive is enabled, see Section&nbsp;<a href="#sec:keepalive">13.9</a>.
In case of long response times, the latencies introduced by the unrelated requests may become prohibitive for a successful
deployment of a stand-alone service. When HTTP keep-alive is enabled, a client may not close the socket on time, thereby preventing other clients from connecting.

<p>
gSOAP 2.0 and higher is thread safe and supports the implementation of multi-threaded stand-alone services in which
a thread is used to handle a request.

<p>
Here is an example of a multi-threaded Web Service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; pthread.h &gt;  <br />
#define BACKLOG (100)	// Max. request backlog <br />
#define MAX_THR (8)	// Max. threads to serve requests <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  3) // no args: assume this is a CGI application <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); // serve request, one thread, CGI style <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // cleanup <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap_thr[MAX_THR]; // each thread needs a runtime environment <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t tid[MAX_THR]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*host = argv[1]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;port = atoi(argv[2]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s, i; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, host, port, BACKLOG); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(i = 0; i  &lt;  MAX_THR; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i] = NULL; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(i = 0; i  &lt;  MAX_THR; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n"</tt>, i, s, (soap.ip &gt;&gt; 24)&amp;0xFF,
(soap.ip &gt;&gt; 16)&amp;0xFF, (soap.ip &gt;&gt; 8)&amp;0xFF, soap.ip&amp;0xFF); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap_thr[i]) // first time around <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i] = soap_new(); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap_thr[i]) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); // could not allocate <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b>\	// recycle soap environment <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(tid[i], NULL); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, "Thread <tt>%</tt>d completed<tt>\</tt>n", i); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(soap_thr[i]); // deallocate data of old thread <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_thr[i]<tt>-&gt;</tt>socket = s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid[i], NULL, (<b>void</b>*(*)(<b>void</b>*))soap_serve, (<b>void</b>*)soap_thr[i]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
}
</td></tr></table><br></i>
The example illustrates the use of threads to improve the quality of service by handling new requests in separate threads.
Each thread needs a separate runtime environment. The example above requires threads to synchronize at some point, so runaway
processes can be halted (not shown in the code). The next example detaches threads. No attempt is made to synchronize threads.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include  &lt; pthread.h &gt;  <br />
#define BACKLOG (100)	// Max. request backlog <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  3) // no args: assume this is a CGI application <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); // serve request, one thread, CGI style <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); // cleanup <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;*process_request(<b>void</b>*); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *tsoap; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*host = argv[1]; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;port = atoi(argv[2]); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, host, port, BACKLOG); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n"</tt>, i, s, (soap.ip &gt;&gt; 24)&amp;0xFF,
(soap.ip &gt;&gt; 16)&amp;0xFF, (soap.ip &gt;&gt; 8)&amp;0xFF, soap.ip&amp;0xFF); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap = soap_copy(&amp;soap); // make a safe copy <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!tsoap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, (<b>void</b>*(*)(<b>void</b>*))process_request, (<b>void</b>*)tsoap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>void</b>&nbsp;*process_request(<b>void</b>&nbsp;*soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;pthread_detach(pthread_self()); <br />
&nbsp;&nbsp;&nbsp;soap_serve((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_end((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
}
</td></tr></table><br></i>
The following functions can be used to setup a gSOAP runtime environment (<i><b>struct</b>&nbsp;soap</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td width="351"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_init(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Initializes a runtime environment (required only once) </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_new()</i> </td><td width="351">Allocates, initializes, and returns a pointer to a runtime environment </td></tr>
<tr><td><i><b>struct</b>&nbsp;soap *soap_copy(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Allocates a new runtime invironment and copies contents of
the argument environment such that the new environment does not share data with the argument environment </td></tr>
<tr><td><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td width="351">Reset, close communications, and remove callbacks </td></tr></table>

</td></tr></table><br></span>
A new environment is required for each new thread to guarantee exclusive access
to runtime environments by threads.

<p>
For clean termination of the server, the master socket can be closed and callbacks removed with <i>soap_done(<b>struct</b>&nbsp;soap *soap)</i>.

<p>
		      <h4><a name="tth_sEc6.2.4">
6.2.4</a>&nbsp;&nbsp;<font color="#0000FF">Some Web Service Implementation Issues</font></h4>

<p>
The same client header file specification issues apply to the specification and implementation of a SOAP Web service. Refer to

<ul><p>
<li> <a href="#sec:namespace">6.1.2</a> for namespace considerations.</li>
<p>
<li> <a href="#sec:encoding">6.1.5</a> for an explanation on how to change the encoding of the primitive types.</li>
<p>
<li> <a href="#sec:response">6.1.7</a> for a discussion on how the response element format can be controlled.</li>
<p>
<li> <a href="#sec:multiple">6.1.9</a> for details on how to pass multiple output parameters from a remote method.</li>
<p>
<li> <a href="#sec:compound">6.1.11</a> for passing complex data types as output parameters.</li>
<p>
<li> <a href="#sec:anonymous">6.1.13</a> for anonymizing the input and output parameter names.</li>
</ul>

<p>
		      <h4><a name="tth_sEc6.2.5">
6.2.5</a>&nbsp;&nbsp;<font color="#0000FF">How to Generate WSDL Service Descriptions</font></h4><a name="sec:wsdl">
</a>

<p>
The gSOAP stub and skeleton compiler <i>soapcpp2</i> generates WSDL (Web Service Description Language) service descriptions and XML schema files
when processing a header file.  The compiler produces one WSDL file for a set of remote methods.  The names of the function
prototypes of the remote methods must use the same namespace prefix and the namespace prefix is used to name the WSDL file.  If
multiple namespace prefixes are used to define remote methods, multiple WSDL files will be created and each file describes the set
of remote methods belonging to a namespace prefix.

<p>
In addition to the generation of the <tt>ns.wsdl</tt> file, a file with a namespace mapping table is generated by the gSOAP
compiler. An example mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
struct Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", \"http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", \"http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "http://tempuri.org"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
This file can be incorporated in the
client/service application, see Section&nbsp;<a href="#sec:nstable">8.4</a> for details on namespace mapping tables.

<p>
To deploy a Web service, copy the compiled CGI service application to the designated CGI directory of your Web server.
Make sure the proper file permissions are set (<tt>chmod 755 calc.cgi</tt> for Unix/Linux).
You can then publish the WSDL file on the Web by placing it in the appropriate Web server directory.

<p>
The gSOAP compiler also generates XML schema files for all C/C++
complex types (e.g.&nbsp;<i><b>struct</b></i>s and <i><b>class</b></i>es) when declared with a namespace prefix.
These files are named <tt>ns.xsd</tt>, where <tt>ns</tt> is the namespace prefix used in the declaration of the complex type.
The XML schema files do not have to be published as the WSDL file already contains the appropriate XML schema definitions.

<p>
		      <h4><a name="tth_sEc6.2.6">
6.2.6</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example8">
</a>

<p>
For example, suppose the following methods are defined in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>int</b>&nbsp;ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); <br />
<b>int</b>&nbsp;ns__sqrt(xsd__double a, xsd__double &amp;result); <br />
</td></tr></table><br></i>
Then, one WSDL file will be created with the file name <tt>ns.wsdl</tt> that describes all three remote methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;definitions name="Service" <br />
&nbsp;&nbsp;&nbsp;xmlns="http://schemas.xmlsoap.org/wsdl/" <br />
&nbsp;&nbsp;&nbsp;targetNamespace="http://location/Service.wsdl" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP="http://schemas.xmlsoap.org/wsdl/soap/" <br />
&nbsp;&nbsp;&nbsp;xmlns:WSDL="http://schemas.xmlsoap.org/wsdl/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2000/10/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:tns="http://location/Service.wsdl" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://tempuri.org"&#62; <br />
&lt;types&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;schema <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://www.w3.org/2000/10/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targetNamespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="addResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="subResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;complexType name="sqrtResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="result" type="double" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;anyAttribute namespace="##other"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/complexType&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/schema&#62; <br />
&lt;/types&#62; <br />
&lt;message name="addRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="b" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="addResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="subRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="b" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="subResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="sqrtRequest"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="a" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;message name="sqrtResponse"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;part name="result" type="xsd:double"/&#62; <br />
&lt;/message&#62; <br />
&lt;portType name="ServicePortType"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="add"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:addRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:addResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sub"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:subRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:subResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sqrt"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input message="tns:sqrtRequest"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output message="tns:sqrtResponse"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&lt;/portType&#62; <br />
&lt;binding name="ServiceBinding" type="tns:ServicePortType"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="add"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="http://tempuri.org#add"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sub"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="http://tempuri.org#sub"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;operation name="sqrt"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:operation soapAction="http://tempuri.org#sqrt"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/input&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;output&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:body use="encoded" namespace="http://tempuri.org" <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/output&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/operation&#62; <br />
&lt;/binding&#62; <br />
&lt;service name="Service"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;port name="ServicePort" binding="tns:ServiceBinding"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SOAP:address location="http://location/Service.cgi"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/port&#62; <br />
&lt;/service&#62; <br />
&lt;/definitions&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc6.2.7">
6.2.7</a>&nbsp;&nbsp;<font color="#0000FF">How to Import WSDL Service Descriptions</font></h4><a name="sec:wsdlin">
</a>

<p>
Note: see <i>README.txt</i> in the <i>wsdlcpp</i> directory for installation
instructions for the importer.

<p>
The creation of SOAP Web Service clients from a WSDL service description is a
two-step process.

<p>
First, execute <i>java wsdlcpp <u><span class="roman">file</span></u>.wsdl</i> which generates the
a header file <i><u><span class="roman">file</span></u>.h</i> and a C-source file
<i><u><span class="roman">file</span></u>.c</i> with an example client program template.  Modify
the client program template to your needs.  Use <i>java wsdlcpp -c
<u><span class="roman">file</span></u>.wsdl</i> to generate C-only code.

<p>
Second, the header file <i><u><span class="roman">file</span></u>.h</i> is to be processed by the
gSOAP compiler by executing <i>soapcpp2 <u><span class="roman">file</span></u>.h</i>.  This
creates the C/C++ source files to build a client application,
see&nbsp;<a href="#sec:client">6.1</a>.  In addition, this generates a client proxy object
declared in <i>soap<u><span class="roman">Service</span></u>Proxy.h</i>, where
<span class="roman"><u>Service</u></span> is the name of the service defined in the WSDL.  To
use this object, include the <i>soap<u><span class="roman">Service</span></u>Proxy.h</i> and
<i><u><span class="roman">Service</span></u>.nsmap</i> files in your C++ client application.  The
<span class="roman"><u>Service</u></span> class provides the remote Web service methods as class
members.

<p>
		      <h4><a name="tth_sEc6.2.8">
6.2.8</a>&nbsp;&nbsp;<font color="#0000FF">How to Use Client Functionalities Within a Service</font></h4>

<p>
A gSOAP service may make client calls to other services from within its remove
methods. This is best illustrated with an example.  The following example is a
more sophisticated example that combines the functionality of two Web services
into one new SOAP Web service.  The service provides a currency-converted stock
quote.  To serve a request, the service in turn requests the stock quote and
the currency-exchange rate from two XMethods services.

<p>
In addition to being a client of two XMethods services, this service
application can also be used as a client of itself to test the implementation.
As a client invoked from the command-line, it will return a currency-converted
stock quote by connecting to a copy of itself installed as a CGI application on
the Web to retrieve the quote after which it will print the quote on the
terminal.

<p>
The header file input to the gSOAP compiler is given below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "quotex.h": <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result); // XMethods delayed stock quote service remote method <br />
<b>int</b>&nbsp;ns2__getRate(<b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result); // XMethods currency-exchange service remote method <br />
<b>int</b>&nbsp;ns3__getQuote(<b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result); // the new currency-converted stock quote service <br />
</td></tr></table><br></i>
The <i>quotex.cpp</i> client/service application source is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "quotex.cpp": <br />
#include "soapH.h"	// include generated proxy and SOAP support <br />
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;q; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc &lt;= 2) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<b>if</b>&nbsp;(soap_call_ns3__getQuote(&amp;soap, <tt>"http://www.cs.fsu.edu/~engelen/quotex.cgi"</tt>, NULL, argv[1], argv[2], q)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<tt>"\nCompany %s: %f (%s)\n"</tt>, argv[1], q, argv[2]); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>int</b>&nbsp;ns3__getQuote(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;q, r; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ns1__getQuote(soap, <tt>"http://services.xmethods.net/soap"</tt>, NULL, symbol, q) == 0 &amp;&amp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_call_ns2__getRate(soap, <tt>"http://services.xmethods.net/soap"</tt>, NULL, <tt>"us"</tt>, country, r) == 0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = q*r; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_FAULT;	// pass soap fault messages on to the client of this app <br />
} <br />
/* Since this app is a combined client-server, it is put together with <br />
 * one header file that describes all remote methods. However, as a consequence we <br />
 * have to implement the methods that are not ours. Since these implementations are <br />
 * never called (this code is client-side), we can make them dummies as below. <br />
 */ <br />
<b>int</b>&nbsp;ns1__getQuote(<b>struct</b>soap *soap, <b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result) <br />
{ <b>return</b>&nbsp;SOAP_NO_METHOD; } // dummy: will never be called <br />
<b>int</b>&nbsp;ns2__getRate(<b>struct</b>soap *soap, <b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result) <br />
{ <b>return</b>&nbsp;SOAP_NO_METHOD; } // dummy: will never be called <br />
 <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema",          "http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1", "urn:xmethods-delayed-quotes"}, <br />
&nbsp;&nbsp;&nbsp;{"ns2", "urn:xmethods-CurrencyExchange"}, <br />
&nbsp;&nbsp;&nbsp;{"ns3", "urn:quotex"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
To compile:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 quotex.h</i> <br />
<i>g++ -o quotex.cgi quotex.cpp soapC.cpp soapClient.cpp soapServer.cpp stdsoap2.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span>
Note: under Linux and Mac OS X you can often omit the <tt>-l</tt> libraries.

<p>
The <i>quotex.cgi</i> executable is installed as a CGI application on the Web by
copying it in the designated directory specific to your Web server.  After
this, the executable can also serve to test the service.  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>quotex.cgi AOL uk</i>
</td></tr></table><br></span>
returns the quote of <i>AOL</i> in <i>uk</i> pounds by communicating the request
and response quote from the CGI application.  See
<a href="http://xmethods.com/detail.html?id=5"><tt>http://xmethods.com/detail.html?id=5</tt></a> for details on the currency
abbreviations.

<p>
When combining clients and service functionalities, it is required to use one
header file input to the compiler.  As a consequence, however, stubs and
skeletons are available for <b>all</b> remote methods, while the client part
will only use the stubs and the service part will use the skeletons.  Thus,
dummy implementations of the unused remote methods need to be given which are
never called.

<p>
Three WSDL files are created by gSOAP: <tt>ns1.wsdl</tt>, <tt>ns2.wsdl</tt>, and
<tt>ns3.wsdl</tt>. Only the <tt>ns3.wsdl</tt> file is required to be published as it
contains the description of the combined service, while the others are
generated as a side-effect (and in case you want to develop these separate
services).

<p>
	     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;<font color="#0000FF">How to Use gSOAP for Asynchronous One-Way Message Passing</font></h3><a name="sec:oneway">
</a>

<p>
SOAP RPC client-server interaction is synchonous: the client blocks until the server responds to the request.
gSOAP also supports asynchronous one-way message passing.
SOAP messaging routines are declared as function prototypes, just like remote methods for SOAP RPC.  However, the output parameter is a
<i><b>void</b></i> type to indicate the absence of a return value.

<p>
For example, the following header file specifies a event message for SOAP messaging:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__event(<b>int</b>&nbsp;eventNo, <b>void</b>&nbsp;dummy);
</td></tr></table><br></i>
The gSOAP stub and skeleton compiler generates the following functions in <i>soapClient.cpp</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_send_ns__event(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;URL, <b>const</b>&nbsp;<b>char</b>&nbsp;action, <b>int</b>&nbsp;event); <br />
<b>int</b>&nbsp;soap_recv_ns__event(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;ns__event *dummy); <br />
</td></tr></table><br></i>
The <i>soap_send_ns__event</i> function transmits the message to the destination URL by opening a socket and sending the SOAP encoded
message. The socket will remain
open after the send and has to be closed with <i>soap_closesock()</i>.  The open socket connection can also be used to obtain a service
response, e.g. with a <i>soap_recv</i> function call.

<p>
The <i>soap_recv_ns__event</i> function waits for a SOAP message on the currently open socket (<i>soap.socket</i>) and fills the
<i><b>struct</b>&nbsp;ns__event</i> with the <i>ns__event</i> parameters (e.g. <i><b>int</b>&nbsp;eventNo</i>).
The <i><b>struct</b>&nbsp;ns__event</i> is automatically created by gSOAP and is a mirror image of the <i>ns__event</i> parameters:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__event <br />
{ <b>int</b>&nbsp;eventNo; <br />
}
</td></tr></table><br></i>
The gSOAP generated <i>soapServer.cpp</i> code includes a skeleton routine to accept the message.
(The skeleton routine does not respond with a SOAP response message.)
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_serve_ns__event(<b>struct</b>&nbsp;soap *soap);
</td></tr></table><br></i>
The skeleton routine calls the user-implemented <i>ns__event(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;eventNo)</i> routine (note tha absence of the void
parameter!).

<p>
As usual, the skeleton will be automatically called by the remote method request dispatcher that handles both the remote method
requests (RPCs) and messages:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
main() <br />
{ soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;ns__event(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;eventNo) <br />
{ <br />
&nbsp;&nbsp;&nbsp;... // handle event <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;<font color="#0000FF">How to Use the SOAP Serializers and Deserializers to Save and Load Application Data</font></h3>

<p>
The gSOAP stub and skeleton compiler generates serializers and deserializers for all user-defined data structures that are
specified in the header file input to the compiler. The serializers and deserializers can be found in the generated
<i>soapC.cpp</i> file. These serializers and deserializers can be used separately by an application without the need to build a
full client or service application.  This is useful for applications that need to save or export their data in XML or need to
import or load data stored in XML format.

<p>
The following attributres can be set to control the destination and source for serialization and deserialization:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Variable</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap.socket</i> </td><td>socket file descriptor for input and output or -1 </td></tr>
<tr><td><i>soap.sendfd</i> </td><td>when <i>soap_socket</i> &lt; 0 this is the file descriptor for send operations </td></tr>
<tr><td><i>soap.recvfd</i> </td><td>when <i>soap_socket</i> &lt; 0 this is the file descriptor for receive operations </td></tr></table>

</td></tr></table><br></span>
The following initializing and finalizing functions can be used:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i><b>void</b>&nbsp;soap_begin_send(<b>struct</b>&nbsp;soap*)</i>	</td><td>start a send/write phase </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_end_send(<b>struct</b>&nbsp;soap*)</i> 	</td><td>flush the buffer </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_begin_recv(<b>struct</b>&nbsp;soap*)</i>	</td><td>start a rec/read phase (if an HTTP header is present, parse it first) </td></tr>
<tr><td><i><b>int</b>&nbsp;soap_end_recv(<b>struct</b>&nbsp;soap*)</i> 	</td><td>perform a id/href consistancy check on deserialized data </td></tr></table>

</td></tr></table><br></span>
See also Section&nbsp;<a href="#sec:flags">7.10</a> to control the I/O buffering and content encoding such as compression and DIME encoding with flags.

<p>
		      <h4><a name="tth_sEc6.4.1">
6.4.1</a>&nbsp;&nbsp;<font color="#0000FF">Serializing a Data Type</font></h4><a name="sec:serialize">
</a>

<p>
To serialize a data type, two functions need to be called to process the data. The first function (<i>soap_serialize</i>) analyzes
pointers and determines if multi-references are required to encode the data and if the data contains cycles. The second function
(<i>soap_put</i>) generates the SOAP encoding output for that data type.

<p>
The function names are specific to a data type. For example, <i>soap_serialize_float(&amp;soap, &amp;d)</i> is called to serialize an
<i><b>float</b></i> value and <i>soap_put_float(&amp;soap, &amp;d, "number", NULL)</i> is called to output the floating point value in SOAP tagged
with the name <tt>&lt;number&#62;</tt>.  To initialize data, the <i>soap_default</i> function of a data type can be used.  For example,
<i>soap_default_float(&amp;soap, &amp;d)</i> initializes the float to 0.0.  The <i>soap_default</i> functions are useful to initialize complex
data types such as arrays, <i><b>struct</b></i>s, and <i><b>class</b></i> instances.  Note that the <i>soap_default</i> functions do not need
the gSOAP runtime environment as a first parameter.

<p>
The following table lists the type naming conventions used:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Type Name</b></font> </td></tr>
<tr><td><i><b>char</b>*</i> </td><td><i>string</i> </td></tr>
<tr><td><i>wchar_t*</i> </td><td><i>wstring</i> </td></tr>
<tr><td><i><b>char</b></i> </td><td><i>byte</i> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><i>bool</i> </td></tr>
<tr><td><i><b>double</b></i> </td><td><i>double</i> </td></tr>
<tr><td><i><b>int</b></i> </td><td><i>int</i> </td></tr>
<tr><td><i><b>float</b></i> </td><td><i>float</i> </td></tr>
<tr><td><i><b>long</b></i> </td><td><i>long</i> </td></tr>
<tr><td><i>LONG64</i> </td><td><i>LONG64</i> (Win32) </td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><i>LONG64</i> (Unix/Linux) </td></tr>
<tr><td><i><b>short</b></i> </td><td><i>short</i> </td></tr>
<tr><td><i>time_t</i> </td><td><i>time</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><i>unsignedByte</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><i>unsignedInt</i> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><i>unsignedLong</i> </td></tr>
<tr><td><i>ULONG64</i> </td><td><i>unsignedLONG64</i> (Win32)</td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><i>unsignedLONG64</i> (Unix/Linux) </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><i>unsignedShort</i> </td></tr>
<tr><td><i><u><span class="roman">T</span></u><span class="roman">[</span><u><span class="roman">N</span></u><span class="roman">]</span></i> </td><td><i>Array<u><span class="roman">N</span></u>Of<u><span class="roman">Type</span></u></i> where <u>Type</u> is the type name of <u>T</u> </td></tr>
<tr><td><i><u><span class="roman">T</span></u>*</i> </td><td><i>PointerTo<u><span class="roman">Type</span></u></i> where <u>Type</u> is the type name of <u>T</u> </td></tr>
<tr><td><i><b>struct</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr>
<tr><td><i><b>class</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr>
<tr><td><i><b>enum</b>&nbsp;Name</i> </td><td><i>Name</i> </td></tr></table>

</td></tr></table><br></span>
Consider for example the following declaration of <i>p</i> as a pointer to a <i><b>struct</b>&nbsp;ns__Person</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Person { <b>char</b>&nbsp;*name; } *p;
</td></tr></table><br></i>
To serialize <i>p</i>, its address is passed to the function <i>soap_serialize_PointerTons__Person</i> generated for this type by
the gSOAP compiler:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_serialize_PointerTons__Person(&amp;soap, &amp;p);
</td></tr></table><br></i>
The <b>address of</b> <i>p</i> is passed, so the serializer can determine whether <i>p</i> was already serialized and to discover
cycles in graph data structures.
To generate the output, the address of <i>p</i> is passed to the function <i>soap_put_PointerTons__Person</i> together with the
name of an XML element and an optional type string (to omit a type, use <i>NULL</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_put_PointerTons__Person(&amp;soap, &amp;p, "ns:element-name", "ns:type-name");
</td></tr></table><br></i>
This produces:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:element-name xmlns:SOAP-ENV="..." xmlns:SOAP-ENC="..." xmlns:ns="..." <br />
&nbsp;&nbsp;&nbsp;... xsi:type="ns:type-name"&#62; <br />
&lt;name xsi:type="xsd:string"&#62;...&lt;/name&#62; <br />
&lt;/ns:element-name&#62;
</td></tr></table><br></tt>
The serializer is initialized with the <i>soap_begin</i> function. All temporary data structures and data structures deserialized
on the heap are destroyed with the <i>soap_end()</i> function.  The <i>soap_free()</i> function can be used to remove the
temporary data only and keep the deserialized data on the heap.  Temporary data structures are only created if the encoded data
uses pointers. Each pointer in the encoded data has an internal hash table entry to determine all multi-reference parts and cyclic
parts of the complete data structure.

<p>
If more than one data structure is to be serialized and parts of those data structures are shared through pointers, then the
<i>soap_serialize</i> functions MUST to be called first before any of the <i>soap_put</i> functions. This is necessary to ensure
that multi-reference data shared by the data structures is encoded as multi-reference.

<p>
For example, to encode the contents of two variables <i>var1</i> and <i>var2</i> the serializers are called before the output routines:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">T1</span></u> var1; <br />
<u><span class="roman">T2</span></u> var2; <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); // initialize <br />
<font size="+1"><span class="roman">[</span></font>soap_omode(&amp;soap, flags);<font size="+1"><span class="roman">]</span></font> // set output-mode flags <br />
soap_begin(&amp;soap); // start new (de)serialization phase <br />
soap_set_omode(&amp;soap, SOAP_XML_GRAPH); <br />
soap_serialize_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1); <br />
soap_serialize_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2); <br />
... <br />
<font size="+1"><span class="roman">[</span></font>soap.socket = a_socket_file_descriptor;<font size="+1"><span class="roman">]</span></font> <br />
<font size="+1"><span class="roman">[</span></font>soap.sendfd = an_output_file_descriptor;<font size="+1"><span class="roman">]</span></font> <br />
soap_begin_send(&amp;soap); <br />
soap_put_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name1", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
soap_put_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2, "<font size="+1"><span class="roman">[</span></font>namespace-prefic:<font size="+1"><span class="roman">]</span></font>element-name2", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2"); <br />
... <br />
soap_end_send(&amp;soap); // flush <br />
soap_end(&amp;soap); // remove temporary data structures after phase <br />
soap_done(&amp;soap); // finalize last use of this environment <br />
...
</td></tr></table><br></i>
where <u>Type1</u> is the type name of <u>T1</u> and <u>Type2</u> is the type name of <u>T2</u> (see table
above).  The strings <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1</i> and <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2</i> describe the schema types
of the elements.  Use <i>NULL</i> to omit this type information.  The output stream is set by the assignment to
<i>soap.sendfd</i>.

<p>
For serializing class instances, method invocations MUST be used instead of function calls, for example
<i>var.soap_serialize(&amp;soap)</i> and <i>var.soap_put(&amp;soap, "elt", "type")</i>.  This ensures that the proper serializers are used for
serializing instances of derived classes.

<p>
In principle, encoding MAY take place without calling the <i>soap_serialize</i> functions. However, as the following example
demonstrates the resulting encoding is not SOAP 1.1 compliant.  However, the messages can still be used with gSOAP to save and
restore data.

<p>
Consider the following <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "tricky.h": <br />
<b>struct</b>&nbsp;Tricky<br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*p; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*q; <br />
};
</td></tr></table><br></i>
The following fragment initializes the pointer fields <i>p</i> and <i>q</i> to the value of field <i>n</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
<b>struct</b>&nbsp;Tricky X; <br />
X.n = 1; <br />
X.p = &amp;X.n; <br />
X.q = &amp;X.n; <br />
soap_init(&amp;soap); <br />
soap_begin(&amp;soap); <br />
soap_serialize_Tricky(&amp;soap, &amp;X); <br />
soap_put_Tricky(&amp;soap, &amp;X, <tt>"Tricky"</tt>, NULL); <br />
soap_end(&amp;soap); // Clean up temporary data used by the serializer
</td></tr></table><br></i>
The resulting output is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;Tricky xsi:type="Tricky"&#62; <br />
&lt;p href="#2"/&#62;
&lt;n xsi:type="int"&#62;1&lt;/n&#62;
&lt;q href="#2"/&#62;
&lt;r xsi:type="int"&#62;2&lt;/r&#62;
&lt;/Tricky&#62;
&lt;id id="2" xsi:type="int"&#62;1&lt;/id&#62;
</td></tr></table><br></tt>
which uses an independent element at the end to represent the multi-referenced integer.

<p>
To preserve the exact structure of the data, use the <i>SOAP_XML_GRAPH</i> flag to serialize the data in XML (see Section&nbsp;<a href="#sec:flags">7.10</a>)
to serialize multi-referenced data
embedded in the structure which assures the preservation of structure but is not SOAP 1.1 compliant.
For example, the resulting output is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;Tricky xsi:type="Tricky"&#62; <br />
&lt;p href="#2"/&#62;
&lt;n id="2" xsi:type="int"&#62;1&lt;/n&#62;
&lt;q href="#2"/&#62;
&lt;/Tricky&#62;
</td></tr></table><br></tt>
In this case, the XML is self-contained and multi-referenced data is accurately serialized.
The gSOAP generated deserializer for this data type will be able to accurately reconstruct the data from the XML (on the heap).

<p>
		      <h4><a name="tth_sEc6.4.2">
6.4.2</a>&nbsp;&nbsp;<font color="#0000FF">Deserializing a Data Type</font></h4><a name="sec:deserialize">
</a>

<p>
To deserialize a data type, its <i>soap_get</i> function is used. The outline of a program that deserializes two variables <i>var1</i> and <i>var2</i> is for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">T1</span></u> var1; <br />
<u><span class="roman">T2</span></u> var2; <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); // initialize at least once <br />
<font size="+1"><span class="roman">[</span></font>soap_imode(&amp;soap, flags);<font size="+1"><span class="roman">]</span></font> // set input-mode flags <br />
soap_begin(&amp;soap); // begin new decoding phase <br />
<font size="+1"><span class="roman">[</span></font>soap.recvfd = an_input_stream;<font size="+1"><span class="roman">]</span></font> <br />
soap_begin_recv(&amp;soap); // if HTTP header is present, parse it <br />
soap_get_<u><span class="roman">Type1</span></u>(&amp;soap, &amp;var1, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name1", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
soap_get_<u><span class="roman">Type2</span></u>(&amp;soap, &amp;var2, "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name2", "<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1"); <br />
... <br />
soap_end_recv(&amp;soap); // check consistancy of id/hrefs <br />
soap_destroy(&amp;soap); // remove deserialized class instances <br />
soap_end(&amp;soap); // remove temporary data, including the decoded data on the heap <br />
soap_done(&amp;soap); // finalize last use of the environment
</td></tr></table><br></i>
The strings <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name1</i> and <i><font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>type-name2</i> are the schema types of the
elements and should match the <tt>xsi:type</tt> attribute of the receiving message. To omit the match, use <i>NULL</i> as the type.
For class instances, method invocation can be used instead of a function call if the object is already instantiated, i.e.
<i>var.soap_get(&amp;soap, "...", "...")</i>.

<p>
The <i>soap_begin</i> call resets the deserializers. The <i>soap_destroy</i> and <i>soap_end</i> calls remove the temporary data structures <b>
and</b> the decoded data that was placed on the heap.

<p>
To remove temporary data while retaining the deserialized data on the heap, the function <i>soap_free</i> should be called instead
of <i>soap_destroy</i> and <i>soap_end</i>.

<p>
		      <h4><a name="tth_sEc6.4.3">
6.4.3</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4><a name="sec:example9">
</a>

<p>
As an example, consider the following data type declarations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "person.h": <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__Name; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;xsd__unsignedInt; <br />
<b>enum</b>&nbsp;ns__Gender {male, female}; <br />
<b>class</b>&nbsp;ns__Address <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__string street; <br />
&nbsp;&nbsp;&nbsp;xsd__unsignedInt number; <br />
&nbsp;&nbsp;&nbsp;xsd__string city; <br />
}; <br />
<b>class</b>&nbsp;ns__Person <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__Name name; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;ns__Gender gender; <br />
&nbsp;&nbsp;&nbsp;ns__Address address; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother; <br />
&nbsp;&nbsp;&nbsp;ns__Person *father; <br />
};
</td></tr></table><br></i>
The following program uses these data types to write to standard output a data structure that contains the data of a person named "John" living at Dowling st. 10 in Londen. He has a mother
"Mary" and a father "Stuart". After initialization, the class instance for "John" is serialized and encoded in XML to the
standard output stream using gzip compression (requires the Zlib library, compile sources with -DWITH_GZIP):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "person.cpp": <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person mother, father, john; <br />
&nbsp;&nbsp;&nbsp;mother.name = <tt>"Mary"</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.gender = female; <br />
&nbsp;&nbsp;&nbsp;mother.address.street = <tt>"Dowling st."</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.address.number = 10; <br />
&nbsp;&nbsp;&nbsp;mother.address.city = <tt>"London"</tt>; <br />
&nbsp;&nbsp;&nbsp;mother.mother = NULL; <br />
&nbsp;&nbsp;&nbsp;mother.father = NULL; <br />
&nbsp;&nbsp;&nbsp;father.name = <tt>"Stuart"</tt>; <br />
&nbsp;&nbsp;&nbsp;father.gender = male; <br />
&nbsp;&nbsp;&nbsp;father.address.street = <tt>"Main st."</tt>; <br />
&nbsp;&nbsp;&nbsp;father.address.number = 5; <br />
&nbsp;&nbsp;&nbsp;father.address.city = <tt>"London"</tt>; <br />
&nbsp;&nbsp;&nbsp;father.mother = NULL; <br />
&nbsp;&nbsp;&nbsp;father.father = NULL; <br />
&nbsp;&nbsp;&nbsp;john.name = <tt>"John"</tt>; <br />
&nbsp;&nbsp;&nbsp;john.gender = male; <br />
&nbsp;&nbsp;&nbsp;john.address = mother.address; <br />
&nbsp;&nbsp;&nbsp;john.mother = &amp;mother; <br />
&nbsp;&nbsp;&nbsp;john.father = &amp;father; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_omode(&amp;soap, SOAP_ENC_ZLIB | SOAP_XML_GRAPH); // see&nbsp;<a href="#sec:flags">7.10</a> <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin_send(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;john.soap_serialize(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;john.soap_put(&amp;soap, <tt>"johnnie"</tt>, NULL); <br />
&nbsp;&nbsp;&nbsp;soap_end_send(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_done(&amp;soap); <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "urn:person"}, // Namespace URI of the ``Person'' data type <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The header file is processed and the application compiled on Linux/Unix with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 person.h</i> <br />
<i>g++ -DWITH_GZIP -o person person.cpp soapC.cpp stdsoap2.cpp -lsocket -lxnet -lnsl -lz</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i>
are required. Compiling on Linux typically does not require the inclusion of those
libraries.)
See&nbsp;<a href="#sec:compression">13.19</a> for details on compression with gSOAP.

<p>
Running the <i>person</i> application results in the compressed XML output:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;johnnie xsi:type="ns:Person" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="urn:person" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;John&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;male&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street id="3" xsi:type="xsd:string"&#62;Dowling st.&lt;/street&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;10&lt;/number&#62; <br />
&lt;city id="4" xsi:type="xsd:string"&#62;London&lt;/city&#62; <br />
&lt;/address&#62; <br />
&lt;mother xsi:type="ns:Person"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;Mary&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;female&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street href="#3"/&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;5&lt;/number&#62; <br />
&lt;city href="#4"/&#62; <br />
&lt;/address&#62; <br />
&lt;/mother&#62; <br />
&lt;father xsi:type="ns:Person"&#62; <br />
&lt;name xsi:type="xsd:Name"&#62;Stuart&lt;/name&#62; <br />
&lt;gender xsi:type="ns:Gender"&#62;male&lt;/gender&#62; <br />
&lt;address xsi:type="ns:Address"&#62; <br />
&lt;street xsi:type="xsd:string"&#62;Main st.&lt;/street&#62; <br />
&lt;number xsi:type="unsignedInt"&#62;13&lt;/number&#62; <br />
&lt;city href="#4"/&#62; <br />
&lt;/address&#62; <br />
&lt;/father&#62; <br />
&lt;/johnnie&#62;
</td></tr></table><br></tt>
The following program fragment decodes this content from standard input and reconstructs the orignal data structure on the heap:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother, *father, *john = NULL; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_imode(&amp;soap, SOAP_ENC_ZLIB); // optional: gzip is detected automatically <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin_recv(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_get_ns__Person(&amp;soap, john, "johnnie", NULL)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... error ... <br />
&nbsp;&nbsp;&nbsp;mother = john<tt>-&gt;</tt>mother; <br />
&nbsp;&nbsp;&nbsp;father = john<tt>-&gt;</tt>father; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_end_recv(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_free(&amp;soap); // Clean up temporary data but keep deserialized data <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "urn:person"}, // Namespace URI of the ``Person'' data type <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
It is REQUIRED to either pass <i>NULL</i> to the <i>soap_get</i> routine, or a valid pointer to a data structure that can
hold the decoded content. The following example explicitly passes <i>NULL</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;john = soap_get_ns__Person(&amp;soap, NULL, "johnnie", NULL); <br />
</td></tr></table><br></i>
Note: the second <i>NULL</i> parameter indicates that the schema type attribute of the receiving message can be ignored.
The deserializer stores the SOAP contents on the heap, and returns the address. The allocated storage is released with the
<i>soap_end</i> call, which removes all temporary and deserialized data from the heap, or with the <i>soap_free</i> call, which removes all
temporary data only.

<p>
Alternatively, the XML content can be decoded within an existing allocated data structure.
The following program fragment decodes the SOAP content in a <i><b>struct</b>&nbsp;ns__Person</i> allocated on the stack:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ns__Person *mother, *father, john; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_imode(&amp;soap, SOAP_ENC_ZLIB); // optional <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin_recv(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_default_ns__Person(&amp;soap, &amp;john); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_get_ns__Person(&amp;soap, &amp;john, "johnnie", NULL)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... error ... <br />
&nbsp;&nbsp;&nbsp;... <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
&nbsp;&nbsp;&nbsp;...
</td></tr></table><br></i>
Note the use of <i>soap_default_ns__Person</i>. This routine is generated by the gSOAP stub and skeleton compiler and assigns default
values to the fields of <i>john</i>.

<p>
		      <h4><a name="tth_sEc6.4.4">
6.4.4</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify Default Values for Omitted Data</font></h4>

<p>
The gSOAP compiler generates <i>soap_default</i> functions for all data types.  The default values of the primitive types can be
easily changed by defining any of the following macros in the <i>stdsoap2.h</i> file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define SOAP_DEFAULT_bool <br />
#define SOAP_DEFAULT_byte <br />
#define SOAP_DEFAULT_double <br />
#define SOAP_DEFAULT_float <br />
#define SOAP_DEFAULT_int <br />
#define SOAP_DEFAULT_long <br />
#define SOAP_DEFAULT_LONG64 <br />
#define SOAP_DEFAULT_short <br />
#define SOAP_DEFAULT_string <br />
#define SOAP_DEFAULT_time <br />
#define SOAP_DEFAULT_unsignedByte <br />
#define SOAP_DEFAULT_unsignedInt <br />
#define SOAP_DEFAULT_unsignedLong <br />
#define SOAP_DEFAULT_unsignedLONG64 <br />
#define SOAP_DEFAULT_unsignedShort <br />
#define SOAP_DEFAULT_wstring
</td></tr></table><br></i>
Instead of adding these to <i>stdsoap2.h</i>, you can also compile with option <i>-DWITH_USERDEFS_H</i> and include your
definitions in file <i>userdefs.h</i>.
The absence of a data value in a receiving SOAP message will result in the assignment of a default value to a primitive type upon
deserialization.

<p>
Default values can also be assigned to individual <i><b>struct</b></i> and <i><b>class</b></i> fields of primitive type. For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;MyRecord <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name = "Unknown"; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;value = 9999; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;Status { active, passive } status = passive; <br />
}
</td></tr></table><br></i>
Default values are assigned to the fields on receiving a SOAP/XML message in which the data values are absent.

<p>
Because method requests and responses are essentially structs, default values can also be assigned to method parameters. The
default parameter values do not control the parameterization of C/C++ function calls, i.e. all actual parameters must be present
when calling a function. The default parameter values are used in case an inbound request or response message lacks the XML
elements with parameter values. For example, a Web service can use default values to fill-in absent parameters in a
SOAP/XML request:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__login(<b>char</b>&nbsp;*username = "anonymous", <b>char</b>&nbsp;*password = "guest", <b>bool</b>&nbsp;granted);
</td></tr></table><br></i>
When the request message lacks username and password parameters, e.g.:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://tempuri.org"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ns:login&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ns:login&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
then the service uses the default values.
In addition, the default values will show up in the SOAP/XML request and response message examples generated by the gSOAP
compiler.

<p>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;<font color="#0000FF">Using the gSOAP Stub and Skeleton Compiler</font></h2>

<p>
The gSOAP stub and skeleton compiler is invoked from the command line and optionally takes the name of a header file as an
argument or, when the file name is absent, parses the standard input:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 <font size="+1"><span class="roman">[</span></font>aheaderfile.h<font size="+1"><span class="roman">]</span></font></i>
</td></tr></table><br></span>
where <i>aheaderfile.h</i> is a standard C++ header file. The compiler acts as a preprocessor and produces C++ source files that
can be used to build SOAP client and Web service applications in C++. The files generated by the compiler are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File Name</b></font> </td><td width="501"><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soapH.h</i> </td><td width="501">Main header file to be included by all client and service sources </td></tr>
<tr><td><i>soapC.cpp</i> </td><td width="501">Serializers and deserializers for the specified data structures </td></tr>
<tr><td><i>soapClient.cpp</i> </td><td width="501">Client stub routines and proxies for all remote methods </td></tr>
<tr><td><i>soapServer.cpp</i> </td><td width="501">Service skeleton routines </td></tr>
<tr><td><i>soapStub.h</i> </td><td width="501">A modified header file produced from the compiler input header file </td></tr>
<tr><td><i>.xsd</i> </td><td width="501">An <i>ns.xsd</i> file is generated with an XML schema for each namespace prefix <i>ns</i> used by a data structure in the header
file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">6.2.5</a> </td></tr>
<tr><td><i>.wsdl</i> </td><td width="501">A <i>ns.wsdl</i> file is generated with an WSDL description for each namespace prefix <i>ns</i> used by a remote method in the
header file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">6.2.5</a> </td></tr>
<tr><td><i>.xml</i> </td><td width="501">Several SOAP/XML request and response files are generated. These are example message files are valid provided
that sufficient schema namespace directives are added to the header file or the generated .nsmap namespace table for the
clinet/service is not modified by hand </td></tr>
<tr><td><i>.nsmap</i> </td><td width="501">A <i>ns.nsmap</i> file is generated for each namespace prefix <i>ns</i> used by a remote method in the
header file input to the compiler, see Section&nbsp;<a href="#sec:wsdl">6.2.5</a>.  The file contains a namespace mapping table that can be used in the client/service sources </td></tr></table>

</td></tr></table><br></span>
Both client and service applications are developed from a header file that specifies the remote methods. If client and
service applications are developed with the same header file, the applications are guaranteed to be compatible because the stub and skeleton routines use
the same serializers and deserializers ot encode and decode the parameters. Note that when client and service applications are developed together, an application developer does
not need to know the details of the internal SOAP encoding used by the client and service.

<p>
The following files are part of the gSOAP package and are required to build client and service applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File Name</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>stdsoap2.h</i> </td><td>Header file of <i>stdsoap2.cpp</i> runtime library </td></tr>
<tr><td><i>stdsoap2.c</i> </td><td>Runtime C library with XML parser and run-time support routines </td></tr>
<tr><td><i>stdsoap2.cpp</i> </td><td>Runtime C++ library identical to <i>stdsoap2.c</i> </td></tr></table>

</td></tr></table><br></span>

<p>
	     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;<font color="#0000FF">Compiler Options</font></h3><a name="sec:options">
</a>

<p>
The compiler supports the following options:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Option</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>-1</i>	</td><td>Use SOAP 1.1 namespaces and encodings (default) </td></tr>
<tr><td><i>-2</i>	</td><td>Use SOAP 1.2 namespaces and encodings </td></tr>
<tr><td><i>-h</i>	</td><td>Print a brief usage message </td></tr>
<tr><td><i>-c</i>	</td><td>Save files using extension <i>.c</i> instead of <i>.cpp</i> </td></tr>
<tr><td><i>-i</i>	</td><td>Interpret <i>#include</i> and <i>#define</i> directives </td></tr>
<tr><td><i>-m</i>	</td><td>Generate code that requires array/binary classes to explicitly free malloced array </td></tr>
<tr><td></td><td>(to be depricated since <i>soap_unlink</i> should be used to keep specific data) </td></tr>
<tr><td><i>-d  &lt; path &gt; </i>	</td><td>Save sources in directory specified by <i> &lt; path &gt; </i> </td></tr>
<tr><td><i>-p  &lt; name &gt; </i>	</td><td>Save sources with file name prefix <i> &lt; name &gt; </i> instead of ``<i>soap</i>'' </td></tr></table>

</td></tr></table><br></span>
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 -cd '../projects' -pmy file.h</i>
</td></tr></table><br></span>
Saves the sources:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>../projects/myH.h</i> <br />
<i>../projects/myC.c</i> <br />
<i>../projects/myClient.c</i> <br />
<i>../projects/myServer.c</i> <br />
<i>../projects/myStub.h</i> <br />
</td></tr></table><br></span>
MS Windows users can use the usual ``<i>/</i>'' for options, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 /cd '..\projects' /pmy file.h</i>
</td></tr></table><br></span>

<p>
	     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;<font color="#0000FF">SOAP 1.1 Versus SOAP 1.2</font></h3>

<p>
gSOAP supports SOAP 1.1 by default. SOAP 1.2 support is automatically turned on when the appropriate SOAP 1.2 namespace is used
in the namespace mapping table:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://www.w3.org/2002/06/soap-envelope"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://www.w3.org/2002/06/soap-encoding"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema"},
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
gSOAP Web services and clients can automatically switch from SOAP 1.1 to SOAP 1.2 by providing the SOAP 1.2 namespace
as a pattern in the third column of a namespace table:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/2002/06/soap-encoding"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/2002/06/soap-envelope"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema"},
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
This way, gSOAP Web services can respond to either SOAP 1.1 or SOAP 1.2 requests.

<p>
The gSOAP <i>soapcpp2</i> compiler generates a <i>.nsmap</i> file with <i>SOAP-ENV</i> and <i>SOAP-ENC</i> namespace patterns similar to the above.
Since clients issue a send first, they will always use SOAP 1.1 for requests when the namespace table is similar as shown above.
Clients can accept SOAP 1.2 responses by inspecting the response message.
To restrict gSOAP services and clients to SOAP 1.2 and to generate SOAP 1.2 service WSDLs, use <i>soapcpp2</i>
compiler option <i>-2</i> to generate SOAP 1.2 conformant <i>.nsmap</i> and <i>.wsdl</i> files.

<p>
<font color="#FF0000"><b>Caution</b></font>: SOAP 1.2 does not support partially transmitted arrays. So the <i>__offset</i> field of a dynamic array is meaningless.

<p>
<font color="#FF0000"><b>Caution</b></font>: SOAP 1.2 requires the use of <i>SOAP_ENV__Code</i>, <i>SOAP_ENV__Reason</i>, and <i>SOAP_ENV__Detail</i> fields
in a <i>SOAP_ENV__Fault</i> fault struct, while SOAP 1.1 uses <i>faultcode</i>, <i>faultstring</i>, and <i>detail</i> fields.
Use <i>soap_receiver_fault(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*faultstring, <b>const</b>&nbsp;<b>char</b>&nbsp;*detail)</i> to set a SOAP 1.1/1.2
fault at the server-side.
Use <i>soap_sender_fault(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*faultstring, <b>const</b>&nbsp;<b>char</b>&nbsp;*detail)</i> to set a SOAP 1.1/1.2
unrecoverable Bad Request fault at the server-side.

<p>
	     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;<font color="#0000FF">The soapdefs.h Header File</font></h3>

<p>
The <i>soapdefs.h</i> header file is included in <i>stdsoap2.h</i> when compiling with option <i>-DWITH_SOAPDEFS_H</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_SOAPDEFS_H -c stdsoap2.cpp</i>
</td></tr></table><br></span>
The <i>soapdefs.h</i> file allows users to include definitions and add includes without requiring changes to <i>stdsoap2.h</i>.
For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of soapdefs.h <br />
#include  &lt; ostream &gt;  <br />
#define SOAP_BUFLEN 20480 // use large send/recv buffer <br />
</td></tr></table><br></i>
The following header file can now refer to <i>ostream</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>extern</b>&nbsp;<b>class</b>&nbsp;ostream; // ostream can't be (de)serialized, but need to be declared to make it visible to gSOAP <br />
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(ostream &amp;s) <b>const</b>; // need ostream here <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
See also Section&nbsp;<a href="#sec:transient">13.4</a>.

<p>
	     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;<font color="#0000FF">The gSOAP #import Directive</font></h3><a name="sec:import">
</a>

<p>
The <i>#import</i> directive can be used to include gSOAP header files into other gSOAP header files for processing with
<i>soapcpp2</i>.
The C <i>#include</i> directive cannot be used to include gSOAP header files.
The <i>#include</i> directive is reserved to control the post-gSOAP compilation process, see&nbsp;<a href="#sec:pragmas">7.5</a>.

<p>
An example of the <i>#import</i> directive:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#import "mydefs.gsoap" <br />
<b>int</b>&nbsp;ns__mymethod(xsd__string in, xsd__int *out);
</td></tr></table><br></i>
where <i>"mydefs.gsoap"</i> is a gSOAP header file that defines <i>xsd__string</i> and <i>xsd_int</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int;
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;<font color="#0000FF">How to Use #include and #define Directives</font></h3><a name="sec:pragmas">
</a>

<p>
The <i>#include</i> and <i>#define</i> directives are normally ignored by the gSOAP compiler.
The use of the directives is enabled with the <i>-i</i> option of the gSOAP compiler, see Section&nbsp;<a href="#sec:options">7.1</a>.
However, the gSOAP compiler will not actually parse the contents of the header files provided by the <i>#include</i> directives in a header file.
Instead, the <i>#include</i> and <i>#define</i> directives will be added to the generated <i>soapH.h</i> header file <b>before</b>
any other header file is included. Therefore, <i>#include</i> and <i>#define</i> directives can be used to control the C/C++
compilation process of the sources of an application.

<p>
The following example header file refers to <i>ostream</i> by including <i> &lt; ostream &gt; </i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include  &lt; ostream &gt;  <br />
#define WITH_COOKIES // use HTTP cookie support (you must compile stdsoap2.cpp with -DWITH_COOKIES) <br />
#define WITH_OPENSSL // use HTTP OpenSSL support (you must compile stdsoap2.cpp with -DWITH_OPENSSL) <br />
#define SOAP_DEFAULT_float FLT_NAN // use NaN instead of 0.0 <br />
<b>extern</b>&nbsp;<b>class</b>&nbsp;ostream; // ostream can't be (de)serialized, but need to be declared to make it visible to gSOAP <br />
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(ostream &amp;s) <b>const</b>; // need ostream here <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
This example also uses <i>#define</i> directives for various settings.

<p>
<font color="#FF0000"><b>Caution</b></font>: Note that the use of <i>#define</i> in the header file does not automatically result in compiling
<i>stdsoap2.cpp</i> with these directives. You MUST use the <i>-DWITH_COOKIES</i> and <i>-DWITH_OPENSSL</i> options when
compiling <i>stdsoap2.cpp</i> before linking the object file with your codes. As an alternative, you can use <i>#define
WITH_SOAPDEFS_H</i> and put the <i>#define</i> directives in the <i>soapdefs.h</i> file.

<p>
	     <h3><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;<font color="#0000FF">Compiling a gSOAP Client</font></h3>

<p>
After invoking the gSOAP stub and skeleton compiler on a header file description of a service, the client application can be compiled on a Linux machine as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp</i>
</td></tr></table><br></span>
Or on a Unix machine:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i> or dynamic <i>*.so</i> versions of those libraries are required.)

<p>
The <i>myclient.cpp</i> file must include <i>soapH.h</i> and must define a global namespace mapping table. A typical client program layout with namespace mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "myclient.cpp" <br />
#include "soapH.h"; <br />
... <br />
// A remote method invocation: <br />
&nbsp;&nbsp;&nbsp;soap_call_some_remote_method(...); <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-remote-method"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
}; <br />
...
</td></tr></table><br></i>
A mapping table is generated by the gSOAP compiler that can be used in the source, see Section&nbsp;<a href="#sec:wsdl">6.2.5</a>.

<p>
	     <h3><a name="tth_sEc7.7">
7.7</a>&nbsp;&nbsp;<font color="#0000FF">Compiling a gSOAP Web Service</font></h3>

<p>
After invoking the gSOAP stub and skeleton compiler on a header file description of the service, the server application can be compiled on a Linux machine as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp</i>
</td></tr></table><br></span>
Or on a Unix machine:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span>
(Depending on your system configuration, the libraries <i>libsocket.a</i>,
<i>libxnet.a</i>, <i>libnsl.a</i> or dynamic <i>*.so</i> versions of those libraries are required.)

<p>
The <i>myserver.cpp</i> file must include <i>soapH.h</i> and must define a global namespace mapping table. A typical service program layout with namespace mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "myserver.cpp" <br />
#include "soapH.h"; <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
... <br />
// Implementations of the remote methods as C++ functions <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-remote-method"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
}; <br />
...
</td></tr></table><br></i>
When the gSOAP service is compiled and installed as a CGI application, the <i>soap_serve</i> function acts as a service dispatcher. It listens to standard input and
invokes the method via a skeleton routine to serve a SOAP client request. After the request is served, the response is encoded in
SOAP and send to standard output. The method must be implemented in the server application and the type signature of the method
must be identical to the remote method specified in the header file. That is, the function prototype in the header file must be a
valid prototype of the method implemented as a C/C++ function.

<p>
	     <h3><a name="tth_sEc7.8">
7.8</a>&nbsp;&nbsp;<font color="#0000FF">Using gSOAP for Creating Web Services and Clients in Pure C</font></h3>

<p>
The gSOAP compiler can be used to create pure C Web services and clients. The gSOAP stub and skeleton compiler
<i>soapcpp2</i> generates <i>.cpp</i> files by default. The compiler generates <i>.c</i> files with the <i>-c</i> option.
However, these files only use C syntax and data types <b>if</b> the header
file input to <i>soapcpp2</i> uses C syntax and data types. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 -c quote.h</i> <br />
<i>gcc -o quote quote.c stdsoap2.c soapC.c soapClient.c</i>
</td></tr></table><br></span>
Warnings will be issued by the compiler when C++ class declarations occur in the header file.

<p>
	     <h3><a name="tth_sEc7.9">
7.9</a>&nbsp;&nbsp;<font color="#0000FF">Limitations of gSOAP</font></h3><a name="sec:limitations">
</a>

<p>
gSOAP is fully SOAP 1.1 (and mostly SOAP 1.2) compliant and supports all SOAP RPC and most SOAP LIT features.

<p>
From the perspective of the C/C++ language, a few C++ language features are not supported by gSOAP and these features cannot be used in the specification of SOAP remote methods.

<p>
The following C++ language constructs cannot be used by the header file input to the gSOAP stub and skeleton compiler:

<dl compact="compact">
 <dt><b>Templates</b></dt>
	<dd> The gSOAP stub and skeleton compiler is a preprocessor and cannot predict the template intantations used by the main program, nor can it generate templated code.</dd>
 <dt><b>Multiple inheritance</b></dt>
	<dd> Single class inheritance is supported. Multiple inheritance cannot be supported due to limitations of the SOAP protocol.</dd>
 <dt><b>Abstract methods</b></dt>
	<dd> A class must be instantiatable to allow decoding of instances of the class.</dd>
 <dt><b>Directives</b></dt>
	<dd> Directives and pragmas such as <i>#include</i> and <i>#define</i> are interpreted by the gSOAP compiler.
However, the interpretation is different compared to the usual handling of directives, see Section&nbsp;<a href="#sec:pragmas">7.5</a>. If necessary, a traditional C++
preprocessor can be used for the interpretation of directives. For example, Unix and Linux users can use ``<tt>cpp -B</tt>''
to expand the header file, e.g. <tt>cpp -B myfile.h | soapcpp2</tt>.
Use the gSOAP <i>#import</i> directive to import gSOAP header files, see&nbsp;<a href="#sec:import">7.4</a>.</dd>
 <dt><b>C and C++ programming statements</b></dt>
	<dd> All class methods of a class should be declared within the class declaration in the header file, but the methods should not be implemented in code. All class method implementations must be defined within another C++ source file and linked to the application.</dd>
</dl>
In addition, the following data types cannot be used in the header file
(they can, however be used as a class method return type and as class method parameter types of a class declared in the header file):

<dl compact="compact">
 <dt><b><i><b>union</b></i> types</b></dt>
	<dd> Because the run-time value of a <i><b>union</b></i> data type cannot be determined by the compiler, the data type cannot be encoded. An alternative is to use a <i><b>struct</b></i> with a pointer type for each field. Because <i>NULL</i> pointers are not encoded, the resulting encoding will appear as a union type if only one pointer field is valid (i.e.&nbsp;non-<i>NULL</i>) at the time that the data type is encoded.</dd>
 <dt><b><i><b>void</b></i> and <i><b>void</b>*</i> types</b></dt>
	<dd> The <i><b>void</b></i> data type cannot be encoded. The <i><b>void</b>*</i> data type is typically used to point to some object or to some array of some type of objects at run-time. The compiler cannot determine the type of data pointed to and the size of the array pointed to.</dd>
 <dt><b>Pointers to sequences of elements in memory</b></dt>
	<dd> Any pointer, except for C strings which are pointers to a sequence of
characters, are treated by the compiler as if the pointer points to <b>only one element in memory</b> at run-time. Consequently,
the encoding and decoding routines will ignore any subsequent elements that follow the first in memory. For the same reason,
arrays of undetermined length, e.g.&nbsp;<i><b>float</b>&nbsp;a[]</i> cannot be used. gSOAP supports dynamic arrays using a special type convention,
see Section&nbsp;<a href="#sec:dynarray">9.8</a>.</dd>
 <dt><b>Uninitialized pointers</b></dt>
	<dd> Obviously, all pointers that are part of a data structure must be valid or <i>NULL</i> to enable
serialization of the data structure at run time.</dd>
</dl>
There are a number of programming solutions that can be adopted to circumvent these limitations. Instead of using <i><b>void</b>*</i>, a program
can in some cases be modified to use a pointer to a known type. If the pointer is intended to point to different types of objects, a generic
base class can be declared and the pointer is declared to point to the base class. All the other types are declared to be derived
classes of this base class. For pointers that point to a sequence of elements in memory dynamic arrays should be used instead,
see <a href="#sec:dynarray">9.8</a>.

<p>
	     <h3><a name="tth_sEc7.10">
7.10</a>&nbsp;&nbsp;<font color="#0000FF">Runtime Flags</font></h3><a name="sec:flags">
</a>

<p>
gSOAP provides flags to control the input and output mode settings at runtime.
These flags are divided into four categories: transport (IO), content encoding
(ENC), XML marshalling (XML), and C/C++ data mapping (C).

<p>
Although gSOAP is fully SOAP 1.1 compliant, some SOAP implementations may have
trouble accepting multi-reference data and/or require explicit nil data so
these flags can be used to put gSOAP in ``safe mode''.  In addition, the
embedding (or inlining) of multi-reference data is adopted in the SOAP 1.2
specification, which gSOAP automatically supports when handling with SOAP 1.2
messages.  The flags are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Flag</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>SOAP_IO_FLUSH</i> </td><td>Disable buffering and flush output (default for all file-based output) </td></tr>
<tr><td><i>SOAP_IO_BUFFER</i> </td><td>Enable buffering (default for all socket-oriented connections) </td></tr>
<tr><td><i>SOAP_IO_STORE</i> </td><td>Store entire message to calculate HTTP content length </td></tr>
<tr><td><i>SOAP_IO_CHUNK</i> </td><td>Use HTTP chunking </td></tr>
<tr><td><i>SOAP_IO_LENGTH</i> </td><td>Require apriori calculation of content length (this is automatic) </td></tr>
<tr><td><i>SOAP_IO_KEEPALIVE</i> </td><td>Attempt to keep socket connections alive (open) </td></tr>
<tr><td><i>SOAP_ENC_XML</i> </td><td>Use plain XML encoding without HTTP headers </td></tr>
<tr><td><i>SOAP_ENC_DIME</i> </td><td>Use DIME encoding (automatic when DIME attachments are used) </td></tr>
<tr><td><i>SOAP_ENC_SSL</i> </td><td>Encrypt encoding with SSL (automatic with "https:" endpoints) </td></tr>
<tr><td><i>SOAP_ENC_ZLIB</i> </td><td>Compress encoding with Zlib (deflate or gzip format) </td></tr>
<tr><td><i>SOAP_XML_STRICT</i> </td><td>XML strict validation (fault on unknown XML elements rather than omitting them) </td></tr>
<tr><td><i>SOAP_XML_TREE</i> </td><td>Serialize data as XML trees (no multi-ref, duplicate data when necessary) </td></tr>
<tr><td><i>SOAP_XML_GRAPH</i> </td><td>Serialize data as an XML graph with inline multi-ref (SOAP 1.2 default) </td></tr>
<tr><td><i>SOAP_XML_NIL</i> </td><td>Serialize NULL data as XML nil elements (omit by default) </td></tr>
<tr><td><i>SOAP_C_NOIOB</i> </td><td>Do not fault with <i>SOAP_IOB</i> when an array is received that does not fit in a fixed-size array </td></tr>
<tr><td><i>SOAP_C_UTFSTRING</i> </td><td>(De)serialize 8-bit strings ``as is'' (strings MUST have UTF-8 encoded content) </td></tr></table>

</td></tr></table><br></span>
The flags can be selectively turned on/off at any time, for example when
multiple Web services are accessed by a client that require special treatment.

<p>
All flags are orthogonal, except
<i>SOAP_IO_FLUSH</i>,
<i>SOAP_IO_BUFFER</i>,
<i>SOAP_IO_STORE</i>, and
<i>SOAP_IO_CHUNK</i>
which are enumerations and only one of these I/O flags can be used.  Also the
XML serialization flags
<i>SOAP_XML_TREE</i> and
<i>SOAP_XML_GRAPH</i> should not be mixed.

<p>
The flags control the inbound and outbound message transport, encoding, and
(de)serialization.  The following functions are used to set and reset the flags
for input and output modes:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_init2(<b>struct</b>&nbsp;soap *soap, int imode, int omode)</i> </td><td>Initialize the runtime and set flags </td></tr>
<tr><td><i>soap_imode(<b>struct</b>&nbsp;soap *soap, int imode)</i> </td><td>Set all input mode flags </td></tr>
<tr><td><i>soap_omode(<b>struct</b>&nbsp;soap *soap, int omode)</i> </td><td>Set all output mode flags </td></tr>
<tr><td><i>soap_set_imode(<b>struct</b>&nbsp;soap *soap, int imode)</i> </td><td>Enable input mode flags </td></tr>
<tr><td><i>soap_set_omode(<b>struct</b>&nbsp;soap *soap, int omode)</i> </td><td>Enable output mode flags </td></tr>
<tr><td><i>soap_clr_imode(<b>struct</b>&nbsp;soap *soap, int omode)</i> </td><td>Disable input mode flags </td></tr>
<tr><td><i>soap_clr_omode(<b>struct</b>&nbsp;soap *soap, int omode)</i> </td><td>Disable output mode flags </td></tr></table>

</td></tr></table><br></span>
The default setting is <i>SOAP_IO_DEFAULT</i> for both input and output modes.

<p>
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, SOAP_IO_KEEPALIVE | SOAP_ENC_ZLIB | SOAP_XML_TREE); <br />
<b>if</b>&nbsp;(soap_call_ns__myMethod(&amp;soap, ...)) <br />
...
</td></tr></table><br></i>
sends a compressed client request with keep-alive enabled and all data serialized as XML trees.

<p>
In many cases, setting the input mode will have no effect, especially with HTTP
transport because gSOAP will determine the optimal input buffering and the
encoding used for an inbound message. The flags that do have an effect on
handling inbound messages are <i>SOAP_IO_KEEPALIVE</i>, <i>SOAP_ENC_SSL</i>
(but automatic when "https:" endpoints are used or <i>soap_ssl_accept</i>),
<i>SOAP_XML_NIL</i> will fault on receiving nil elements for non-nillable
data, <i>SOAP_C_NOIOB</i>, and <i>SOAP_C_UTFSTRING</i>.

<p>
<font color="#FF0000"><b>Caution</b></font>: The <i>SOAP_XML_TREE</i> serialization flag can be used to
improve interoperability with SOAP implementations that are not fully SOAP 1.1
compliant.  However, a tree serialization will duplicate data when necessary
and will crash the serializer for cyclic data structures.

<p>
	     <h3><a name="tth_sEc7.11">
7.11</a>&nbsp;&nbsp;<font color="#0000FF">Memory Management</font></h3><a name="sec:memory">
</a>

<p>
Understanding gSOAP's run-time memory management is important to optimize
client and service applications by eliminating memory leaks and/or dangling
references.

<p>
There are two forms of dynamic (heap) allocations made by gSOAP's runtime for
serialization and deserialization of data.  Temporary data is created by the
runtime such as hash tables to keep pointer reference information for
serialization and hash tables to keep XML id/href information for
multi-reference object deserialization.  Deserialized data is created upon
receiving SOAP messages.  This data is stored on the heap and requires several
calls to the <i>malloc</i> library function to allocate space for the data and
<i><b>new</b></i> to create class instances.  All such allocations are tracked by
gSOAP's runtime by linked lists for later deallocation.  The linked list for
<i>malloc</i> allocations uses some extra space in each <i>malloc</i>ed block to
form a chain of pointers through the <i>malloc</i>ed blocks.  A separate
<i>malloc</i>ed linked list is used to keep track of class instance allocations.

<p>
gSOAP does not enforce a deallocation policy and the user can adopt a
deallocation policy that works best for a particular application.  As a
consequence, deserialized data is never deallocated by the gSOAP runtime unless
the user explicitly forces deallocation by calling functions to deallocate data
collectively or individually.

<p>
The deallocation functions are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function Call</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>soap_end(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove temporary data and deserialized data except </td></tr>
<tr><td></td><td>class instances </td></tr>
<tr><td><i>soap_free(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove temporary data only </td></tr>
<tr><td><i>soap_destroy(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Remove all dynamically allocated class instances. </td></tr>
<tr><td></td><td>Need to be called before <i>soap_end()</i> </td></tr>
<tr><td><i>soap_dealloc(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*p)</i> </td><td>Remove malloced data at <i>p</i>. When <i>p==NULL</i>: remove all </td></tr>
<tr><td></td><td>dynamically allocated (deserialized) data except class instances </td></tr>
<tr><td><i>soap_delete(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*p)</i> </td><td>Remove class instance at <i>p</i>. When <i>p==NULL</i>: remove all </td></tr>
<tr><td></td><td>dynamically allocated (deserialized) class instances </td></tr>
<tr><td></td><td>(this is identical to calling soap_destroy(<b>struct</b>&nbsp;soap *soap)) </td></tr>
<tr><td><i>soap_unlink(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*p)</i> </td><td>Unlink data/object at <i>p</i> from gSOAP's deallocation chain </td></tr>
<tr><td></td><td>so gSOAP won't deallocate it </td></tr>
<tr><td><i>soap_done(<b>struct</b>&nbsp;soap *soap)</i> </td><td>Reset: close master/slave sockets and remove callbacks </td></tr>
<tr><td></td><td>(see Section&nbsp;<a href="#sec:callback">13.7</a> </td></tr></table>

</td></tr></table><br></span>
Temporary data (i.e.&nbsp;the hash tables) are automatically removed with calls to
the <i>soap_free</i> function which is made within <i>soap_end</i> and
<i>soap_done</i> or when the next call to a stub or skeleton routine is made to
send a message or receive a message.  Deallocation of non-class based data is
straightforward: <i>soap_end</i> removes all dynamically allocated deserialized
data (data allocated with <i>soap_malloc</i>.  That is, when the client/service
application does not use any class instances that are (de)marshalled, but uses
structs, arrays, etc., then calling the <i>soap_end</i> function is safe to
remove all deserialized data.  The function can be called after processing the
deserialized data of a remote method call or after a number of remote method
calls have been made.  The function is also typically called after
<i>soap_serve</i>, when the service finished sending the response to a client
and the deserialized client request data can be removed.

<p>
Individual data objects can be unlinked from the deallocation chain if
necessary, to prevent deallocation by the collective <i>soap_end</i> or
<i>soap_destroy</i> functions.

<p>
	      <h4><a name="tth_sEc7.11.1">
7.11.1</a>&nbsp;&nbsp;<font color="#0000FF">Memory Management Policies</font></h4>

<p>
There are three situations to consider for memory deallocation policies for class instances:

<ol type="1"><p>
<li> the program code deletes the class
instances and the class destructors in turn SHOULD delete and free any dynamically allocated data (deep deallocation) without
calling the <i>soap_end</i> and <i>soap_destroy</i> functions,</li>
<p>
<li> or the class
destructors SHOULD NOT deallocate any data and the <i>soap_end</i> and <i>soap_destroy</i> functions can be called to remove
the data.</li>
<p>
<li> or the class
destructors SHOULD mark their own deallocation and mark the deallocation of any other data deallocated by it's destructors
by calling the <i>soap_unlink</i> function. This allows
<i>soap_destroy</i> and <i>soap_end</i> to remove the remaining instances and data without causing duplicate deallocations.</li>
</ol>
With the <i>-m</i> option of <i>soapcpp2</i> enabled (to be depricated), there is one exception which requires explicit deallocation of <i>malloc</i>ed data in
the destructors of classes for array binary types:

<ul><p>
<li> A dynamic array class with non-class elements SHOULD delete the contents of the array it points to as part of its destructor's operations (this includes classes for <i>hexBinary</i> and
<i>base64Binary</i> schema types.</li>
</ul>
It is advised to use pointers to class instances that are used within other structs and classes to avoid the creation of temporary
class instances. The problem with temporary class instances is that the destructor of the temporary may affect data used by
other instances through the sharing of data parts accessed with pointers. Temporaries and even whole copies of class instances
can be created when deserializing SOAP multi-referenced objects.
A dynamic array of class instances is similar: temporaries may be created to fill the array upon deserialization. To avoid
problems, use dynamic arrays of pointers to class instances. This also enables the exchange of polymorphic arrays when the
elements are instances of classes in an inheritance hierarchy.
In addition, allocate data and class instances with <i>soap_malloc</i> and <i>soap_new_X</i> functions (more details below).

<p>
To summarize, it is advised to pass class data types by pointer to a remote method. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;X { ... }; <br />
ns__remoteMethod(X *in, ...);
</td></tr></table><br></i>
Response elements that are class data types can be passed by reference, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ns__remoteMethodResponse { ... }; <br />
ns__remoteMethod(X *in, ns__remoteMethodResponse &amp;out);
</td></tr></table><br></i>
But dynamic arrays declared as class data types should use a pointer to a valid object that will be overwritten when the
function is called, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ArrayOfint { xsd__int *__ptr; <b>int</b>&nbsp;__size; }; <br />
ns__remoteMethod(X *in, ArrayOfint *out);
</td></tr></table><br></i>
Or a reference to a valid or <i>NULL</i> pointer, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;X { ... }; <br />
<b>class</b>&nbsp;ArrayOfint { xsd__int *__ptr; <b>int</b>&nbsp;__size; }; <br />
ns__remoteMethod(X *in, ArrayOfint *&amp;out);
</td></tr></table><br></i>
The gSOAP memory allocation functions can be used in client and/or service code to allocate temporary data that will be
automatically deallocated.
These functions are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Function Call</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i><b>void</b>&nbsp;*soap_malloc(<b>struct</b>&nbsp;soap *soap, size_t n)</i> </td><td>return pointer to <i>n</i> bytes </td></tr>
<tr><td><i><u><span class="roman">Class</span></u> *soap_new_<u><span class="roman">Class</span></u>(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;n)</i> </td><td>instantiate <i>n</i> <u><span class="roman">Class</span></u> objects </td></tr></table>

</td></tr></table><br></span>
The <i>soap_new_X</i> functions are generated by the gSOAP compiler for every class <i>X</i> in the header file.
Parameter <i>n</i> MUST be <i>-1</i> to instantiate a single object or  <font face="symbol"></font
> 0 to instantiate an array of <i>n</i> objects.

<p>
Space allocated with <i>soap_malloc</i> will be released with the <i>soap_end</i> and <i>soap_dealloc</i> functions.
Objects instantiated with <i>soap_new_X(<b>struct</b>&nbsp;soap*)</i> are removed altogether with <i>soap_destroy(<b>struct</b>soap*)</i>.
Individual objects instantiated with <i>soap_new_X</i> are removed with <i>soap_delete_X(<b>struct</b>&nbsp;soap*, X*)</i>.
For example, the following service uses temporary data in the remote method implementation:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
An example remote method that allocates a temporary string is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__itoa(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;i, <b>char</b>&nbsp;**a) <br />
{ <br />
&nbsp;&nbsp;&nbsp;*a = (char*)soap_malloc(soap, 11); <br />
&nbsp;&nbsp;&nbsp;sprintf(*a, "%d", i); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>
This temporary allocation can also be used to allocate strings for the SOAP Fault data structure. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__mymethod(...) <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(exception) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*msg = (<b>char</b>*)soap_malloc(soap, 1024); // allocate temporary space for detailed message <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(msg, "...", ...); // produce the detailed message <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;soap_receiver_fault(soap, &#196;n exception occurred", msg); // return the server-side fault <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>
Use <i>soap_receiver_fault(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*faultstring, <b>const</b>&nbsp;<b>char</b>&nbsp;*detail)</i> to set a SOAP 1.1/1.2
fault at the server-side.
Use <i>soap_sender_fault(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*faultstring, <b>const</b>&nbsp;<b>char</b>&nbsp;*detail)</i> to set a SOAP 1.1/1.2
unrecoverable Bad Request fault at the server-side.

<p>
		      <h4><a name="tth_sEc7.11.2">
7.11.2</a>&nbsp;&nbsp;<font color="#0000FF">Intra-Class Memory Management</font></h4><a name="sec:classmemory">
</a>

<p>
When a class declaration has a <i><b>struct</b>&nbsp;soap *</i> field, this field will be set to point to the current gSOAP run-time environment by
gSOAP's deserializers and by the <i>soap_new_Class</i> functions.
This simplifies memory management for class instances.
The <i><b>struct</b>&nbsp;soap*</i> pointer is implicitly set by the gSOAP deserializer for
the class or explicitly by calling the <i>soap_new_X</i> function for class <i>X</i>.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;Sample <br />
{ <b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; // reference to gSOAP's run-time <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;Sample(); <br />
&nbsp;&nbsp;&nbsp;~Sample(); <br />
};
</td></tr></table><br></i>
The constructor and destructor for class <i>Sample</i> are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
Sample::Sample() <br />
{ this<tt>-&gt;</tt>soap = NULL; <br />
} <br />
Sample::~Sample() <br />
{ soap_unlink(this<tt>-&gt;</tt>soap, this); <br />
}
</td></tr></table><br></i>
The <i>soap_unlink()</i> call removes the object from gSOAP's deallocation chain.
In that way, <i>soap_destroy</i> can be safely called to remove all class instances.
The following code illustrates the explicit creation of a <i>Sample</i> object and cleanup:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap *soap = soap_new(); // new gSOAP runtime <br />
Sample *obj = soap_new_Sample(soap, -1); // new Sample object with obj<tt>-&gt;</tt>soap set to runtime <br />
... <br />
<b>delete</b>&nbsp;obj; // also calls soap_unlink to remove obj from the deallocation chain <br />
soap_destroy(soap); // deallocate all (other) class instances <br />
soap_end(soap); // clean up
</td></tr></table><br></i>
Here is another example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap *soap; // set by soap_new_ns__myClass() <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;setName(<b>const</b>&nbsp;<b>char</b>&nbsp;*s); <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
Calls to <i>soap_new_ns__myClass(soap, n)</i> will set the <i>soap</i> field in the class instance to the current gSOAP
environment. Because the deserializers invoke the <i>soap_new</i> functions, the <i>soap</i> field of the <i>ns__myClass</i>
instances are set as well.
This mechanism is convenient when Web Service methods need to return objects that are instantiated in the methods.
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__myMethod(<b>struct</b>&nbsp;soap *soap, ...) <br />
{ <br />
&nbsp;&nbsp;&nbsp;ns__myClass *p = soap_new_ns__myClass(soap, -1); <br />
&nbsp;&nbsp;&nbsp;p-&#62;setName("SOAP"); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
<b>void</b>&nbsp;ns__myClass::ns__setName(<b>const</b>&nbsp;<b>char</b>&nbsp;*s) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = (<b>char</b>*)soap_malloc(soap, strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = (<b>char</b>*)malloc(strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;strcpy(name, s); <br />
} <br />
ns__myClass::ns__myClass() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap = NULL; <br />
&nbsp;&nbsp;&nbsp;name = NULL; <br />
} <br />
ns__myClass::~ns__myClass() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!soap &amp;&amp; name) free(name); <br />
&nbsp;&nbsp;&nbsp;soap_unlink(soap, this); <br />
} 
</td></tr></table><br></i>
Calling <i>soap_destroy</i> right after <i>soap_serve</i> in the Web Service will destroy all dynamically allocated
class instances.

<p>
	     <h3><a name="tth_sEc7.12">
7.12</a>&nbsp;&nbsp;<font color="#0000FF">Debugging</font></h3>

<p>
To activate message logging for debugging, un-comment the <i>#define DEBUG</i> directive in <i>stdsoap2.h</i>. Compile the client and/or
server applications as described above (or simply use <i>g++ -DDEBUG ...</i> to compile with debugging activated). When the client and server applications run, they will log their activity in three
separate files:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>File</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td><i>SENT.log</i> </td><td>The SOAP content transmitted by the application </td></tr>
<tr><td><i>RECV.log</i> </td><td>The SOAP content received by the application </td></tr>
<tr><td><i>TEST.log</i> </td><td>A log containing various activities performed by the application </td></tr></table>

</td></tr></table><br></span>
<font color="#FF0000"><b>Caution</b></font>: The client and server applications may run slow due to the logging activity.

<p>
<font color="#FF0000"><b>Caution</b></font>: When installing a CGI application on the Web with debugging activated, the log files may sometimes not be created due to file
access permission restrictions imposed on CGI applications. To get around this, create empty log files with universal write
permissions. Be careful about the security implication of this.

<p>
You can test a service CGI application without deploying it on the Web.
To do this, create a client application for the service and activate message logging by this client.
Remove any old <i>SENT.log</i> file and run the client (which connects to the Web service or to another dummy, but valid address)
and copy the <i>SENT.log</i> file to another file, e.g. <i>SENT.tst</i>.
Then redirect the <i>SENT.tst</i> file to the service CGI application.  For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>myservice.cgi</i>  &lt;  <i>SENT.tst</i>
</td></tr></table><br></span>
This should display the service response on the terminal.

<p>
The file names of the log files and the logging activity can be controlled at the application level. This allows the creation of
separate log files by separate services, clients, and threads.
For example, the following service logs all SOAP messages (but no debug messages) in separate directories:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
... <br />
soap_set_recv_logfile(&amp;soap, "logs/recv/service12.log"); // append all messages received in /logs/recv/service12.log <br />
soap_set_sent_logfile(&amp;soap, "logs/sent/service12.log"); // append all messages sent in /logs/sent/service12.log <br />
soap_set_test_logfile(&amp;soap, NULL); // no file name: do not save debug messages <br />
... <br />
soap_serve(&amp;soap); <br />
...
</td></tr></table><br></i>
Likewise, messages can be logged for individual client-side remote method calls.

<p>
	     <h3><a name="tth_sEc7.13">
7.13</a>&nbsp;&nbsp;<font color="#0000FF">Libraries</font></h3>

<p>

<ul><p>
<li> The socket library is essential and requires the inclusion of the appropriate libraries with the compile command for Sun
Solaris systems:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span>
These library loading options are not required with Linux.</li>
<p>
<li> The gSOAP runtime uses the math library for the <tt>NaN</tt>, <tt>INF</tt>, and <tt>-INF</tt> floating point representations.  The library
is not strictly necessary and the <i>&lt;math.h&#62;</i> header file import can be commented out from the <i>stdsoap2.h</i> header file.
The application can be linked without the <i>-lm</i> math library e.g. under Sun Solaris:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</i>
</td></tr></table><br></span></li>
</ul>

<p>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;<font color="#0000FF">The gSOAP Remote Method Specification Format</font></h2>

<p>
A SOAP remote method is specified as a C/C++ function prototype in a header
file. The function is REQUIRED to return <i><b>int</b></i>, which is used to represent
a SOAP error code, see Section&nbsp;<a href="#sec:errcodes">8.2</a>. Multiple remote methods MAY
be declared together in one header file.

<p>
The general form of a SOAP remote method specification is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font><b>int</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> outparam);
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the method (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>)</span></dd>
 <dt><b><span class="roman"><i>method_name</i></b></dt>
	<dd>	 it the remote method name (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>)</span></dd>
 <dt><b><span class="roman"><i>inparam</i></b></dt>
	<dd>		 is the declaration of an input parameter of the remote method</span></dd>
 <dt><b><span class="roman"><i>outparam</i></b></dt>
	<dd>	 is the declaration of the output parameter of the remote method</span></dd>
</dl>
This simple form can only pass a single, non-<i><b>struct</b></i> and non-<i><b>class</b></i>
type output parameter. See&nbsp;<a href="#sec:param">8.1</a> for passing multiple output
parameters. The name of the declared function <i>namespace_prefix__
method_name</i> must be unique and cannot match the name of a <i><b>struct</b></i>,
<i><b>class</b></i>, or <i><b>enum</b></i> declared in the same header file.

<p>
The method request is encoded in SOAP as an XML element and the namespace prefix, method name, and input parameters are encoded using the format:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name&#62; <br />
&lt;inparam-name1 xsi:type="..."&#62;...&lt;/inparam-name1&#62; <br />
&lt;inparam-name2 xsi:type="..."&#62;...&lt;/inparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method_name&#62;
</td></tr></table><br></tt>
where the <tt>inparam-name</tt> accessors are the element-name representations of the <i>inparam</i> parameter name declarations, see
Section&nbsp;<a href="#sec:idtrans">8.3</a>. (The optional parts are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The XML response by the Web service is of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse&#62; <br />
&lt;outparam-name xsi:type="..."&#62;...&lt;/outparam-name&#62; <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-nameResponse&#62;
</td></tr></table><br></tt>
where the <tt>outparam-name</tt> accessor is the element-name representation of the <i>outparam</i> parameter name declaration, see
Section&nbsp;<a href="#sec:idtrans">8.3</a>. By convention, the response element name is the method name ending in <tt>Response</tt>.
See&nbsp;<a href="#sec:param">8.1</a> on how to change the declaration if the service response element name is different.

<p>
The gSOAP stub and skeleton compiler generates a stub routine for the remote
method. This stub is of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_call_<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*URL, <b>char</b>&nbsp;*action, <font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> outparam);
</td></tr></table><br></i>
This proxy can be called by a client application to perform the remote method
call.

<p>
The gSOAP stub and skeleton compiler generates a skeleton routine for the
remote method. The skeleton function is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;soap_serve_<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<b>struct</b>&nbsp;soap *soap);
</td></tr></table><br></i>
The skeleton routine, when called by a service application, will attempt to
serve a request on the standard input. If no request is present or if the
request does not match the method name, <i>SOAP_NO_METHOD</i> is returned.
The skeleton routines are automatically called by the generated
<i>soap_serve</i> routine that handles all requests.

<p>
	     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;<font color="#0000FF">Remote Method Parameter Passing</font></h3><a name="sec:param">
</a>

<p>
The input parameters of a remote method MUST be passed by value.  Input
parameters cannot be passed by reference with the <i>&amp;</i> reference operator,
but an input parameter value MAY be passed by a pointer to the data.  Of
course, passing a pointer to the data is prefered when the size of the data of
the parameter is large.  Also, to pass instances of (derived) classes, pointers
to the instance need to be used to avoid passing the instance by value which
requires a temporary and prohibits passing derived class instances.  When two
input parameter values are identical, passing them using a pointer has the
advantage that the value will be encoded only once as multi-reference (hence,
the parameters are aliases).  When input parameters are passed using a pointer,
the data pointed to will not be modified by the remote method and returned to
the caller.

<p>
The output parameter MUST be passed by reference using <i>&amp;</i> or by using a
pointer. Arrays are passed by reference by default and do not require the use
of the reference operator <i>&amp;</i>.

<p>
The input and output parameter types have certain limitations, see
Section&nbsp;<a href="#sec:limitations">7.9</a>

<p>
If the output parameter is a <i><b>struct</b></i> or <i><b>class</b></i> type, it is
considered a SOAP remote method response element instead of a simple output
parameter value. That is, the name of the <i><b>struct</b></i> or <i><b>class</b></i> is the
name of the response element and the <i><b>struct</b></i> or <i><b>class</b></i> fields are
the output parameters of the remote method, see also&nbsp;<a href="#sec:response">6.1.7</a>. Hence,
if the output parameter has to be a <i><b>struct</b></i> or <i><b>class</b></i>, a response
<i><b>struct</b></i> or <i><b>class</b></i> MUST be declared as well.  In addition, if a
remote method returns multiple output parameters, a response <i><b>struct</b></i> or
<i><b>class</b></i> MUST be declared. By convention, the response element is the
remote method name ending with ``<tt>Response</tt>''.

<p>
The general form of a response element declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>response_element_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;outparam1; <br />
&nbsp;&nbsp;&nbsp;outparam2; <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the response element (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>)</span></dd>
 <dt><b><span class="roman"><i>response_element_name</i></b></dt>
	<dd>	 it the name of the response element (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>)</span></dd>
 <dt><b><span class="roman"><i>outparam</i></b></dt>
	<dd>	 is the declaration of an output parameter of the remote method</span></dd>
</dl>
The general form of a remote method specification with a response element declaration for (multiple) output parameters is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font><b>int</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>method_name(<font size="+1"><span class="roman">[</span></font>inparam1, inparam2, ...,<font size="+1"><span class="roman">]</span></font> <b>struct</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>response_element_name {outparam1<font size="+1"><span class="roman">[</span></font>, outparam2, ...<font size="+1"><span class="roman">]</span></font>} &amp;anyparam);
</td></tr></table><br></i>
The choice of name for <i>anyparam</i> has no effect on the SOAP encoding and decoding and is only used as a place holder for the
response.

<p>
The method request is encoded in SOAP as an independent element and the
namespace prefix, method name, and input parameters are encoded using the
format:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name&#62; <br />
&lt;inparam-name1 xsi:type="..."&#62;...&lt;/inparam-name1&#62; <br />
&lt;inparam-name2 xsi:type="..."&#62;...&lt;/inparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>method-name&#62;
</td></tr></table><br></tt>
where the <tt>inparam-name</tt> accessors are the element-name representations of
the <i>inparam</i> parameter name declarations, see Section&nbsp;<a href="#sec:idtrans">8.3</a>.
(The optional parts resulting from the specification are shown enclosed in
<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The method response is expected to be of the form:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name&#62; <br />
&lt;outparam-name1 xsi:type="..."&#62;...&lt;/outparam-name1&#62; <br />
&lt;outparam-name2 xsi:type="..."&#62;...&lt;/outparam-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>response-element-name&#62;
</td></tr></table><br></tt>
where the <tt>outparam-name</tt> accessors are the element-name representations of
the <i>outparam</i> parameter name declarations, see Section&nbsp;<a href="#sec:idtrans">8.3</a>.
(The optional parts resulting from the specification are shown enclosed in
<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The input and/or output parameters can be made anonymous, which allows the
deserialization of requests/responses with different parameter names as is
endorsed by the SOAP 1.1 specification, see Section&nbsp;<a href="#sec:anonymous">6.1.13</a>.

<p>
	     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;<font color="#0000FF">Stub and Skeleton Routine Error Codes</font></h3><a name="sec:errcodes">
</a>

<p>
The error codes returned by the stub and skeleton routines are listed below.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td align="right"><font color="#FF0000"><b>#</b></font> </td><td><font color="#FF0000"><b>Code</b></font> </td><td><font color="#FF0000"><b>Description</b></font> </td></tr>
<tr><td align="right">0 </td><td><i>SOAP_OK</i> </td><td>No error </td></tr>
<tr><td align="right">1 </td><td><i>SOAP_CLI_FAULT</i>* </td><td>The service returned a client fault (SOAP 1.2 Sender fault)</td></tr>
<tr><td align="right">2 </td><td><i>SOAP_SVR_FAULT</i>* </td><td>The service returned a server fault (SOAP 1.2 Receiver fault)</td></tr>
<tr><td align="right">3 </td><td><i>SOAP_TAG_MISMATCH</i> </td><td>An XML element didn't correspond to anything expected </td></tr>
<tr><td align="right">4 </td><td><i>SOAP_TYPE_MISMATCH</i> </td><td>An XML schema type mismatch </td></tr>
<tr><td align="right">5 </td><td><i>SOAP_SYNTAX_ERROR</i> </td><td>An XML syntax error occurred on the input </td></tr>
<tr><td align="right">6 </td><td><i>SOAP_NO_TAG</i> </td><td>Begin of an element expected, but not found </td></tr>
<tr><td align="right">7 </td><td><i>SOAP_IOB</i> </td><td>Array index out of bounds </td></tr>
<tr><td align="right">8 </td><td><i>SOAP_MUSTUNDERSTAND</i>* </td><td>An element needs to be ignored that need to be understood </td></tr>
<tr><td align="right">9 </td><td><i>SOAP_NAMESPACE</i> </td><td>Namespace name mismatch (validation error) </td></tr>
<tr><td align="right">10 </td><td><i>SOAP_OBJ_MISMATCH</i> </td><td>Mismatch in the size and/or shape of an object </td></tr>
<tr><td align="right">11 </td><td><i>SOAP_FATAL_ERROR</i> </td><td>Internal error </td></tr>
<tr><td align="right">12 </td><td><i>SOAP_FAULT</i> </td><td>An exception raised by the service </td></tr>
<tr><td align="right">13 </td><td><i>SOAP_NO_METHOD</i> </td><td>Skeleton error: the skeleton cannot serve the method </td></tr>
<tr><td align="right">14 </td><td><i>SOAP_GET_METHOD</i> </td><td>Unsupported HTTP GET </td></tr>
<tr><td align="right">15 </td><td><i>SOAP_EOM</i> </td><td>Out of memory </td></tr>
<tr><td align="right">16 </td><td><i>SOAP_NULL</i> </td><td>An element was null, while it is not supposed to be null </td></tr>
<tr><td align="right">17 </td><td><i>SOAP_MULTI_ID</i> </td><td>Multiple occurrences of the same element ID on the input </td></tr>
<tr><td align="right">18 </td><td><i>SOAP_MISSING_ID</i> </td><td>Element ID missing for an HREF on the input </td></tr>
<tr><td align="right">19 </td><td><i>SOAP_HREF</i> </td><td>Reference to object is incompatible with the object refered to </td></tr>
<tr><td align="right">20 </td><td><i>SOAP_TCP_ERROR</i> </td><td>A TCP connection error occured </td></tr>
<tr><td align="right">21 </td><td><i>SOAP_HTTP_ERROR</i> </td><td>An HTTP error occured </td></tr>
<tr><td align="right">22 </td><td><i>SOAP_SSL_ERROR</i> </td><td>An SSL error occured </td></tr>
<tr><td align="right">23 </td><td><i>SOAP_ZLIB_ERROR</i> </td><td>A Zlib error occured </td></tr>
<tr><td align="right">24 </td><td><i>SOAP_DIME_ERROR</i> </td><td>DIME parsing error </td></tr>
<tr><td align="right">25 </td><td><i>SOAP_EOD</i> </td><td>End of DIME error </td></tr>
<tr><td align="right">26 </td><td><i>SOAP_VERSIONMISMATCH</i>* </td><td>SOAP version mismatch or no SOAP message </td></tr>
<tr><td align="right">27 </td><td><i>SOAP_DIME_MISMATCH</i> </td><td>DIME version mismatch </td></tr>
<tr><td align="right">28 </td><td><i>SOAP_PLUGIN_ERROR</i> </td><td>Failed to register plugin </td></tr>
<tr><td align="right">-1 </td><td><i>SOAP_EOF</i> </td><td>Unexpected end of file, no input, or timeout receiving data </td></tr></table>

</td></tr></table><br></span>
The error codes that are returned by a stub routine (proxy) upon receiving a
SOAP Fault from the server are marked (*).  The remaining error codes are
generated by the proxy itself as a result of problems with a SOAP payload.  The
error code is <i>SOAP_OK</i> when the remote method call was successful (the
<i>SOAP_OK</i> predefined constant is guaranteed to be <i>0</i>).  The error
code is also stored in <i>soap.error</i>, where <i>soap</i> is a variable that
contains the current runtime environment. The function
<i>soap_print_fault(<b>struct</b>&nbsp;soap *soap, FILE *fd)</i> can be called to
display an error message on <i>fd</i> where current value of the
<i>soap.error</i> variable is used by the function to display the error.  The
function <i>soap_print_fault_location(<b>struct</b>&nbsp;soap *soap, FILE *fd)</i>
prints the location of the error if the error is a result from parsing XML.

<p>
A remote method implemented in a SOAP service MUST return an error code as the
function's return value. <i>SOAP_OK</i> denotes success and <i>SOAP_FAULT</i>
denotes an exception. The exception details can be assigned with the
<i>soap_receiver_fault(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*faultstring,
<b>const</b>&nbsp;<b>char</b>&nbsp;*detail)</i> which sets the strings
<i>soap.fault</i><tt>-&gt;</tt><i>faultstring</i> and
<i>soap.fault</i><tt>-&gt;</tt><i>detail</i> for SOAP 1.1, and
<i>soap.fault</i><tt>-&gt;</tt><i>SOAP_ENV__Reason</i> and
<i>soap.fault</i><tt>-&gt;</tt><i>SOAP_ENV__Detail</i> for SOAP 1.2, where
<i>soap</i> is a variable that contains the current runtime environment, see
Section&nbsp;<a href="#sec:fault">10</a>.

<p>
	     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;<font color="#0000FF">C/C++ Identifier Name to XML Name Translations</font></h3><a name="sec:idtrans">
</a>

<p>
One of the ``secrets'' behind the power and flexibility of gSOAP's encoding and
decoding of remote method names, class names, type identifiers, and struct or
class fields is the ability to specify namespace prefixes with these names that
are used to denote their encoding style. More specifically, a C/C++ identifier
name of the form
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>element_name
</td></tr></table><br></i>
will be encoded in XML as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>element-name ...&#62;
</td></tr></table><br></tt>
The <b>underscore pair</b> (<i>__</i>) separates the namespace prefix from the
element name.  Each namespace prefix has a namespace URI specified by a
namespace mapping table&nbsp;<a href="#sec:nstable">8.4</a>, see also
Section&nbsp;<a href="#sec:namespace">6.1.2</a>.  The namespace URI is a unique identification that
can be associated with the remote methods and data types.  The namespace URI
disambiguates potentially identical remote method names and data type names
used by disparate organizations.

<p>
XML element names are NCNames (restricted strings) that MAY contain <b>
hypens</b>, <b>dots</b>, and <b>underscores</b>.  The special characters in the XML
element names of remote methods, structs, classes, typedefs, and fields can be
controlled using the following conventions: A <b>single underscore</b> in a
namespace prefix or identifier name is replaced by a hyphen (<tt>-</tt>) in the
XML element name.  For example, the identifier name <i>SOAP_ENC__ur_type</i>
is represented in XML as <tt>SOAP-ENC:ur-type</tt>.  The sequence <i>_DOT_</i> is
replaced by a dot (<tt>.</tt>), and the sequence <i>_USCORE_</i> is replaced by
an underscore (<tt>_</tt>) in the corresponding XML element name.  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;n_s__biz_DOT_com <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*n_s__biz_USCORE_name; <br />
};
</td></tr></table><br></i>
is encoded in XML as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;n-s:biz.com xsi:type="n-s:biz.com"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;n-s:biz_name xsi:type="string"&#62;Bizybiz&lt;/n-s:biz_name&#62; <br />
&lt;/n-s:biz.com&#62;
</td></tr></table><br></tt>
Trailing underscores of an identifier name are not translated into the XML
representation. This is useful when an identifier name clashes with a C++
keyword. For example, <tt>return</tt> is often used as an accessor name in a SOAP
response element.  The <tt>return</tt> element can be specified as <i>return_</i>
in the C++ source code. Note that XML should be treated as case sensitive, so
the use of e.g. <i>Return</i> may not always work to avoid a name clash with the
<i><b>return</b></i> keyword.  The use of trailing underscores also allows for
defining <i><b>struct</b></i>s and <i><b>class</b></i>es with essentially the same XML schema
type name, but that have to be distinghuished as seperate C/C++ types.

<p>
For decoding, the underscores in identifier names act as wildcards. An XML
element is parsed and matches the name of an identifier if the name is
identical to the element name (case insensitive) and the underscores in the
identifier name are allowed to match any character in the element name. For
example, the identifier name <i>I_want__soap_fun_the_bea___DOT_com</i>
matches the element name <tt>I-want:SOAP4fun@the-beach.com</tt>.

<p>
	     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;<font color="#0000FF">Namespace Mapping Table</font></h3><a name="sec:nstable">
</a>

<p>
A namespace mapping table MUST be defined by clients and service applications.
The mapping table is used by the serializers and deserializers of the stub and
skeleton routines to produce a valid SOAP payload and to validate an incoming
SOAP payload.  A typical mapping table is shown below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name"} <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, // MUST be first <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, // MUST be second <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance"}, // MUST be third <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema"}, // Required for XML schema types <br />
&nbsp;&nbsp;&nbsp;{"ns1",      "urn:my-service-URI"}, // The namespace URI of the remote methods <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} // end of table <br />
}; <br />
</td></tr></table><br></i>
Each namespace prefix used by a identifier name in the header file
specification (see Section&nbsp;<a href="#sec:idtrans">8.3</a>) MUST have a binding to a
namespace URI in the mapping table. The end of the namespace mapping table MUST
be indicated by the <i>NULL</i> pair.  The namespace URI matching is case
insensitive. A namespace prefix is distinghuished by the occurrence of a pair
of underscores (<i>__</i>) in an identifier.

<p>
An optional namespace pattern MAY be provided with each namespace mapping table
entry.  The patterns provide an alternative namespace matching for the
validation of decoded SOAP messages.  In this pattern, dashes (<i>-</i>) are
single-character wildcards and asterisks (<i>*</i>) are multi-character
wildcards.  For example, to decode different versions of XML Schema type with
different authoring dates, four dashes can be used in place of the specific
dates in the namespace mapping table pattern:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance", "http://www.w3.org/<tt>----</tt>/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema", "http://www.w3.org/<tt>----</tt>/XMLSchema"}, <br />
...
</td></tr></table><br></i>
Or alternatively, asterisks can be used as wildcards for multiple characters:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"xsi",      "http://www.w3.org/1999/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd",      "http://www.w3.org/1999/XMLSchema", "http://www.w3.org/*/XMLSchema"}, <br />
...
</td></tr></table><br></i>
A namespace mapping table is automatically generated together with a WSDL file
for each namespace prefix that is used for a remote method in the header file.
This namespace mapping table has entries for all namespace prefixes.  The
namespace URIs need to be filled in. These appear as <i>http://tempuri.org</i>
in the table.  See Section&nbsp;<a href="#sec:directives">13.2</a> on how to specify the namespace
URIs in the header file.

<p>
For decoding elements with namespace prefixes, the namespace URI associated with the namespace prefix (through the <tt>xmlns</tt>
attribute of an XML element) is searched from the
beginning to the end in a namespace mapping table,
and for every row the following tests are performed as part of the validation process:

<ol type="1"><p>
<li> the string in the second column matches the namespace URI (case insensitive)</li>
<p>
<li> the string in the optional third column matches the namespace URI (case insensitive), where <i>-</i> is a one-character wildcard and <i>*</i> is a
   multi-character wildcard</li>
</ol>
When a match is found, the namespace prefix in the first column of the table is considered semantically identical to the namespace prefix used
by the XML element to be decoded, though the prefix names may differ.
A service will respond with the namespace that it received from a client in case it matches a pattern in the third column.

<p>
For example, let's say we have the following structs:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;a__elt { ... }; <br />
<b>struct</b>&nbsp;b__elt { ... }; <br />
<b>struct</b>&nbsp;k__elt { ... }; <br />
</td></tr></table><br></i>
and a namespace mapping table in the program:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{&nbsp;&nbsp;&nbsp;// {"ns-prefix", "ns-name", "ns-name validation pattern"} <br />
... <br />
&nbsp;&nbsp;&nbsp;{"a", "some uri"}, <br />
&nbsp;&nbsp;&nbsp;{"b", "other uri"}, <br />
&nbsp;&nbsp;&nbsp;{"c", "his uri", "* uri"}, <br />
...
</td></tr></table><br></i>
Then, the following XML elements will match the structs:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;n:elt xmlns:n="some URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>a__elt</i> <br />
... <br />
&lt;m:elt xmlns:m="other URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>b__elt</i> <br />
... <br />
&lt;k:elt xmlns:k="my URI"&#62; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches the struct name <i>c__elt</i> <br />
... <br />
</td></tr></table><br></tt>
The response of a service to a client request that uses the namespaces listed above,
will include <tt>my URI</tt> for the name space of element <tt>k</tt>.

<p>
It is possible to use a number of different namespace tables and select the one that is appropriate.
For example, an application might contact many different Web services all using different namespace URIs.
If all the URIs are stored in one table, each remote method invocation will dump the whole namespace
table in the SOAP payload.  There is no technical problem with that, but it can be ugly when the table is large.
To use different namespace tables, declare a pointer to a table and set the pointer to a particular table before remote method
invocation.  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Namespace namespacesTable1[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace namespacesTable2[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace namespacesTable3[] = { ... }; <br />
<b>struct</b>&nbsp;Namespace *namespaces; <br />
... <br />
<b>struct</b>&nbsp;soap soap; <br />
... <br />
soap_init(&amp;soap); <br />
soap.namespaces = namespaceTable1; <br />
soap_call_remote_method(&amp;soap, URL, Action, ...); <br />
...
</td></tr></table><br></i> 

<p>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;<font color="#0000FF">gSOAP Serialization and Deserialization Rules</font></h2>

<p>
This section describes the serialization and deserialization of C and C++ data types for SOAP 1.1 and 1.2 compliant encoding and decoding.

<p>
	     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;<font color="#0000FF">Primitive Type Encoding</font></h3>

<p>
The default encoding rules for the primitive C and C++ data types are given in the table below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>XSD Type</b></font> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><tt>boolean</tt> </td></tr>
<tr><td><i><b>char</b>*</i> (C string) </td><td><tt>string</tt> </td></tr>
<tr><td><i><b>char</b></i> </td><td><tt>byte</tt> </td></tr>
<tr><td><i><b>double</b></i> </td><td><tt>double</tt> </td></tr>
<tr><td><i><b>float</b></i> </td><td><tt>float</tt> </td></tr>
<tr><td><i><b>int</b></i> </td><td><tt>int</tt> </td></tr>
<tr><td><i><b>long</b></i> </td><td><tt>long</tt> </td></tr>
<tr><td><i>LONG64</i> </td><td><tt>long</tt> </td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><tt>long</tt> </td></tr>
<tr><td><i><b>short</b></i> </td><td><tt>short</tt> </td></tr>
<tr><td><i>time_t</i> </td><td><tt>dateTime</tt> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><tt>unsignedByte</tt> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><tt>unsignedInt</tt> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><tt>unsignedLong</tt> </td></tr>
<tr><td><i>ULONG64</i> </td><td><tt>unsignedLong</tt> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><tt>unsignedLong</tt> </td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><tt>unsignedShort</tt> </td></tr>
<tr><td><i>wchar_t*</i> </td><td><tt>string</tt> </td></tr></table>

</td></tr></table><br></span>
Objects of type <i><b>void</b></i> and <i><b>void</b>*</i> cannot be encoded.
Enumerations and bit masks are supported as well, see&nbsp;<a href="#sec:enum">9.3</a>.

<p>
		     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;<font color="#0000FF">How to Encode and Decode Primitive Types as XSD Types</font></h3><a name="sec:primitive">
</a>

<p>
By default, encoding of the primitive types will take place as per SOAP
encoding style.  The encoding can be changed to any XML schema type (XSD type) with an
optional namespace prefix by using a <i><b>typedef</b></i> in the header file input to
the gSOAP stub and skeleton compiler. The declaration enables the
implementation of built-in XML schema types (also known as XSD types) such as
<tt>positiveInteger</tt>, <tt>xsd:anyURI</tt>, and <tt>xsd:date</tt> for which no
built-in data structures in C and C++ exist but which can be represented using
standard data structures such as strings, integers, and floats.

<p>
The <i><b>typedef</b></i> declaration is frequently used for convenience in C. A
<i><b>typedef</b></i> declares a type name for a (complex) type expression. The type
name can then be used in other declarations in place of the more complex type
expression, which often improves the readability of the program code.

<p>
The gSOAP compiler interprets <i><b>typedef</b></i> declarations the same way as a
regular C compiler interprets them, i.e.&nbsp;as types in declarations. In addition
however, the gSOAP compiler will also use the type name in the encoding of the
data in SOAP.  The <i><b>typedef</b></i> name will appear as the XML element name of
an independent element and as the value of the <tt>xsi:type</tt> attribute in the
SOAP payload.

<p>
Many built-in primitive and derived XSD types such as <tt>xsd:anyURI</tt>,
<tt>positiveInteger</tt>, and <tt>decimal</tt> can be stored by standard primitive
data structures in C++ as well such as strings, integers, floats, and doubles.
To serialize strings, integers, floats, and doubles as built-in primitive and
derived XSD types. To this end, a <i><b>typedef</b></i> declaration can be used
to declare an XSD type.

<p>
For example, the declaration
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;xsd__positiveInteger;
</td></tr></table><br></i>
creates a named type <i>positiveInteger</i> which is represented by <i><b>unsigned</b>&nbsp;<b>int</b></i> in C++. For example, the encoding of a
<i>positiveInteger</i> value <i>3</i> is
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;positiveInteger xsi:type="xsd:positiveInteger"&#62;3&lt;/positiveInteger&#62;
</td></tr></table><br></tt>
The built-in XML schema datatype hierarchy from the XML Schema Part 2 documentation <a href="http://www.w3.org/TR/xmlschema-2"><tt>http://www.w3.org/TR/xmlschema-2</tt></a> is depicted below.

<p>
<a name="tth_fIg1">
</a> 
<center><img src="http://www.w3.org/TR/xmlschema-2/type-hierarchy.gif"/>
</center>

<center>Figure 1: Built-in Datatype Hierarchy</center>

<p>
The built-in primitive and derived numerical XML Schema types are listed below together with their recommended <i><b>typedef</b></i>
declarations. Note that the SOAP encoding schemas for primitive types are derived from the built-in XML schema types, so
<i>SOAP_ENC__</i> can be used as a namespace prefix instead of <i>xsd__</i>.

<dl compact="compact">
 <dt><b><tt>xsd:anyURI</tt></b></dt>
	<dd>
Represents a Uniform Resource Identifier Reference (URI).
Each URI scheme imposes specialized syntax rules for URIs in that scheme, including restrictions
on the syntax of allowed fragement identifiers.
It is recommended to use strings to store <tt>xsd:anyURI</tt> XML schema types. The recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:base64Binary</tt></b></dt>
	<dd>
Represents Base64-encoded arbitrary binary data.
For using the <tt>xsd:base64Binary</tt> XML schema type, the use of the base64Binary representation of a dynamic array is <b>strongly</b> recommended,
see Section&nbsp;<a href="#sec:base64binary">9.9</a>. However, the
type can also be declared as a string and the encoding will be string-based:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__base64Binary;
</td></tr></table><br></i>
With this approach, it is solely the responsibility of the application to make sure the string content is according to the Base64 Content-Transfer-Encoding defined in Section 6.8 of RFC 2045.</dd>
 <dt><b><tt>xsd:boolean</tt></b></dt>
	<dd>
For declaring an <tt>xsd:boolean</tt> XML schema type, the use of a bool is <b>strongly</b> recommended.
If a pure C compiler is used that does not support the <i>bool</i> type, see Section&nbsp;<a href="#sec:boolean">9.3.5</a>.
The corresponding type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean;
</td></tr></table><br></i>
Type <i>xsd__boolean</i> declares a Boolean (0 or 1), which is encoded as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:boolean xsi:type="xsd:boolean"&#62;...&lt;/xsd:boolean&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:byte</tt></b></dt>
	<dd>
Represents a byte (-128...127). The corresponding type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;xsd__byte;
</td></tr></table><br></i>
Type <i>xsd__byte</i> declares a byte which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:byte xsi:type="xsd:byte"&#62;...&lt;/xsd:byte&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:dateTime</tt></b></dt>
	<dd>
Represents a date and time. The lexical representation is according to the ISO 8601 extended format CCYY-MM-DDThh:mm:ss where "CC"
represents the century, "YY" the year, "MM" the month and "DD" the day, preceded by an optional leading "-" sign to indicate a
negative number. If the sign is omitted, "+" is assumed. The letter "T" is the date/time separator and "hh", "mm", "ss" represent
hour, minute and second respectively.
It is recommended to use the <i>time_t</i> type to store <tt>xsd:dateTime</tt> XML schema types and the type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;time_t xsd__dateTime;
</td></tr></table><br></i>
However, note that calendar times  before  the year 1902  or after
the year 2037 cannot be represented. Upon receiving a date outside this range,
the <i>time_t</i> value will be set to -1.

<p>
Strings (<i><b>char</b>*</i>) can be used to store <tt>xsd:dateTime</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__dateTime;
</td></tr></table><br></i>
In this case, it is up to the application to read and set the dateTime representation.</dd>
 <dt><b><tt>xsd:date</tt></b></dt>
	<dd>
Represents a date.
The lexical representation for date is the reduced (right truncated) lexical representation for dateTime: CCYY-MM-DD.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:date</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__date;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:decimal</tt></b></dt>
	<dd>
Represents arbitrary precision decimal numbers.
It is recommended to use the <b>double</b> type to store <tt>xsd:decimal</tt> XML schema types and the type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__decimal;
</td></tr></table><br></i>
Type <i>xsd__decimal</i> declares a double floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:double xsi:type="xsd:decimal"&#62;...&lt;/xsd:double&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:double</tt></b></dt>
	<dd>
Corresponds to the IEEE double-precision 64-bit floating point type. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double;
</td></tr></table><br></i>
Type <i>xsd__double</i> declares a double floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:double xsi:type="xsd:double"&#62;...&lt;/xsd:double&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:duration</tt></b></dt>
	<dd>
Represents a duration of time.
The lexical representation for duration is the ISO 8601 extended format PnYn MnDTnH nMnS, where nY represents
the number of years, nM the number of months, nD the number of days, T is the date/time separator, nH the number of
hours, nM the number of minutes and nS the number of seconds. The number of seconds can include decimal digits to
arbitrary precision.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:duration</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__duration;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:float</tt></b></dt>
	<dd>
Corresponds to the IEEE single-precision 32-bit floating point type. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float;
</td></tr></table><br></i>
Type <i>xsd__float</i> declares a floating point number which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:float xsi:type="xsd:float"&#62;...&lt;/xsd:float&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:hexBinary</tt></b></dt>
	<dd>
Represents arbitrary hex-encoded binary data.  It has a lexical representation where each binary octet is encoded as a character
tuple, consisting of two hexadecimal digits ([0-9a-fA-F]) representing the octet code. For example, "0FB7" is a hex encoding for
the 16-bit integer 4023 (whose binary representation is 111110110111.
For using the <tt>xsd:hexBinary</tt> XML schema type, the use of the hexBinary representation of a dynamic array is <b>strongly</b> recommended,
see Section&nbsp;<a href="#sec:hexbinary">9.10</a>. However, the
type can also be declared as a string and the encoding will be string-based:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__hexBinary;
</td></tr></table><br></i>
With this approach, it is solely the responsibility of the application to make sure the string content consists of a sequence of octets.</dd>
 <dt><b><tt>xsd:int</tt></b></dt>
	<dd>
Corresponds to a 32-bit integer in the range -2147483648 to 2147483647.
If the C++ compiler supports 32-bit <i><b>int</b></i> types, the type declaration can use the <i><b>int</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>int</b>&nbsp;xsd__int;
</td></tr></table><br></i>
Otherwise, the C++ compiler supports 16-bit <i><b>int</b></i> types and the type declaration should use the <i><b>long</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int;
</td></tr></table><br></i>
Type <i>xsd__int</i> declares a 32-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:int xsi:type="xsd:int"&#62;...&lt;/xsd:int&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:integer</tt></b></dt>
	<dd>
Corresponds to an unbounded integer.
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__integer;
</td></tr></table><br></i>
Type <i>xsd__integer</i> declares a 64-bit integer which is encoded as an unbounded <tt>xsd:integer</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:integer xsi:type="xsd:integer"&#62;...&lt;/xsd:integer&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:long</tt></b></dt>
	<dd>
Corresponds to a 64-bit integer in the range -9223372036854775808 to 9223372036854775807.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__long;
</td></tr></table><br></i>
Or in Visual C++:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;LONG64 xsd__long;
</td></tr></table><br></i>
Type <i>xsd__long</i> declares a 64-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:long xsi:type="xsd:long"&#62;...&lt;/xsd:long&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:negativeInteger</tt></b></dt>
	<dd>
Corresponds to a negative unbounded integer ( &lt; 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__negativeInteger;
</td></tr></table><br></i>
Type <i>xsd__negativeInteger</i> declares a 64-bit integer which is encoded as a <tt>xsd:negativeInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:negativeInteger xsi:type="xsd:negativeInteger"&#62;...&lt;/xsd:negativeInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:nonNegativeInteger</tt></b></dt>
	<dd>
Corresponds to a non-negative unbounded integer ( &gt; 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonNegativeInteger;
</td></tr></table><br></i>
Type <i>xsd__nonNegativeInteger</i> declares a 64-bit unsigned integer which is encoded as a non-negative unbounded <tt>xsd:nonNegativeInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:nonNegativeInteger xsi:type="xsd:nonNegativeInteger"&#62;...&lt;/xsd:nonNegativeInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:nonPositiveInteger</tt></b></dt>
	<dd>
Corresponds to a non-positive unbounded integer ( <font face="symbol"></font
> 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonPositiveInteger;
</td></tr></table><br></i>
Type <i>xsd__nonPositiveInteger</i> declares a 64-bit integer which is encoded as a <tt>xsd:nonPositiveInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:nonPositiveInteger xsi:type="xsd:nonPositiveInteger"&#62;...&lt;/xsd:nonPositiveInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:normalizedString</tt></b></dt>
	<dd>
Represents normalized character strings.
Normalized character strings do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) characters.
It is recommended to use strings to store <tt>xsd:normalizeString</tt> XML schema types.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__normalizedString;
</td></tr></table><br></i>
Type <i>xsd__normalizedString</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:normalizedString xsi:type="xsd:normalizedString"&#62;...&lt;/xsd:normalizedString&#62;
</td></tr></table><br></tt>
It is solely the responsibility of the application to make sure the strings do not contain carriage return (#xD), line feed (#xA)
and tab (#x9) characters.</dd>
 <dt><b><tt>xsd:positiveInteger</tt></b></dt>
	<dd>
Corresponds to a positive unbounded integer ( <font face="symbol"></font
> 0).
Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__positiveInteger;
</td></tr></table><br></i>
Type <i>xsd__positiveInteger</i> declares a 64-bit unsigned integer which is encoded as a <tt>xsd:positiveInteger</tt>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:positiveInteger xsi:type="xsd:positiveInteger"&#62;...&lt;/xsd:positiveInteger&#62;
</td></tr></table><br></tt>
Another possibility is to use strings to represent unbounded integers and do the translation in code.</dd>
 <dt><b><tt>xsd:short</tt></b></dt>
	<dd>
Corresponds to a 16-bit integer in the range -323768 to 323767.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>short</b>&nbsp;xsd__short;
</td></tr></table><br></i>
Type <i>xsd__short</i> declares a short 16-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:short xsi:type="xsd:short"&#62;...&lt;/xsd:short&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:string</tt></b></dt>
	<dd>
Represents character strings. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string;
</td></tr></table><br></i>
Type <i>xsd__string</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:string xsi:type="xsd:string"&#62;...&lt;/xsd:string&#62;
</td></tr></table><br></tt>
The type declaration for wide character strings is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *xsd__string;
</td></tr></table><br></i>
Both type of strings can be used at the same time, but requires one typedef name to be changed by appending an underscore which is
invisible in XML. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *xsd__string_;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:time</tt></b></dt>
	<dd>
Represents a time.  The lexical representation for time is the left truncated lexical representation for dateTime: hh:mm:ss.sss
with optional following time zone indicator.
It is recommended to use strings (<i><b>char</b>*</i>) to store <tt>xsd:time</tt> XML schema types. The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__time;
</td></tr></table><br></i></dd>
 <dt><b><tt>xsd:token</tt></b></dt>
	<dd>
Represents tokenized strings.
Tokens are strings that do not contain the
line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and that have no internal
sequences of two or more spaces.
It is recommended to use strings to store <tt>xsd:token</tt> XML schema types.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__token;
</td></tr></table><br></i>
Type <i>xsd__token</i> declares a string type which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:token xsi:type="xsd:token"&#62;...&lt;/xsd:token&#62;
</td></tr></table><br></tt>
It is solely the responsibility of the application to make sure the strings do not contain the line feed (#xA) nor tab (#x9)
characters, that have no leading or trailing spaces (#x20) and that have no internal sequences of two or more spaces.</dd>
 <dt><b><tt>xsd:unsignedByte</tt></b></dt>
	<dd>
Corresponds to an 8-bit unsigned integer in the range 0 to 255.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;xsd__unsignedByte;
</td></tr></table><br></i>
Type <i>xsd__unsignedByte</i> declares a unsigned 8-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedByte xsi:type="xsd:unsignedByte"&#62;...&lt;/xsd:unsignedByte&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedInt</tt></b></dt>
	<dd>
Corresponds to a 32-bit unsigned integer in the range 0 to 4294967295.
If the C++ compiler supports 32-bit <i><b>int</b></i> types, the type declaration can use the <i><b>int</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;xsd__unsignedInt;
</td></tr></table><br></i>
Otherwise, the C++ compiler supports 16-bit <i><b>int</b></i> types and the type declaration should use the <i><b>long</b></i> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedInt;
</td></tr></table><br></i>
Type <i>xsd__unsignedInt</i> declares an unsigned 32-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedInt xsi:type="xsd:unsignedInt"&#62;...&lt;/xsd:unsignedInt&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedLong</tt></b></dt>
	<dd>
Corresponds to a 64-bit unsigned integer in the range 0 to 18446744073709551615.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedLong;
</td></tr></table><br></i>
Or in Visual C++:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;ULONG64 xsd__unsignedLong;
</td></tr></table><br></i>
Type <i>xsd__unsignedLong</i> declares an unsigned 64-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedLong xsi:type="xsd:unsignedLong"&#62;...&lt;/xsd:unsignedLong&#62;
</td></tr></table><br></tt></dd>
 <dt><b><tt>xsd:unsignedShort</tt></b></dt>
	<dd>
Corresponds to a 16-bit unsigned integer in the range 0 to 65535.
The type declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>short</b>&nbsp;xsd__unsignedShort;
</td></tr></table><br></i>
Type <i>xsd__unsginedShort</i> declares an unsigned short 16-bit integer which is encoded as 
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:unsignedShort xsi:type="xsd:unsignedShort"&#62;...&lt;/xsd:unsignedShort&#62;
</td></tr></table><br></tt></dd>
</dl>
Other XML schema types such as <tt>gYearMonth</tt>, <tt>gYear</tt>, <tt>gMonthDay</tt>, <tt>gDay</tt>, <tt>xsd:gMonth</tt>, <tt>QName</tt>,
<tt>NOTATION</tt>, etc., can be encoded similarly using a <i><b>typedef</b></i> declaration.

<p>
		      <h4><a name="tth_sEc9.2.1">
9.2.1</a>&nbsp;&nbsp;<font color="#0000FF">How to Use Multiple C/C++ Types for a Single Primitive XSD Type</font></h4>

<p>
Trailing underscores (see Section&nbsp;<a href="#sec:idtrans">8.3</a>) can be used in the type
name in a <i><b>typedef</b></i> to enable the declaration of multiple storage formats
for a single XML schema type. For example, one part of a C/C++ application's
data structure may use plain strings while another part may use wide character
strings.  To enable this simultaneous use, declare:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;wchar_t *xsd__string_;
</td></tr></table><br></i>
Now, the <i>xsd__string</i> and <i>xsd__string_</i> types will both be encoded
and decoded as XML string types and the use of trailing underscores allows
multiple declarations for a single XML schema type.

<p>
		      <h4><a name="tth_sEc9.2.2">
9.2.2</a>&nbsp;&nbsp;<font color="#0000FF">How to use Wrapper Classes to Specify Polymorphic Primitive Types</font></h4><a name="sec:primclass">
</a>

<p>
SOAP 1.1 supports polymorphic types, because XML schema types form a hierarchy.
The root of the hierarchy is called <tt>xsd:anyType</tt> (<tt>xsd:ur-type</tt> in the
older 1999 schema).  So, for example, an array of <tt>xsd:anyType</tt> in SOAP may
actually contain any mix of element types that are the derived types of the
root type.  The use of polymorphic types is indicated by the WSDL and schema
descriptions of a Web service and can therefore be predicted/expected for each
particular case.

<p>
On the one hand, the <i><b>typedef</b></i> construct provides a convenient way to
associate C/C++ types with XML schema types and makes it easy to incorporate
these types in a (legacy) C/C++ application.  However, on the other hand the
<i><b>typedef</b></i> declarations cannot be used to support polymorphic XML schema
types.  Most SOAP clients and services do not use polymorphic types.  In case
they do, the primitive polymorphic types can be declared as a hierarchy of C++
<i><b>class</b></i>es that can be used simultaneously with the <i><b>typedef</b></i>
declarations.

<p>
The general form of a primitive type declaration that is derived from a super type is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__type_name: <font size="+1"><span class="roman">[</span></font><b>public</b>&nbsp;xsd__super_type_name<font size="+1"><span class="roman">]</span></font> <br />
{ <b>public</b>: <u><span class="roman">Type</span></u> __item; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where <u><span class="roman">Type</span></u> is a primitive C type. The <i>__item</i> field MUST be the first
field in this wrapper class.

<p>
For example, the XML schema type hierarchy can be copied to C++ with the following declarations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__anyType { }; <br />
<b>class</b>&nbsp;xsd__anySimpleType: <b>public</b>&nbsp;xsd__anyType { }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; <br />
<b>class</b>&nbsp;xsd__anyURI_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__anyURI __item; }; <br />
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;xsd__boolean; <br />
<b>class</b>&nbsp;xsd__boolean_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__boolean __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__date; <br />
<b>class</b>&nbsp;xsd__date_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__date __item; }; <br />
<b>typedef</b>&nbsp;time_t xsd__dateTime; <br />
<b>class</b>&nbsp;xsd__dateTime_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__dateTime __item; }; <br />
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>class</b>&nbsp;xsd__double_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__double __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__duration; <br />
<b>class</b>&nbsp;xsd__duration_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__duration __item; }; <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>class</b>&nbsp;xsd__float_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__float __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__time; <br />
<b>class</b>&nbsp;xsd__time_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__time __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__decimal; <br />
<b>class</b>&nbsp;xsd__decimal_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__decimal __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__integer; <br />
<b>class</b>&nbsp;xsd__integer_: <b>public</b>&nbsp;xsd__decimal_ { <b>public</b>: xsd__integer __item; }; <br />
<b>typedef</b>&nbsp;LONG64 xsd__long; <br />
<b>class</b>&nbsp;xsd__long_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__long __item; }; <br />
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; <br />
<b>class</b>&nbsp;xsd__int_: <b>public</b>&nbsp;xsd__long_ { <b>public</b>: xsd__int __item; }; <br />
<b>typedef</b>&nbsp;<b>short</b>&nbsp;xsd__short; <br />
<b>class</b>&nbsp;xsd__short_: <b>public</b>&nbsp;xsd__int_ { <b>public</b>: xsd__short __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;xsd__byte; <br />
<b>class</b>&nbsp;xsd__byte_: <b>public</b>&nbsp;xsd__short_ { <b>public</b>: xsd__byte __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__nonPositiveInteger; <br />
<b>class</b>&nbsp;xsd__nonPositiveInteger_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__nonPositiveInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__negativeInteger; <br />
<b>class</b>&nbsp;xsd__negativeInteger_: <b>public</b>&nbsp;xsd__nonPositiveInteger_ { <b>public</b>: xsd__negativeInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__nonNegativeInteger; <br />
<b>class</b>&nbsp;xsd__nonNegativeInteger_: <b>public</b>&nbsp;xsd__integer_ { <b>public</b>: xsd__nonNegativeInteger __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__positiveInteger; <br />
<b>class</b>&nbsp;xsd__positiveInteger_: <b>public</b>&nbsp;xsd__nonNegativeInteger_ { <b>public</b>: xsd__positiveInteger __item; }; <br />
<b>typedef</b>&nbsp;ULONG64 xsd__unsignedLong; <br />
<b>class</b>&nbsp;xsd__unsignedLong_: <b>public</b>&nbsp;xsd__nonNegativeInteger_ { <b>public</b>: xsd__unsignedLong __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;xsd__unsignedInt; <br />
<b>class</b>&nbsp;xsd__unsignedInt_: <b>public</b>&nbsp;xsd__unsginedLong_ { <b>public</b>: xsd__unsignedInt __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>short</b>&nbsp;xsd__unsignedShort; <br />
<b>class</b>&nbsp;xsd__unsignedShort_: <b>public</b>&nbsp;xsd__unsignedInt_ { <b>public</b>: xsd__unsignedShort __item; }; <br />
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;xsd__unsignedByte; <br />
<b>class</b>&nbsp;xsd__unsignedByte_: <b>public</b>&nbsp;xsd__unsignedShort_ { <b>public</b>: xsd__unsignedByte __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>class</b>&nbsp;xsd__string_: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: xsd__string __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__normalizedString; <br />
<b>class</b>&nbsp;xsd__normalizedString_: <b>public</b>&nbsp;xsd__string_ { <b>public</b>: xsd__normalizedString __item; }; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__token; <br />
<b>class</b>&nbsp;xsd__token_: <b>public</b>&nbsp;xsd__normalizedString_ { <b>public</b>: xsd__token __item; }; <br />
</td></tr></table><br></i>
Note the use of the trailing underscores for the <i><b>class</b></i> names to distinhuish the <i><b>typedef</b></i> type names from the
<i><b>class</b></i> names.  Only the most frequently used built-in schema types are shown.
It is also allowed to include the <i>xsd:base64Binray</i> and <i>xsd:hexBinary</i> types in the hierarchy:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: <b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <b>int</b>&nbsp;__size; }; <br />
<b>class</b>&nbsp;xsd__hexBinary: <b>public</b>&nbsp;xsd__anySimpleType { <b>public</b>: <b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <b>int</b>&nbsp;__size; };
</td></tr></table><br></i>
See Sections&nbsp;<a href="#sec:base64binary">9.9</a> and&nbsp;<a href="#sec:hexbinary">9.10</a>.

<p>
Methods are allowed to be added to the classes above, such as constructors and getter/setter methods.

<p>
Wrapper structs are supported as well, similar to wrapper classes.  But thay cannot be used
to implement polymorphism.  Rather, the wrapper structs facilitate the use of XML attributes
with a primitive typed object, see&nbsp;<a href="#sec:attributes">9.5.5</a>.

<p>
		      <h4><a name="tth_sEc9.2.3">
9.2.3</a>&nbsp;&nbsp;<font color="#0000FF">XML Schema Type Decoding Rules</font></h4>

<p>
The decoding rules for the primitive C and C++ data types is given in the table below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Allows Decoding of</b></font> </td><td><font color="#FF0000"><b>Precision Lost?</b></font> </td></tr>
<tr><td><i><b>bool</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>boolean</tt> </td><td>no </td></tr>
<tr><td><i><b>char</b>*</i> (C string) </td><td>any type, see&nbsp;<a href="#sec:smart">9.2.5</a> </td><td>no </td></tr>
<tr><td><i>wchar_t *</i> (wide string) </td><td>any type, see&nbsp;<a href="#sec:smart">9.2.5</a> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>double</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>double</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>float</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>decimal</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>float</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>float</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>decimal</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>long</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>integer</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>negativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonPositiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr></table>

</td></tr></table><br></span>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Type</b></font> </td><td><font color="#FF0000"><b>Allows Decoding of</b></font> </td><td><font color="#FF0000"><b>Precision Lost?</b></font> </td></tr>
<tr><td><i><b>long</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>long</tt> </td><td>possibly, if <i><b>long</b></i> is 32 bit </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>int</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>int</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>short</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>short</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>char</b></i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>byte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>positiveInteger</tt> </td><td>possibly </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>nonNegativeInteger</tt> </td><td>possibly </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>long</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedLong</tt> </td><td>possibly, if <i><b>long</b></i> is 32 bit </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>int</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedInt</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>short</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedShort</tt> </td><td>no </td></tr>
<tr><td></td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i><b>unsigned</b>&nbsp;<b>char</b></i> </td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>unsignedByte</tt> </td><td>no </td></tr>
<tr><td></td></tr>
<tr><td><i>time_t</i>	</td><td><tt><font size="+1"><span class="roman">[</span></font>xsd:<font size="+1"><span class="roman">]</span></font>dateTime</tt> </td><td>no(?) </td></tr>
<tr><td></td></tr></table>

</td></tr></table><br></span>
Due to limitations in representation of certain primitive C++ types, a possible loss of accuracy may occur with the decoding of certain XML schema types as is indicated in the table. The table does not indicate the possible loss of precision of floating point values due to the textual representation of floating point values in SOAP.

<p>
All explicitly declared XML schema encoded primitive types adhere to the same decoding rules. For example, the following declaration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b>&nbsp;xsd__nonNegativeInteger;
</td></tr></table><br></i>
enables the encoding and decoding of <tt>xsd:nonNegativeInteger</tt> XML schema types (although decoding takes place with a possible
loss of precision).
The declaration also allows decoding of <tt>xsd:positiveInteger</tt> XML schema types, because of the storage as a <i><b>unsigned</b>&nbsp;<b>long</b>&nbsp;<b>long</b></i> data type.

<p>
		      <h4><a name="tth_sEc9.2.4">
9.2.4</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Reference Strings</font></h4>

<p>
If more than one <i><b>char</b></i> pointer points to the same string, the string is encoded as a multi-reference value.
Consider for example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;*s = "hello", *t = s;
</td></tr></table><br></i>
The <i>s</i> and <i>t</i> variables are assigned the same string, and when serialized, <i>t</i> refers to the content of <i>s</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;string id="123" xsi:type="string"&#62;hello&lt;/string&#62; <br />
... <br />
&lt;string href="#123"/&#62;
</td></tr></table><br></tt>
The example assumed that <i>s</i> and <i>t</i> are encoded as independent elements.

<p>
Note: the use of <i><b>typedef</b></i> to declare a string type such as <i>xsd__string</i> will not affect the multi-reference string
encoding.  However, strings declared with different <i><b>typedef</b></i>s will never be considered multi-reference even when they point
to the same string.  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__anyURI; <br />
xsd__anyURI *s = "http://www.myservice.com"; <br />
xsd__string *t = s;
</td></tr></table><br></i>
The variables <i>s</i> and <i>t</i> point to the same string, but since they are considered different types their content will not
be shared in the SOAP payload through a multi-referenced string.

<p>
		      <h4><a name="tth_sEc9.2.5">
9.2.5</a>&nbsp;&nbsp;<font color="#0000FF">``Smart String'' Mixed-Content Decoding</font></h4><a name="sec:smart">
</a>

<p>
The implementation of string decoding in gSOAP allows for mixed content decoding. If the SOAP payload contains a complex data type in place of
a string, the complex data type is decoded in the string as plain XML text.

<p>
For example, suppose the <i>getInfo</i> remote method returns some detailed information. The remote method is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file "getInfo.h": <br />
getInfo(<b>char</b>&nbsp;*detail);
</td></tr></table><br></i>
The proxy of the remote method is used by a client to request a piece of information and the service responds with:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
HTTP/1.1 200 OK <br />
Content-Type: text/xml <br />
Content-Length: nnn <br />
<br />
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/1999/XMLSchema" <br />
&lt;SOAP-ENV:Body&#62; <br />
&lt;getInfoResponse&#62; <br />
&lt;detail&#62; <br />
&lt;picture&#62;Mona Lisa by &lt;i&#62;Leonardo da Vinci&lt;/i&#62;&lt;/picture&#62; <br />
&lt;/detail&#62; <br />
&lt;/getInfoResponse&#62; <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
As a result of the mixed content decoding, the <i>detail</i> string contains ``<tt>&lt;picture&#62;Mona Lisa by &lt;i&#62;Leonardo da Vinci&lt;/i&#62;&lt;/picture&#62;</tt>''.

<p>
		      <h4><a name="tth_sEc9.2.6">
9.2.6</a>&nbsp;&nbsp;<font color="#0000FF">Changing the Encoding Precision of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></h4>

<p>
The <i>double</i> encoding format is by default set to ``<i>%.18G</i>'' (see a manual on <i>printf</i> text formatting in C),
i.e.&nbsp;at most 18 digits of precision to limit a loss in accuracy.
The <i>float</i> encoding format is by default ``<i>%.9G</i>'', i.e.&nbsp;at most 9 digits of precision.

<p>
The encoding format of a double type can be set by assigning a format string to <i>soap.double_format</i>, where <i>soap</i> is a
variable that contains the
current runtime environment. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); // sets double_format = "%.18G" <br />
soap.double_format = "%e"; // redefine
</td></tr></table><br></i>
which causes all doubles to be encoded in scientific notation.
Likewise, the encoding format of a float type can be set by assigning a format string to the static <i>soap_float_format</i> string variable. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); // sets float_format = "%.9G" <br />
soap.float_format = "%.4f"; // redefine
</td></tr></table><br></i>
which causes all floats to be encoded with four digits precision.

<p>
<font color="#FF0000"><b>Caution</b></font>: The format strings are not automatically reset before or after SOAP communications. An error in the format string may result in the incorrect encoding of floating point values.

<p>
		      <h4><a name="tth_sEc9.2.7">
9.2.7</a>&nbsp;&nbsp;<font color="#0000FF">INF, -INF, and NaN Values of <b>float</b>&nbsp;and <b>double</b>&nbsp;Types</font></h4>

<p>
The gSOAP runtime <i>stdsoap2.cpp</i> and header file <i>stdsoap2.h</i> support the marshalling of IEEE INF, -INF, and NaN
representations.  Under certain circumstances this may break if the hardware and/or C/C++ compiler does not support these
representations.
To remove the representations, remove the inclusion of the <i>&lt;math.h&#62;</i> header file from the <i>stdsoap2.h</i> file.
You can control the representations as well, which are defined by the macros:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define FLT_NAN <br />
#define FLT_PINFTY <br />
#define FLT_NINFTY <br />
#define DBL_NAN <br />
#define DBL_PINFTY <br />
#define DBL_NINFTY
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;<font color="#0000FF">Enumeration Type Encoding and Decoding</font></h3><a name="sec:enum">
</a>

<p>
Enumerations are generally useful for the declaration of named integer-valued constants, also called enumeration constants.

<p>
		      <h4><a name="tth_sEc9.3.1">
9.3.1</a>&nbsp;&nbsp;<font color="#0000FF">Symbolic Encoding of Enumeration Constants</font></h4>

<p>
The gSOAP stub and skeleton compiler encodes the constants of enumeration-typed variables in symbolic form using the names of the constants when possible to comply to SOAP's XML schema enumeration encoding style. Consider for example the following enumeration of weekdays:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
</td></tr></table><br></i>
The enumeration-constant <i>Mon</i>, for example, is encoded as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;weekday xsi:type="weekday"&#62;Mon&lt;/weekday&#62;
</td></tr></table><br></tt>
The value of the <tt>xsi:type</tt> attribute is the enumeration-type identifier's name. If the element is independent as in the example above, the element name is the enumeration-type identifier's name.

<p>
The encoding of complex types such as enumerations requires a reference to an XML schema through the use of a namespace prefix. The namespace prefix can be specified as part of the enumeration-type identifier's name, with the usual namespace prefix conventions for identifiers. This can be used to explicitly specify the encoding style. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
</td></tr></table><br></i>
The enumeration-constant <i>Sat</i>, for example, is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns1:weekday xsi:type="ns1:weekday"&#62;Sat&lt;/ns1:weekday&#62;
</td></tr></table><br></tt>
The corresponding XML schema for this enumeration data type would be:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:element name="weekday" type="tns:weekday"/&#62; <br />
&lt;xsd:simpleType name="weekday"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;xsd:restriction base="xsd:string"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Mon"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Tue"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Wed"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Thu"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Fri"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Sat"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsd:enumeration value="Sun"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/xsd:restriction&#62; <br />
&lt;/xsd:simpleType&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc9.3.2">
9.3.2</a>&nbsp;&nbsp;<font color="#0000FF">Literal Encoding of Enumeration Constants</font></h4>

<p>
If the value of an enumeration-typed variable has no corresponding named constant, the value is encoded as a signed integer literal. For example, the following declaration of a <i>workday</i> enumeration type lacks named constants for Saturday and Sunday:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri};
</td></tr></table><br></i>
If the constant <i>5</i> (Saturday) or <i>6</i> (Sunday) is assigned to a variable of the <i>workday</i> enumeration type, the variable will be encoded with the integer literals <tt>5</tt> and <tt>6</tt>, respectively. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns1:workday xsi:type="ns1:workday"&#62;5&lt;/ns1:workday&#62;
</td></tr></table><br></tt>
Since this is legal in C++ and SOAP allows enumeration constants to be integer literals, this method ensures that non-symbolic
enumeration constants are correctly communicated to another party if the other party accepts literal enumeration constants (as
with the gSOAP stub and skeleton compiler).

<p>
Both symbolic and literal enumeration constants can be decoded.

<p>
To enforce the literal enumeration constant encoding and to get the literal constants in the WSDL file, use the following trick:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__nums { _1 = 1, _2 = 2, _3 = 3 };
</td></tr></table><br></i>
The difference with an enumeration type without a list of values and the enumeration type above is that the enumeration constants
will appear in the WSDL service description.

<p>
		      <h4><a name="tth_sEc9.3.3">
9.3.3</a>&nbsp;&nbsp;<font color="#0000FF">Initialized Enumeration Constants</font></h4>

<p>
The gSOAP compiler supports the initialization of enumeration constants, as in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__relation {LESS = -1, EQUAL = 0, GREATER = 1};
</td></tr></table><br></i>
The symbolic names <tt>LESS</tt>, <tt>EQUAL</tt>, and <tt>GREATER</tt> will appear in the SOAP payload for the encoding of the <i>ns1__relation</i> enumeration values <i>-1</i>, <i>0</i>, and <i>1</i>, respectively.

<p>
		      <h4><a name="tth_sEc9.3.4">
9.3.4</a>&nbsp;&nbsp;<font color="#0000FF">How to ``Reuse'' Symbolic Enumeration Constants</font></h4>

<p>
A well-known deficiency of C and C++ enumeration types is the lack of support for the reuse of symbolic names by multiple enumerations. That is, the names of all the symbolic constants defined by an enumeration cannot be reused by another enumeration. To force encoding of the same symbolic name by different enumerations, the identifier of the symbolic name can end in an underscore (<i>_</i>) or any number of underscores to distinghuish it from other symbolic names in C++. This guarantees that the SOAP encoding will use the same name, while the symbolic names can be distinghuished in C++. Effectively, the underscores are removed from a symbolic name prior to encoding.

<p>
Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri}; <br />
<b>enum</b>&nbsp;ns1__weekday {Mon_, Tue_, Wed_, Thu_, Fri_, Sat_, Sun_};
</td></tr></table><br></i>
which will result in the encoding of the constants of <i>enum ns1__weekday</i> without the underscore, for example as <tt>Mon</tt>.

<p>
<font color="#FF0000"><b>Caution</b></font>: The following declaration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns1__workday {Mon, Tue, Wed, Thu, Fri}; <br />
<b>enum</b>&nbsp;ns1__weekday {Sat = 5, Sun = 6};
</td></tr></table><br></i>
will not properly encode the <i>weekday</i> enumeration, because it lacks the named constants for <i>workday</i> in its enumeration list.

<p>
		      <h4><a name="tth_sEc9.3.5">
9.3.5</a>&nbsp;&nbsp;<font color="#0000FF">Boolean Enumeration Type Encoding and Decoding for C Compilers</font></h4><a name="sec:boolean">
</a>

<p>
When a pure C compiler is used to create SOAP clients and services, the <i>bool</i> type may not be supported by the compiler and
in that case an enumeration type should be used.  The C enumeration-type encoding adopted by the gSOAP stub and skeleton compiler
can be used to encode boolean values according to the SOAP encoding style. The namespace prefix can be specified with the usual
namespace prefix convention for identifiers to explicitly specify the encoding style. For example, the built-in <tt>boolean</tt> XML
schema type supports the mathematical concept of binary-valued logic. The <tt>boolean</tt> XML schema encoding style can be specified
by using the <tt>xsd</tt> prefix. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;xsd__boolean {false_, true_};
</td></tr></table><br></i>
The value <i>false_</i>, for example, is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;xsd:boolean xsi:type="xsd:boolean"&#62;false&lt;/xsd:boolean&#62; <br />
</td></tr></table><br></tt>
Peculiar of the SOAP boolean type encoding is that it only defines the values <tt>0</tt> and <tt>1</tt>, while the built-in XML schema boolean type also defines the <tt>false</tt> and <tt>true</tt> symbolic constants as valid values. The following example declaration of an enumeration type lacks named constants altogether to force encoding of the enumeration values as literal constants:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;SOAP_ENC__boolean {};
</td></tr></table><br></i>
The value <i>0</i>, for example, is encoded with an integer literal:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;SOAP-ENC:boolean xsi:type="SOAP-ENC:boolean"&#62;0&lt;SOAP-ENC:boolean&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc9.3.6">
9.3.6</a>&nbsp;&nbsp;<font color="#0000FF">Bitmask Enumeration Encoding and Decoding</font></h4>

<p>
A bitmask is an enumeration of flags such as declared with C#'s [Flags] <i><b>enum</b></i> annotation.
gSOAP supports bitmask encoding and decoding for interoperability. However, bitmask types are not standardized with SOAP RPC.

<p>
A special syntactic convention is used in the header file input to the gSOAP compiler to indicate the use of bitmasks with an
asterisk:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;* <i>name</i> { <i>enum-constant</i>, <i>enum-constant</i>, ... };
</td></tr></table><br></i>
The gSOAP compiler will encode the enumeration constants as flags, i.e. as a series of powers of 2 starting with 1.
The enumeration constants can be or-ed to form a bitvector (bitmask) which is encoded and decoded as a list of symbolic values
in SOAP.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;* ns__machineStatus { ON, BELT, VALVE, HATCH}; <br />
<b>int</b>&nbsp;ns__getMachineStatus(<b>char</b>&nbsp;*name, <b>char</b>&nbsp;*<b>enum</b>&nbsp;ns__machineStatus result);
</td></tr></table><br></i>
Note that the use of the <i><b>enum</b></i> does not require the asterisk, only the definition.
The gSOAP compiler generates the enumeration:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>enum</b>&nbsp;ns__machineStatus { ON=1, BELT=2, VALVE=4, HATCH=8};
</td></tr></table><br></i>
A remote method implementation in a Web service can return:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;ns__getMachineStatus(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*name, <b>enum</b>&nbsp;ns__machineStatus result) <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;*result = BELT | HATCH; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc9.4">
9.4</a>&nbsp;&nbsp;<font color="#0000FF">Struct Encoding and Decoding</font></h3>

<p>
A <i><b>struct</b></i> data type is encoded as a SOAP compound data type such that the
<i><b>struct</b></i> name forms the data type's element name and schema type and the
fields of the <i><b>struct</b></i> are the data type's accessors. This encoding is
identical to the <i><b>class</b></i> instance encoding without inheritance and method
declarations, see Section&nbsp;<a href="#sec:class">9.5</a> for further details.  However, the
encoding and decoding of <i><b>struct</b></i>s is more efficient compared to
<i><b>class</b></i> instances due to the lack of inheritance and the requirement by
the marshalling routines to check inheritance properties at run time.

<p>
Certain fields of a <i><b>struct</b></i> can be (de)serialized as XML attributes.
See&nbsp;<a href="#sec:attributes">9.5.5</a> for more details.

<p>
	     <h3><a name="tth_sEc9.5">
9.5</a>&nbsp;&nbsp;<font color="#0000FF">Class Instance Encoding and Decoding</font></h3><a name="sec:class">
</a>

<p>
A <i><b>class</b></i> instance is encoded as a SOAP compound data type such that the <i><b>class</b></i> name forms the data type's element name and schema type and the data member fields are the data type's accessors. Only the data member fields are encoded in the SOAP payload. Class methods are not encoded.

<p>
The general form of a <i><b>class</b></i> declaration is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;<font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>class_name1 <font size="+1"><span class="roman">[</span></font>:<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>namespace_prefix__<font size="+1"><span class="roman">]</span></font>class_name2<font size="+1"><span class="roman">]</span></font> <br />
{ <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;field1; <br />
&nbsp;&nbsp;&nbsp;field2; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><b>public</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>private</b>:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font><b>protected</b>:<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
</td></tr></table><br></i>
where

<dl compact="compact">
 <dt><b><span class="roman"><i>namespace_prefix__</i></b></dt>
	<dd> is the optional namespace prefix of the compound data type (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>)</span></dd>
 <dt><b><span class="roman"><i>class_name1</i></b></dt>
	<dd>	 is the element name of the compound data type (see identifier translation rules&nbsp;<a href="#sec:idtrans">8.3</a>).</span></dd>
 <dt><b><span class="roman"><i>class_name2</i></b></dt>
	<dd>	 is an optional base class.</span></dd>
 <dt><b><span class="roman"><i>field</i></b></dt>
	<dd>	 is a field declaration (data member). A field MAY be declared <i><b>static</b></i> and <i><b>const</b></i> and MAY be initialized.</span></dd>
 <dt><b><span class="roman"><i>method</i></b></dt>
	<dd> is a method declaration. A method MAY be declared <i><b>virtual</b></i>, but abstract methods are not allowed. The method parameter declarations are REQUIRED to have parameter identifier names.</span></dd>
 <dt><b><font size="+1"><span class="roman">[</span></font>public:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>private:<font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>protected:<font size="+1"><span class="roman">]</span></font></b></dt>
	<dd> are OPTIONAL and have no effect on the declaration and MAY therefore be
ommitted. All access permissions are converted to <i><b>public</b></i> by the gSOAP stub and skeleton compiler.</dd>
</dl>
A class name is REQUIRED to be unique and cannot have the same name as a <i><b>struct</b></i>, <i><b>enum</b></i>, or remote method name
specified in the header file input to the gSOAP compiler.
The reason is that remote method requests are encoded similarly to class instances in SOAP and they are in principle undistinghuishable (the method parameters are encoded just as the fields of a <i><b>class</b></i>).

<p>
Only single inheritance is supported by the gSOAP compiler. Multiple inheritance is not supported, because of the limitations of the SOAP protocol.

<p>
If a constructor method is present, there MUST also be a constructor declaration with empty parameter list.

<p>
Templates are not supported by the gSOAP compiler.

<p>
Certain fields of a <i><b>class</b></i> can be (de)serialized as XML attributes.
See&nbsp;<a href="#sec:attributes">9.5.5</a> for more details.

<p>
A <i><b>class</b></i> instance is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name xsi:type="<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name"&#62; <br />
&lt;basefield-name1 xsi:type="..."&#62;...&lt;/basefield-name1&#62; <br />
&lt;basefield-name2 xsi:type="..."&#62;...&lt;/basefield-name2&#62; <br />
... <br />
&lt;field-name1 xsi:type="..."&#62;...&lt;/field-name1&#62; <br />
&lt;field-name2 xsi:type="..."&#62;...&lt;/field-name2&#62; <br />
... <br />
&lt;/<font size="+1"><span class="roman">[</span></font>namespace-prefix:<font size="+1"><span class="roman">]</span></font>class-name&#62;
</td></tr></table><br></tt>
where the <tt>field-name</tt> accessors have element-name representations of the class fields and the <tt>basefield-name</tt> accessors have element-name representations of the base class fields. (The optional parts resulting from the specification are shown enclosed in <font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">]</span></font>.)

<p>
The decoding of a class instance allows any ordering of the accessors in the SOAP payload. However, if a base class field name is
identical to a derived class field name because the field is overloaded, the base class field name MUST precede the derived class
field name in the SOAP payload for decoding.  gSOAP guarantees this, but interoperability with other SOAP implementations is
cannot be guaranteed.

<p>
		      <h4><a name="tth_sEc9.5.1">
9.5.1</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4>

<p>
The following example declares a base class <i>ns__Object</i> and a derived class <i>ns__Shape</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "shape.h": <br />
<b>class</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
}; <br />
<b>class</b>&nbsp;ns__Shape : <b>public</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;sides; <br />
&nbsp;&nbsp;&nbsp;<b>enum</b>&nbsp;ns__Color {Red, Green, Blue} color; <br />
&nbsp;&nbsp;&nbsp;ns__Shape(); <br />
&nbsp;&nbsp;&nbsp;ns__Shape(<b>int</b>&nbsp;sides, <b>enum</b>&nbsp;ns__Green color); <br />
&nbsp;&nbsp;&nbsp;~ns__Shape(); <br />
};
</td></tr></table><br></i>
The implementation of the methods of <i><b>class</b>&nbsp;ns__Shape</i> must not be part of the header file and need to be defined elsewhere.

<p>
An instance of <i><b>class</b>&nbsp;ns__Shape</i> with name Triangle, 3 sides, and color Green is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Shape xsi:type="ns:Shape"&#62; <br />
&lt;name xsi:type="string"&#62;Triangle&lt;/name&#62; <br />
&lt;sides xsi:type="int"&#62;3&lt;/sides&#62; <br />
&lt;color xsi:type="ns:Color"&#62;Green&lt;/color&#62; <br />
&lt;/ns:shape&#62;
</td></tr></table><br></tt>
The namespace URI of the namespace prefix <tt>ns</tt> must be defined by a namespace mapping table, see Section&nbsp;<a href="#sec:nstable">8.4</a>.

<p>
		      <h4><a name="tth_sEc9.5.2">
9.5.2</a>&nbsp;&nbsp;<font color="#0000FF">Initialized <b>static</b>&nbsp;<b>const</b>&nbsp;Fields</font></h4>

<p>
A data member field of a class declared as <i><b>static</b>&nbsp;<b>const</b></i> is initialized
with a constant value at compile time. This field is encoded in the
serialization process, but is not decoded in the deserialization process. For
example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "triangle.h": <br />
<b>class</b>&nbsp;ns__Triangle : <b>public</b>&nbsp;ns__Object <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;size; <br />
&nbsp;&nbsp;&nbsp;<b>static</b>&nbsp;<b>const</b>&nbsp;<b>int</b>&nbsp;sides = 3; <br />
};
</td></tr></table><br></i>
An instance of <i><b>class</b>&nbsp;ns__Triangle</i> is encoded in SOAP as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Triangle xsi:type="ns:Triangle"&#62; <br />
&lt;name xsi:type="string"&#62;Triangle&lt;/name&#62; <br />
&lt;size xsi:type="int"&#62;15&lt;/size&#62; <br />
&lt;sides xsi:type="int"&#62;3&#62;/sides&#62; <br />
&lt;/ns:Triangle&#62;
</td></tr></table><br></tt>
Decoding will ignore the <i>sides</i> field's value.

<p>
<font color="#FF0000"><b>Caution</b></font>: The current gSOAP implementation does not support encoding
<i><b>static</b>&nbsp;<b>const</b></i> fields, due to C++ compiler compatibility differences.
This feature may be provided the future.

<p>
		      <h4><a name="tth_sEc9.5.3">
9.5.3</a>&nbsp;&nbsp;<font color="#0000FF">Class Methods</font></h4>

<p>
A <i><b>class</b></i> declaration in the header file input to the gSOAP compiler MAY
include method declarations.  The method implementations MUST NOT be part of
the header file but are required to be defined in another C++ source that is
externally linked with the application. This convention is also used for the
constructors and destructors of the <i><b>class</b></i>.

<p>
Dynamic binding is supported, so a method MAY be declared <i><b>virtual</b></i>.

<p>
		      <h4><a name="tth_sEc9.5.4">
9.5.4</a>&nbsp;&nbsp;<font color="#0000FF">Polymorphism, Derived Classes, and Dynamic Binding</font></h4>

<p>
Interoperability between client and service applications developed with gSOAP
is established even when clients and/or services use derived classes instead of
the base classes used in the declaration of the remote method parameters.  A
client application MAY use pointers to instances of derived classes for the
input parameters of a remote method. If the service was compiled with a
declaration and implementation of the derived class, the remote method base
class input parameters are demarshalled and a derived class instance is created
instead of a base class instance. If the service did not include a declaration
of the derived class, the derived class fields are ignored and a base class
instance is created. Therefore, interoperability is guaranteed even when the
client sends an instance of a derived classes and when a service returns an
instance of a derived class.

<p>
The following example declares Base and Derived classes and a remote method
that takes a pointer to a Base class instance and returns a Base class
instance:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "derived.h" <br />
<b>class</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;Base(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>class</b>&nbsp;Derived : <b>public</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;num; <br />
&nbsp;&nbsp;&nbsp;Derived(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;method(Base *in, <b>struct</b>&nbsp;methodResponse { Base *out; } &amp;result);
</td></tr></table><br></i>
This header file specification is processed by the gSOAP compiler to produce the stub and skeleton routines which are used to implement a client and service.
The pointer of the remote method is also allowed to point to Derived class instances and these instances will be marshalled as Derived class instances and send to a service, which is in accord to the usual semantics of parameter passing in C++ with dynamic binding.

<p>
The Base and Derived class method implementations are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Method implementations of the Base and Derived classes: <br />
#include "soapH.h" <br />
... <br />
Base::Base() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Base class instance"  &lt;&lt;  endl; <br />
} <br />
Derived::Derived() <br />
{<br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Derived class instance"  &lt;&lt;  endl; <br />
} <br />
Base::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Base class instance "  &lt;&lt;  name  &lt;&lt;  endl; <br />
} <br />
Derived::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Derived class instance "  &lt;&lt;  name  &lt;&lt;  " "  &lt;&lt;  num  &lt;&lt;  endl; <br />
}
</td></tr></table><br></i>
Below is an example <i>CLIENT</i> application that creates a Derived class instance that is passed as the input parameter of the remote method:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// CLIENT <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;Derived obj1; <br />
&nbsp;&nbsp;&nbsp;Base *obj2; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;methodResponse r; <br />
&nbsp;&nbsp;&nbsp;obj1.name = "X"; <br />
&nbsp;&nbsp;&nbsp;obj1.num = 3; <br />
&nbsp;&nbsp;&nbsp;soap_call_method(&amp;soap, url, action, &amp;obj1, r); <br />
&nbsp;&nbsp;&nbsp;r.obj2<tt>-&gt;</tt>print(); <br />
} <br />
...
</td></tr></table><br></i>
The following example <i>SERVER1</i> application copies a class instance (Base or Derived class) from the input to the output parameter:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// SERVER1 <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, Base *obj1, <b>struct</b>&nbsp;methodResponse &amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;obj1<tt>-&gt;</tt>print(); <br />
&nbsp;&nbsp;&nbsp;result.obj2 = obj1; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
...
</td></tr></table><br></i>
The following messages are produced by the <i>CLIENT</i> and <i>SERVER1</i> applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
CLIENT: created a Derived class instance <br />
SERVER1: created a Derived class instance <br />
SERVER1: print(): Derived class instance X 3 <br />
CLIENT: created a Derived class instance <br />
CLIENT: print(): Derived class instance X 3
</td></tr></table><br></span>
Which indicates that the derived class kept its identity when it passed through <i>SERVER1</i>. Note that instances are created both by the <i>CLIENT</i> and <i>SERVER1</i> by the demarshalling process.

<p>
Now suppose a service application is developed that only accepts Base class instances. The header file is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "base.h": <br />
<b>class</b>&nbsp;Base <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;Base(); <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;method(Base *in, Base *out);
</td></tr></table><br></i>
This header file specification is processed by the gSOAP stub and skeleton compiler to produce skeleton routine which is used to implement a service (so the client will still use the derived classes).

<p>
The method implementation of the Base class are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Method implementations of the Base class: <br />
#include "soapH.h" <br />
... <br />
Base::Base() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "created a Base class instance"  &lt;&lt;  endl; <br />
} <br />
Base::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  "print(): Base class instance "  &lt;&lt;  name  &lt;&lt;  endl; <br />
} <br />
</td></tr></table><br></i>
And the <i>SERVER2</i> application is that uses the Base class is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// SERVER2 <br />
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_serve(soap_new()); <br />
} <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, Base *obj1, <b>struct</b>&nbsp;methodResponse &amp;result) <br />
{ <br />
&nbsp;&nbsp;&nbsp;obj1<tt>-&gt;</tt>print(); <br />
&nbsp;&nbsp;&nbsp;result.obj2 = obj1; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
...
</td></tr></table><br></i>
Here are the messages produced by the <i>CLIENT</i> and <i>SERVER2</i> applications:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
CLIENT: created a Derived class instance <br />
SERVER2: created a Base class instance <br />
SERVER2: print(): Base class instance X <br />
CLIENT: created a Base class instance <br />
CLIENT: print(): Base class instance X
</td></tr></table><br></span>
In this example, the object was passed as a Derived class instance to <i>SERVER2</i>. Since <i>SERVER2</i> only implements the Base class, this object is converted to a Base class instance and send back to <i>CLIENT</i>.

<p>
	      <h4><a name="tth_sEc9.5.5">
9.5.5</a>&nbsp;&nbsp;<font color="#0000FF">Struct/Class Encoding With XML Attributes</font></h4><a name="sec:attributes">
</a>

<p>
The SOAP RPC/LIT and SOAP DOC/LIT encoding styles support XML attributes in
SOAP messages while SOAP RPC with ``Section 5'' encoding does not support XML
attributes other than the SOAP and XSD specific attributes. SOAP RPC ``Section
5'' encoding has advantages for cross-language interoperability and data
encodings such as graph serialization. However, RPC/LIT and DOC/LIT enables
direct exchange of XML documents, which may include encoded application data
structures. Language interoperability is compromized, because no mapping
between XML and the typical language data types is defined. The meaning of the
RPC/LIT and DOC/LIT XML content is Schema driven rather than
application/language driven.

<p>
gSOAP supports XML attribute (de)serialization for structs and classes.
Attributes are primitive XSD types, such as strings, enumerations, boolean, and
numeric types. To declare an XML attribute in a struct/class, the qualifier
<i>@</i> is used with the type of the attribute. The type must be
primitive type (including enumerations and strings), which can be declared with or without
a <i><b>typedef</b></i> to associate a XSD type with the C/C+ type.  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>typedef</b>&nbsp;<b>bool</b>&nbsp;*xsd__boolean; <br />
<b>enum</b>&nbsp;ns__state { _0, _1, _2 }; <br />
<b>struct</b>&nbsp;ns__myStruct <br />
{ <br />
&nbsp;&nbsp;&nbsp;@xsd__string ns__type; // encode as XML attribute 'ns:type' of type 'xsd:string' <br />
&nbsp;&nbsp;&nbsp;@xsd__boolean ns__flag = false; // encode as XML attribute 'ns:flag' of type 'xsd:boolean' <br />
&nbsp;&nbsp;&nbsp;@<b>enum</b>&nbsp;ns__state ns__state = _2; // encode as XML attribute 'ns:state' of type 'ns:state' <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__myStruct *next; <br />
};
</td></tr></table><br></i>
The <i>@</i> qualifier indicates XML attribute encoding for the
<i>ns__type</i>, <i>ns__flag</i>, and <i>ns__state</i> fields. Note that the
namespace prefix <i>ns</i> is used to distinghuish these attributes from any
other attributes such as <tt>xsi:type</tt> (<tt>ns:type</tt> is not to be confused
with <tt>xsi:type</tt>).

<p>
Default values can be associated with any field that has
a primitive type in a struct/class, as is illustrated in this example. The
default values are used when the receiving message does not contain the
corresponding values.

<p>
The XSD type QName plays a special role in gSOAP to ensure the decoding of the
appropriate namespace information from the XML message inbound. An attribute
with type QName (Qualified Name) contains an optional prefix and a local name.
When declaring a QName XSD type as a string with a <i>typedef</i>, the QName
values are serialized as strings and the user is responsable to ensure proper
formatting of the string as a QName.  For deserialization however, the QName
string is changed by replacing the namespace prefix with the namespace prefix
defined in the namespace mapping table. If the namespace mapping table has not
entry for the namespace name (URI), then the entire URI replaces the namespace
prefix in the QName to ensure that this information is not lost.
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__QName; <br />
<b>struct</b>&nbsp;ns__myStruct <br />
{ <br />
&nbsp;&nbsp;&nbsp;@xsd__QName ns__name = "ns:abc"; <br />
};
</td></tr></table><br></i>
When the field <i>ns__name</i> is serialized, the string contents are just
send.  Suppose that the inbound value for the <i>ns__name</i> is <tt>x:def</tt>,
where the namespace name associated with the prefix <tt>x</tt> matches the
namespace name of the prefix <tt>ns</tt> (as defined in the namespace mapping
table). Then, the value is converted into <tt>ns:def</tt> to ensure proper
mapping. If the namespace name is not in the table, then <tt>x:def</tt> is
converted to <i>&#220;RI":def</i> where <tt>&#220;RI"</tt> is the namespace URI bound to
<tt>x</tt> in the message received.

<p>
Because a remote method request and response is essentially a struct, XML
attributes can also be associated with method requests and responses. For
example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>int</b>&nbsp;ns__myMethod(@xsd__string ns__name, ...);
</td></tr></table><br></i>
Attributes can also be attached to the dynamic arrays, binary types, and wrapper classes/structs of primitive
types. Wrapper classes are described in Section&nbsp;<a href="#sec:primclass">9.2.2</a>.  For
example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__string <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*__item; <br />
&nbsp;&nbsp;&nbsp;@xsd__boolean flag; <br />
};
</td></tr></table><br></i>
and
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;@xsd__boolean flag; <br />
};
</td></tr></table><br></i>
The attribute declarations MUST follow the <i>__item</i>, <i>__ptr</i>, and <i>__size</i> fields
which define the characteristics of wrapper structs/classes and dynamic arrays.

<p>
<font color="#FF0000"><b>Caution</b></font>: Do not use XML attributes with SOAP RPC encoding, unless RPC/LIT is required.

<p>
	     <h3><a name="tth_sEc9.6">
9.6</a>&nbsp;&nbsp;<font color="#0000FF">Pointer Encoding and Decoding</font></h3><a name="sec:pointer">
</a>

<p>
The serialization of a pointer to a data type amounts to the serialization of
the data type in SOAP and the SOAP encoded representation of a pointer to the
data type is indistinghuishable from the encoded representation of the data
type pointed to.

<p>
		      <h4><a name="tth_sEc9.6.1">
9.6.1</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Reference Data</font></h4>

<p>
A data structure pointed to by more than one pointer is serialized as SOAP
multi-reference data. This means that the data will be serialized only once and
identified with a unique <tt>id</tt> attribute. The encoding of the pointers to
the shared data is done through the use of <tt>href</tt> attributes to refer to
the multi-reference data (also see Section&nbsp;<a href="#sec:flags">7.10</a> on options to
control the serialization of multi-reference data).  Cyclic C/C++ data
structures are encoded with multi-reference SOAP encoding.  Consider for
example the following a linked list data structure:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*xsd__string; <br />
<b>struct</b>&nbsp;ns__list<br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__string value; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__list *next; <br />
};
</td></tr></table><br></i>
Suppose a cyclic linked list is created. The first node contains the value "<tt>abc</tt>" and points to a node with value
"<tt>def</tt>" which in turn points to the first node. This is encoded as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:list id="1" xsi:type="ns:list"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;value xsi:type="xsd:string"&#62;abc&lt;/value&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;next xsi:type="ns:list"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value xsi:type="xsd:string"&#62;def&lt;/value&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;next href="#1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/next&#62; <br />
&lt;/ns:list&#62;
</td></tr></table><br></tt>
In case multi-referenced data is received that ``does not fit in a pointer-based structure'', the data is copied.
For example, the following two <i><b>struct</b></i>s are similar, except that the first uses pointer-based fields while the other uses
non-pointer-based fields:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>long</b>&nbsp;xsd__int; <br />
<b>struct</b>&nbsp;ns__record <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__int *a; <br />
&nbsp;&nbsp;&nbsp;xsd__int *b; <br />
} P; <br />
<b>struct</b>&nbsp;ns__record<br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__int a; <br />
&nbsp;&nbsp;&nbsp;xsd__int b; <br />
} R; <br />
... <br />
&nbsp;&nbsp;&nbsp;P.a = &amp;n; <br />
&nbsp;&nbsp;&nbsp;P.b = &amp;n; <br />
...
</td></tr></table><br></i>
Since both <i>a</i> and <i>b</i> fields of <i>P</i> point to the same integer, the encoding of <i>P</i> is multi-reference:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:record xsi:type="ns:record"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;a href="#1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;b href="#1"/&#62; <br />
&lt;/ns:record&#62; <br />
&lt;id id="1" xsi:type="xsd:int"&#62;123&lt;/id&#62;
</td></tr></table><br></tt>
Now, the decoding of the content in the <i>R</i> data structure that does not use pointers to integers results in a copy of each
multi-reference integer.  Note that the two <i><b>struct</b></i>s resemble the same XML data type because the trailing underscore will be
ignored in XML encoding and decoding.

<p>
		      <h4><a name="tth_sEc9.6.2">
9.6.2</a>&nbsp;&nbsp;<font color="#0000FF">NULL Pointers and Nil Elements</font></h4>

<p>
A <i>NULL</i> pointer is <b>not</b> serialized, unless the pointer itself is pointed to by another pointer (but see
Section&nbsp;<a href="#sec:flags">7.10</a> to control the serialization of NULLs).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;X <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*p; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;**q; <br />
}
</td></tr></table><br></i>
Suppose pointer <i>q</i> points to pointer <i>p</i> and suppose <i>p=NULL</i>.
In that case the <i>p</i> pointer is serialized as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;... id="123" xsi:nil="true"/&#62;
</td></tr></table><br></tt>
and the serialization of <i>q</i> refers to <tt>href="#123"</tt>.
Note that SOAP 1.1 does not support
pointer to pointer types (!), so this encoding is specific to gSOAP. The pointer to pointer encoding is rarely used in codes
anyway.  More common is a pointer to a data type such as a <i><b>struct</b></i> with pointer fields.

<p>
<font color="#FF0000"><b>Caution</b></font>: When the deserializer encounters an XML element that has a <tt>xsi:nil="true"</tt> attribute but the corresponding C++ data is not a pointer or reference,
the deserializer will terminate with a <i>SOAP_NULL</i> fault when the <i>SOAP_XML_NIL</i> flag is set.
The types section of a WSDL description contains information on the ``nilability'' of data.

<p>
	     <h3><a name="tth_sEc9.7">
9.7</a>&nbsp;&nbsp;<font color="#0000FF">Fixed-Size Arrays</font></h3>

<p>
Fixed size arrays are encoded as per SOAP 1.1 one-dimensional array types.  Multi-dimensional fixed size arrays are encoded by
gSOAP as nested one-dimensional arrays in SOAP.
Encoding of fixed size arrays supports partially transmitted and sparse array SOAP formats.

<p>
The decoding of (multi-dimensional) fixed-size arrays supports the SOAP multi-dimensional array format as well as partially transmitted and sparse array formats.

<p>
An example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of header file "fixed.h": <br />
<b>struct</b>&nbsp;Example <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&nbsp;a[2][3]; <br />
};
</td></tr></table><br></i>
This specifies a fixed-size array part of the <i><b>struct</b>&nbsp;Example</i>. The encoding of array <i>a</i> is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;a xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[][2]"&#62; <br />
&lt;SOAP-ENC:Array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[3]" <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;/SOAP-ENC:Array&#62; <br />
&lt;SOAP-ENC:Array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="float[3]" <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;float xsi:type="float"&#62;...&lt;/float&#62; <br />
&lt;/SOAP-ENC:Array&#62; <br />
&lt;/a&#62;
</td></tr></table><br></tt>
<font color="#FF0000"><b>Caution</b></font>: Any decoded parts of a (multi-dimensional) array that do not ``fit'' in the fixed size array are ignored by the deserializer.

<p>
	     <h3><a name="tth_sEc9.8">
9.8</a>&nbsp;&nbsp;<font color="#0000FF">Dynamic Arrays</font></h3><a name="sec:dynarray">
</a>

<p>
As the name suggests, dynamic arrays are much more flexible than fixed-size arrays and dynamic arrays are better adaptabe to the
SOAP encoding and decoding rules for arrays.  In addition, a typical C application allocates a dynamic array using <i>malloc</i>,
assigns the location to a pointer variable, and deallocates the array later with <i>free</i>.  A typical C++ application allocates
a dynamic array using <i>new</i>, assigns the location to a pointer variable, and deallocates the array later with <i>delete</i>.
Such dynamic allocations are flexible, but pose a problem for the serialization of data: how does the array serializer know the
length of the array to be serialized given only a pointer to the sequence of elements?  The application stores the size
information somewhere. This information is crucial for the array serializer and has to be made explicitly known to the array
serializer by packaging the pointer and array size information within a <i><b>struct</b></i> or <i><b>class</b></i>.

<p>
		      <h4><a name="tth_sEc9.8.1">
9.8.1</a>&nbsp;&nbsp;<font color="#0000FF">One-Dimensional Dynamic Arrays</font></h4>

<p>
A special form of <i><b>struct</b></i> or <i><b>class</b></i> is used for one-dimensional dynamic arrays
that contains a pointer variable and a field that records the number of elements the pointer points to in memory.

<p>
The general form of the <i><b>struct</b></i> declaration for one-dimensional dynamic arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">[</span></font><b>static</b>&nbsp;<b>const</b><font size="+1"><span class="roman">]</span></font> <b>int</b>&nbsp;__offset <font size="+1"><span class="roman">[</span></font>= ...<font size="+1"><span class="roman">]</span></font>;<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;... // anything that follows here will be ignored <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">Type</span></u></i> MUST be a type associated with an XML schema or MUST be a primitive type.
If these conditions are not met, a list/vector (de)serialization is used (see Section&nbsp;<a href="#sec:list">9.8.6</a>).
A primitive type can be used with or without a <i><b>typedef</b></i>.
If the array elements are structs or classes, then the <i>struct</i>/<i>class</i> type names should have a namespace prefix for schema
association, or they should be other (nested) dynamic arrays. 

<p>
An alternative to a <i><b>struct</b></i> is to use a <i><b>class</b></i> with optional methods that MUST appear after the <i>__ptr</i> and
<i>__size</i> fields:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<font size="+1"><span class="roman">[</span></font><font size="+1"><span class="roman">[</span></font><b>static</b>&nbsp;<b>const</b><font size="+1"><span class="roman">]</span></font> <b>int</b>&nbsp;__offset <font size="+1"><span class="roman">[</span></font>= ...<font size="+1"><span class="roman">]</span></font>;<font size="+1"><span class="roman">]</span></font> <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... // any fields that follow will be ignored <br />
};
</td></tr></table><br></i>
To encode the data type as an array, the name of the <i><b>struct</b></i> or <i><b>class</b></i> SHOULD NOT have a namespace prefix, otherwise
the data type will be encoded and decoded as a SOAP list/vector, see Section&nbsp;<a href="#sec:list">9.8.6</a>.

<p>
The deserializer of a dynamic array can decode partially transmitted and/or SOAP sparse arrays, and even multi-dimensional arrays
which will be collapsed into a one-dimensional array with row-major ordering.

<p>
<font color="#FF0000"><b>Caution</b></font>: SOAP 1.2 does not support partially transmitted arrays. So the <i>__offset</i> field of a dynamic array is ignored.

<p>
		      <h4><a name="tth_sEc9.8.2">
9.8.2</a>&nbsp;&nbsp;<font color="#0000FF">Example</font></h4>

<p>
The following example header file specifies the XMethods Service Listing service <i>getAllSOAPServices</i> remote method and an array of <i>SOAPService</i> data structures:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "listing.h": <br />
<b>class</b>&nbsp;ns3__SOAPService <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;ID; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*owner; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*description; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*homepageURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*endpoint; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAPAction; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodNamespaceURI; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serviceStatus; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*methodName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*dateCreated; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*downloadURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*wsdlURL; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*instructions; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*contactEmail; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*serverImplementation; <br />
}; <br />
<b>class</b>&nbsp;ServiceArray <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;ns3__SOAPService *__ptr; // points to array elements <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;ServiceArray(); <br />
&nbsp;&nbsp;&nbsp;~ServiceArray(); <br />
&nbsp;&nbsp;&nbsp;<b>void</b>&nbsp;print(); <br />
}; <br />
<b>int</b>&nbsp;ns__getAllSOAPServices(ServiceArray &amp;return_);
</td></tr></table><br></i>
An example client application:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h"
... <br />
// ServiceArray class method implementations: <br />
ServiceArray::ServiceArray() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
ServiceArray::~ServiceArray() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(__ptr) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(__ptr); <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
<b>void</b>&nbsp;ServiceArray::print() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 0; i &lt; __size; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  __ptr[i].name  &lt;&lt;  ": "  &lt;&lt;  __ptr[i].homepage  &lt;&lt;  endl; <br />
} <br />
... <br />
// Request a service listing and display results: <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;ServiceArray result; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint = "www.xmethods.net:80/soap/servlet/rpcrouter"; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*action = "urn:xmethodsServicesManager#getAllSOAPServices"; <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__getAllSOAPServices(&amp;soap, endpoint, action, result); <br />
&nbsp;&nbsp;&nbsp;result.print(); <br />
&nbsp;&nbsp;&nbsp;... <br />
}
</td></tr></table><br></i>

<p>
		      <h4><a name="tth_sEc9.8.3">
9.8.3</a>&nbsp;&nbsp;<font color="#0000FF">One-Dimensional Dynamic Arrays With Non-Zero Offset</font></h4>

<p>
The declaration of a dynamic array as described in&nbsp;<a href="#sec:dynarray">9.8</a> MAY include an <i><b>int</b>&nbsp;__offset</i> field. When set to an
integer value, the serializer of the dynamic array will use this field as the start index of the array and the SOAP array offset
attribute will be used in the SOAP payload.

<p>
For example, the following header file declares a mathematical <i>Vector</i> class, which is a dynamic array of floating point values with an index that starts at 1:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "vector.h": <br />
<b>typedef</b>&nbsp;<b>float</b>&nbsp;xsd__float; <br />
<b>class</b>&nbsp;Vector <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__float *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
&nbsp;&nbsp;&nbsp;Vector(); <br />
&nbsp;&nbsp;&nbsp;Vector(<b>int</b>&nbsp;n); <br />
&nbsp;&nbsp;&nbsp;<b>float</b>&amp; <b>operator</b>[](<b>int</b>&nbsp;i); <br />
}
</td></tr></table><br></i>
The implementations of the <i>Vector</i> methods are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
Vector::Vector() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
&nbsp;&nbsp;&nbsp;__offset = 1; <br />
} <br />
Vector::Vector(<b>int</b>&nbsp;n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = (<b>float</b>*)malloc(n*<b>sizeof</b>(<b>float</b>)); <br />
&nbsp;&nbsp;&nbsp;__size = n; <br />
&nbsp;&nbsp;&nbsp;__offset = 1; <br />
} <br />
Vector::~Vector() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(__ptr) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(__ptr); <br />
} <br />
<b>float</b>&amp; Vector::<b>operator</b>[](<b>int</b>&nbsp;i) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__ptr[i-__offset]; <br />
}
</td></tr></table><br></i>
An example program fragment that serializes a vector of 3 elements:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
Vector v(3); <br />
v[1] = 1.0; <br />
v[2] = 2.0; <br />
v[3] = 3.0; <br />
soap_begin(&amp;soap); <br />
v.serialize(&amp;soap); <br />
v.put(<tt>"vec"</tt>); <br />
soap_end(&amp;soap);
</td></tr></table><br></i>
The output is a partially transmitted array:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;vec xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="xsd:float[4]" SOAP-ENC:offset="[1]"&#62; <br />
&lt;item xsi:type="xsd:float"&#62;1.0&lt;/item&#62; <br />
&lt;item xsi:type="xsd:float"&#62;2.0&lt;/item&#62; <br />
&lt;item xsi:type="xsd:float"&#62;3.0&lt;/item&#62; <br />
&lt;/vec&#62;
</td></tr></table><br></tt>
Note that the size of the encoded array is necessarily set to 4 and that the encoding omits the non-existent element at index 0.

<p>
The decoding of a dynamic array with an <i>__offset</i> field is more efficient than decoding a dynamic array without an <i>__offset</i> field, because the <i>__offset</i> field will be assigned the value of the <tt>SOAP-ENC:offset</tt> attribute instead of padding the initial part of the array with default values.

<p>
		      <h4><a name="tth_sEc9.8.4">
9.8.4</a>&nbsp;&nbsp;<font color="#0000FF">Nested One-Dimensional Dynamic Arrays</font></h4><a name="sec:nested">
</a>

<p>
One-dimensional dynamic arrays MAY be nested.
For example, using <i><b>class</b>&nbsp;Vector</i> declared in the previous section, <i><b>class</b>&nbsp;Matrix</i> is declared:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
// Contents of file "matrix.h": <br />
<b>class</b>&nbsp;Matrix <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;Vector *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
&nbsp;&nbsp;&nbsp;Matrix(); <br />
&nbsp;&nbsp;&nbsp;Matrix(<b>int</b>&nbsp;n, <b>int</b>&nbsp;m); <br />
&nbsp;&nbsp;&nbsp;~Matrix(); <br />
&nbsp;&nbsp;&nbsp;Vector&amp; <b>operator</b>[](<b>int</b>&nbsp;i); <br />
}; 
</td></tr></table><br></i>
The Matrix type is essentially an array of pointers to arrays which make up the rows of a matrix.
The encoding of the two-dimensional dynamic array in SOAP will be in nested form.

<p>
		      <h4><a name="tth_sEc9.8.5">
9.8.5</a>&nbsp;&nbsp;<font color="#0000FF">Multi-Dimensional Dynamic Arrays</font></h4>

<p>
The general form of the <i><b>struct</b></i> declaration for K-dimensional (K&#62;1) dynamic arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[K]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[K]; <br />
&nbsp;&nbsp;&nbsp;... // anything that follows here will be ignored <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">Type</span></u></i> MUST be a type associated with an XML schema, which means that it must be a <i><b>typedef</b></i>ed type
in case of a primitive type, or a <i><b>struct</b></i>/<i><b>class</b></i> name with a namespace prefix for schema association, or another dynamic array. If these conditions are not met, a list/vector (de)serialization is used (see Section&nbsp;<a href="#sec:list">9.8.6</a>).

<p>
An alternative is to use a <i><b>class</b></i> with optional methods:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;some_name <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type</span></u> *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[K]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[K]; <br />
&nbsp;&nbsp;&nbsp;method1; <br />
&nbsp;&nbsp;&nbsp;method2; <br />
&nbsp;&nbsp;&nbsp;... // any fields that follow will be ignored <br />
};
</td></tr></table><br></i>
In the above, K is a constant denoting the number of dimensions of the multi-dimensional array.

<p>
To encode the data type as an array, the name of the <i><b>struct</b></i> or <i><b>class</b></i> SHOULD NOT have a namespace prefix, otherwise
the data type will be encoded and decoded as a SOAP list/vector, see Section&nbsp;<a href="#sec:list">9.8.6</a>.

<p>
The deserializer of a dynamic array can decode partially transmitted multi-dimensional arrays.

<p>
For example, the following declaration specifies a matrix class:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>double</b>&nbsp;xsd__double; <br />
<b>class</b>&nbsp;Matrix <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;xsd__double *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size[2]; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset[2]; <br />
}; 
</td></tr></table><br></i>
In contrast to the matrix class of Section&nbsp;<a href="#sec:nested">9.8.4</a> that defined a matrix as an array of pointers to matrix rows, this
class has one pointer to a matrix stored in row-major order.  The size of the matrix is determined by the <i>__size</i> field:
<i>__size[0]</i> holds the number of rows and <i>__size[1]</i> holds the number of columns of the matrix.  Likewise, <i>__
offset[0]</i> is the row offset and <i>__offset[1]</i> is the columns offset.

<p>
		      <h4><a name="tth_sEc9.8.6">
9.8.6</a>&nbsp;&nbsp;<font color="#0000FF">Dynamic Array as List Encoding</font></h4><a name="sec:list">
</a>

<p>
In case the name of the <i><b>struct</b></i> or <i><b>class</b></i> of a dynamic array has a namespace prefix, the data type is considered a
list (a.k.a.&nbsp;vector) and will be serialized as a SOAP list and not encoded as a SOAP array.

<p>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Map <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__Binding {<b>char</b>&nbsp;*key; <b>char</b>&nbsp;*val;} *__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
This declares a dynamic array, but the array will be serialized and deserialized as a list. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;ns:Map xsi:type="ns:Map"&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Joe&lt;/key&#62; <br />
&lt;val&#62;555 77 1234&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Susan&lt;/key&#62; <br />
&lt;val&#62;555 12 6725&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;ns:Binding xsi:type="ns:Binding"&#62; <br />
&lt;key&#62;Pete&lt;/key&#62; <br />
&lt;val&#62;555 99 4321&lt;/val&#62; <br />
&lt;/ns:Binding&#62; <br />
&lt;/ns:Map&#62;
</td></tr></table><br></tt>
Deserialization is less efficient compared to an array, because the size of the list is not part of the SOAP encoding. Internal buffering is used by the deserializer to collect the elements. When the end of the list is reached, the buffered elements are copied to a newly allocated space on the heap for the dynamic array.

<p>
A list (de)serialization is also in affect for dynamic arrays when the pointer field does not refer to a type that is associated
with a schema. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;vector <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Since <i><b>int</b></i> has no association with a schema, a <i>vector</i> structure <i>X</i> is serialized as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;X&#62; <br />
&lt;item&#62;1&lt;/item&#62; <br />
&lt;item&#62;-2&lt;/item&#62; <br />
... <br />
&lt;/X&#62;
</td></tr></table><br></tt>

<p>
		      <h4><a name="tth_sEc9.8.7">
9.8.7</a>&nbsp;&nbsp;<font color="#0000FF">Polymorphic Dynamic Arrays and Lists</font></h4>

<p>
An array of pointers to class instances allows the encoding of polymorphic arrays (arrays of polymorphic element types)
and lists.  For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;ns__Object <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
<b>class</b>&nbsp;ns__Data: <b>public</b>&nbsp;ns__Object <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;... <br />
}; <br />
<b>class</b>&nbsp;ArrayOfObject <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;ns__Object **__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__offset; <br />
}; 
</td></tr></table><br></i>
The pointers in the array can point to the <i>ns__Object</i> base class or <i>ns__Data</i> derived class instances which will be
serialized and deserialized accordingly in SOAP.  That is, the array elements are polymorphic.

<p>
		      <h4><a name="tth_sEc9.8.8">
9.8.8</a>&nbsp;&nbsp;<font color="#0000FF">How to Change the Tag Names of the Elements of a SOAP Array or List</font></h4>

<p>
The <i>__ptr</i> field in a <i><b>struct</b></i> or <i><b>class</b></i> declaration of a dynamic array may have an optional suffix part that
describes the name of the tags of the SOAP array XML elements.
The suffix is part of the field name:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">Type</span></u> *__ptr<u><span class="roman">array_elt_name</span></u>
</td></tr></table><br></i>
The suffix describes the tag name to be used for all array elements. The usual identifier to XML translations apply, see
Section&nbsp;<a href="#sec:idtrans">8.3</a>.
The default XML element tag name for array elements is <tt>item</tt> (which corresponds to the use of field name <i>__ptritem</i>).

<p>
Consider for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ArrayOfstring <br />
{ <br />
&nbsp;&nbsp;&nbsp;xsd__string *__ptrstring;
&nbsp;&nbsp;&nbsp;int __size;
};
</td></tr></table><br></i>
The array is serialized as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;array xsi:type="SOAP-ENC:Array" SOAP-ENC:arrayType="xsd:string[2]&#187; <br />
&lt;string xsi:type="xsd:string&#187;Hello&lt;/string&#62; <br />
&lt;string xsi:type="xsd:string&#187;World&lt;/string&#62; <br />
&lt;/array&#62;
</td></tr></table><br></tt>
SOAP 1.1 and 1.2 do not require the use of a specific tag name for array elements.  gSOAP will deserialize a SOAP array while
ignoring the tag names. Certain XML schemas used in doc/literal encoding may require the declaration of arrray element tag names.

<p>
		      <h4><a name="tth_sEc9.8.9">
9.8.9</a>&nbsp;&nbsp;<font color="#0000FF">Embedded Arrays and Lists</font></h4>

<p>
An array (or list) can be embedded in a struct/class without the need to declare a separate array data type.
When a struct or class type declaration contains a <i><b>int</b>&nbsp;__size</i> field and the next field below is a pointer type,
gSOAP assumes the pointer type points to an array of values where the <i>__size</i> field holds the number of values at run time.
Multiple arrays can be embedded in a struct/class by using <i>__size</i> field names that end with a unique name suffix.

<p>
The general convention for embedding arrays is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__SomeStruct <br />
{ <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size<u><span class="roman">name1</span></u>; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type1</span></u> *<u>field1</u>; // by this field <br />
&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size<u><span class="roman">name2</span></u>; // number of elements pointed to <br />
&nbsp;&nbsp;&nbsp;<u><span class="roman">Type2</span></u> *<u>field2</u>; // by this field <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
where <i><u><span class="roman">name1</span></u></i> and <i><u><span class="roman">name2</span></u></i> are identifiers used as a suffix to distinghuish the <i>__
size</i> field. These names can be arbitrary and are not visible in XML.

<p>
For example, the following struct has two embedded arrays:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__Contact <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*firstName; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*lastName; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__sizePhones; <br />
&nbsp;&nbsp;&nbsp;ULONG64 *phoneNumber; // array of phone numbers <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__sizeEmails; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;**emailAddress; // array of email addresses <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*socSecNumber; <br />
};
</td></tr></table><br></i>
The XML serialization of an example <i>ns__Contact</i> is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;mycontact xsi:type="ns:Contact"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;firstName&#62;Joe&lt;/firstName&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;lastName&#62;Smith&lt;/lastName&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5551112222&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5551234567&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;phoneNumber&#62;5552348901&lt;/phoneNumber&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;emailAddress&#62;Joe.Smith@mail.com&lt;/emailAddress&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;emailAddress&#62;Joe@Smith.com&lt;/emailAddress&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;socSecNumber&#62;999999999&lt;/socSecNumber&#62; <br />
&lt;/mycontact&#62;
</td></tr></table><br></tt>

<p>
	     <h3><a name="tth_sEc9.9">
9.9</a>&nbsp;&nbsp;<font color="#0000FF">Base64Binary XML Schema Type Encoding</font></h3><a name="sec:base64binary">
</a>

<p>
The <tt>base64Binary</tt> XML schema type is a special form of dynamic array declared with a pointer (<i>__ptr</i>) to an
<i><b>unsigned</b>&nbsp;<b>char</b></i> array.

<p>
For example using a <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or with a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>base64Binary</tt> serializers and deserializers.

<p>
The <tt>SOAP_ENC:base64</tt> encoding is another type for base 64 binary encoding
specified by the SOAP data type schema and some SOAP applications may use this form
(as indicated by their WSDL descriptions). It is declared by:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENC__base64 <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or with a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;SOAP_ENC__base64 <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>SOAP-ENC:base64</tt> serializers and deserializers.

<p>
The advantage of using a <i><b>class</b></i> is that methods can be used to initialize and manipulate the <i>__ptr</i> and <i>__size</i> fields. The user can add methods to this class to do this. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;xsd__base64Binary(); // Constructor <br />
&nbsp;&nbsp;&nbsp;xsd__base64Binary(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;n); // Constructor <br />
&nbsp;&nbsp;&nbsp;~xsd__base64Binary(); // Destructor <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*location(); // returns the memory location <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;size(); // returns the number of bytes <br />
};
</td></tr></table><br></i>
Here are example method implementations:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
xsd__base64Binary::xsd__base64Binary() <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = NULL; <br />
&nbsp;&nbsp;&nbsp;__size = 0; <br />
} <br />
xsd__base64Binary::xsd__base64Binary(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;__ptr = (<b>unsigned</b>&nbsp;<b>int</b>*)soap_malloc(soap, n); <br />
&nbsp;&nbsp;&nbsp;__size = n; <br />
} <br />
xsd__base64Binary::~xsd__base64Binary() <br />
{ } <br />
<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*xsd__base64Binary::location() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__ptr; <br />
} <br />
<b>int</b>&nbsp;xsd__base64Binary::size() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;__size; <br />
}
</td></tr></table><br></i>
The following example in C/C++ reads from a raw image file and encodes the image in SOAP using the <tt>base64Binary</tt> type:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
FILE *fd = fopen(<tt>"image.jpg"</tt>, <tt>"r"</tt>); <br />
xsd__base64Binary image(filesize(fd)); <br />
fread(image.location(), image.size(), 1, fd); <br />
fclose(fd); <br />
soap_begin(&amp;soap); <br />
image.soap_serialize(&amp;soap); <br />
image.soap_put(&amp;soap, <tt>"jpegimage"</tt>, NULL); <br />
soap_end(&amp;soap); <br />
...
</td></tr></table><br></i>
where <i>filesize</i> is a function that returns the size of a file given a file descriptor.

<p>
Reading the <tt>xsd:base64Binary</tt> encoded image.
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
xsd__base64Binary image; <br />
soap_begin(&amp;soap); <br />
image.get(&amp;soap, <tt>"jpegimage"</tt>); <br />
soap_end(&amp;soap); <br />
...
</td></tr></table><br></i>
The <i><b>struct</b></i> or <i><b>class</b></i> name <i>soap_enc__base64</i> should be used for <tt>SOAP-ENC:base64</tt> schema type instead of
<i>xsd__base64Binary</i>.

<p>
	     <h3><a name="tth_sEc9.10">
9.10</a>&nbsp;&nbsp;<font color="#0000FF">hexBinary XML Schema Type Encoding</font></h3><a name="sec:hexbinary">
</a>

<p>
The <tt>hexBinary</tt> XML schema type is a special form of dynamic array declared with the name <i>xsd__hexBinary</i> and a pointer (<i>__ptr</i>) to an <i><b>unsigned</b>&nbsp;<b>char</b></i> array.

<p>
For example, using a <i><b>struct</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__hexBinary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
Or using a <i><b>class</b></i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__hexBinary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>public</b>: <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
};
</td></tr></table><br></i>
When compiled by the gSOAP stub and skeleton compiler, this header file specification will generate <tt>base64Binary</tt> serializers and deserializers.

<p>
	     <h3><a name="tth_sEc9.11">
9.11</a>&nbsp;&nbsp;<font color="#0000FF">Doc/Literal XML Encoding Style</font></h3><a name="sec:literal">
</a>

<p>
gSOAP supports doc/literal SOAP encoding of request and/or response messages.
However, the XML schema of the message data must be known in order for the
gSOAP compiler to generate the (de)serialization routines.  In addition,
arbitrary XML documents can be (de)serialized into regular C strings or wide
character strings (<i>wchar_t*</i>) by gSOAP.  Because XML documents are stored
in strings, an application may need a ``plug-in'' XML parser to decode XML
content stored in strings. For details on (de)serialization XML into strings,
see Section&nbsp;<a href="#sec:literal2">9.11.1</a>.

<p>
gSOAP supports doc/literal SOAP encoding either manually by setting the values
of <i>soap.encodingStyle</i>, <i>soap.defaultNamespace</i>, and by using the flag
<i>SOAP_XML_TREE</i> for output mode in your code, or automatically by using a
gSOAP directive in the header file.  In most doc/literal cases, the
<tt>SOAP-ENV:encodingStyle</tt> attribute needs to be absent. To do this, set
<i>soap.encodingStyle=NULL</i>. Furthermore, a default namespace needs to be
defined by setting <i>soap.defaultNamespace</i>.  Finally, doc/literal is a
limited form of serialization and does not support graphs. So setting the flag
<i>SOAP_XML_TREE</i> will produce tree-structured output preventing
multi-reference data. Note that cyclic data will crash the doc/literal
serializer because of this setting. Also polymorphic data may cause
deserialization problems due to the absense of type information in the SOAP
payload (which makes us wonder why doc/literal is the default in .NET).

<p>
The <i>LocalTimeByZipCode</i> remote method of the LocalTime service provides
the local time given a zip code and uses doc/literal SOAP encoding (using MS
.NET).  The following header file declares the method: <br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>int
LocalTimeByZipCode(<b>char</b>&nbsp;*ZipCode, <b>char</b>&nbsp;**LocalTimeByZipCodeResult);
</td></tr></table><br></i> Note that none of the data types need to be namespace qualified using
namespace prefixes. The use of namespace prefixes is optional for doc/literal
in gSOAP. When used, the XML document will include <tt>xsi:type</tt> attributes.

<p>
To illustrate the manual doc/literal setting, the following client program sets
the required properties before the call:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.encodingStyle = NULL; // don't use SOAP encoding <br />
&nbsp;&nbsp;&nbsp;soap.defaultNamespace = "http://alethea.net/webservices/"; // use the service's namespace <br />
&nbsp;&nbsp;&nbsp;soap_set_omode(&amp;soap, SOAP_XML_TREE);" // don't produce multi-ref data (but can accept) <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_LocalTimeByZipCode(&amp;soap, "http://alethea.net/webservices/LocalTime.asmx", "http://alethea.net/webservices/LocalTimeByZipCode", "32306", &amp;t)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Time = %s<tt>\n</tt>", t); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
};
</td></tr></table><br></i>
The SOAP request is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /webservices/LocalTime.asmx HTTP/1.0 <br />
Host: alethea.net <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Length: 479 <br />
SOAPAction: "http://alethea.net/webservices/LocalTimeByZipCode" <br />
<br />
&lt;?xml version="1.0" encoding=&#220;TF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns="http://alethea.net/webservices/"&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LocalTimeByZipCode&#62;&lt;ZipCode&#62;32306&lt;/ZipCode&#62;&lt;/LocalTimeByZipCode&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
Alternatively, the settings can be automatically set by including gSOAP directives in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service name: localtime <br />
//gsoap ns service encoding: literal <br />
//gsoap ns service namespace: http://alethea.net/webservices/ <br />
int ns__LocalTimeByZipCode(<b>char</b>&nbsp;*ZipCode, <b>char</b>&nbsp;**LocalTimeByZipCodeResult);
</td></tr></table><br></i>
In this case, the method name requires to be associated with a schema through a namespace prefix, e.g. <i>ns</i> is used in this example.
See Section&nbsp;<a href="#sec:directives">13.2</a> for more details on gSOAP directives.
With these directives, the gSOAP compiler generates client and server sources with the specified settings.
The directives are required to produce a WSDL file for a new service that uses doc/literal encoding.

<p>
The example client program can be simplified into:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
#include "localtime.nsmap" // include generated map file <br />
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_call_ ns__LocalTimeByZipCode(&amp;soap, "http://alethea.net/webservices/LocalTime.asmx", "http://alethea.net/webservices/LocalTimeByZipCode", "32306", &amp;t)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Time = %s<tt>\n</tt>", t); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
</td></tr></table><br></i>

<p>
	      <h4><a name="tth_sEc9.11.1">
9.11.1</a>&nbsp;&nbsp;<font color="#0000FF">Serializing and Deserializing XML Into Strings</font></h4><a name="sec:literal2">
</a>

<p>
To declare a literal XML ``type'' to hold XML documents in regular strings, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML;
</td></tr></table><br></i>
To declare a literal XML ``type'' to hold XML documents in wide character strings, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;wchar_t *XML;
</td></tr></table><br></i>
Note: only one of the two storage formats can be used.
The differences between the use of regular strings versus wide character strings for XML documents are:

<ul><p>
<li> Regular strings for XML documents MUST hold UTF-8 encoded XML documents. That is, the string MUST contain the proper UTF-8
encoding to exchange the XML document in SOAP messages.</li>
<p>
<li> Wide character strings for XML documents SHOULD NOT hold UTF-8 encoded XML documents. Instead, the UTF-8 translation is done automatically by
the gSOAP runtime marshalling routines.</li>
</ul>
Literal XML encoding should only use one input parameter and one output parameter.
Here is an example of a remote method specification in which the parameters of the remote method uses literal XML encoding to pass
an XML document to a service and back:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML; <br />
ns__GetDocument(XML m__XMLDoc, XML &amp;m__XMLDoc_);
</td></tr></table><br></i>
The <i>ns__Document</i> is essentially a <i><b>struct</b></i> that forms the root of the XML document.
The use of the underscore in the <i>ns__Document</i> response part of the message avoids the name clash between the
<i><b>struct</b></i>s.
Assuming that the namespace mapping table contains the binding of <i>ns</i> to <tt>http://my.org/</tt>
and the binding of <i>m</i> to <tt>http://my.org/mydoc.xsd</tt>, the XML message is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;?xml version="1.0" encoding="UTF-8"?&#62; <br />
&lt;SOAP-ENV:Envelope <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" <br />
&nbsp;&nbsp;&nbsp;xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" <br />
&nbsp;&nbsp;&nbsp;xmlns:xsd="http://www.w3.org/2001/XMLSchema" <br />
&nbsp;&nbsp;&nbsp;xmlns:ns="http://my.org/" <br />
&nbsp;&nbsp;&nbsp;xmlns:m="http://my.org/mydoc.xsd" <br />
&nbsp;&nbsp;&nbsp;SOAP-ENV:encodingStyle=""&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;SOAP-ENV:Body&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ns:GetDocument&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;XMLDoc xmlns="http://my.org/mydoc.xsd"&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/XMLDoc&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ns:Document&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
Important: the literal XML encoding style MUST be specified by setting <i>soap.encodingStyle</i>, where <i>soap</i> is a variable
that contains the current runtime environment.
For example, to specify no constraints on the encoding style (which is typical) use NULL:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.encodingStyle = NULL;
</td></tr></table><br></i>
As a result, the <tt>SOAP-ENV:encodingStyle</tt> attribute will not appear in the SOAP payload.

<p>
For interoperability with Apache SOAP, use
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.encodingStyle = "http://xml.apache.org/xml-soap/literalxml";
</td></tr></table><br></i>
The name of the response element can be changed (default is the remote method name ending with <i>Response</i>).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>typedef</b>&nbsp;<b>char</b>&nbsp;*XML; <br />
ns__GetDocument(<b>struct</b>&nbsp;soap *soap, XML m__XMLDoc, <b>struct</b>&nbsp;ns__Document { XML m__XMLDoc; } &amp;result);
</td></tr></table><br></i>

<p>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;<font color="#0000FF">SOAP Fault Processing</font></h2><a name="sec:fault">
</a>

<p>
A predeclared standard SOAP Fault data structure is generated by the gSOAP stub and skeleton compiler for exchanging exception messages.
This predeclared data structure is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Fault <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultcode; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultstring; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultactor; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*detail; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Code; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Reason; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Detail; <br />
};
</td></tr></table><br></i>
The first four fields are SOAP 1.1 specific. The last three fields are SOAP 1.2 specific.
The data structure can be changed to the need of an application.  To do this, include a new declaration of a
<i><b>struct</b>&nbsp;SOAP_ENV__Fault</i> in the header file input to the gSOAP compiler to replace the built-in data structure.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Fault <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultcode; // MUST be string <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultstring; // MUST be string <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*faultactor; <br />
&nbsp;&nbsp;&nbsp;Detail *detail; // new detail field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Code; // MUST be string<br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Reason; // MUST be string<br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*SOAP_ENV__Detail; // MUST be string<br />
&nbsp;&nbsp;&nbsp;Detail SOAP_ENVB Detail; // new SOAP 1.2 detail field <br />
};
</td></tr></table><br></i>
where <i>Detail</i> is some data type that holds application specific data such as a stack dump.

<p>
When the skeleton of a remote method returns an error (see Section&nbsp;<a href="#sec:errcodes">8.2</a>), then <i>soap.fault</i> contains the SOAP
Fault data at the receiving side (client).

<p>
When a remote method wants to raise an exception, it does so by assigning the <i>fault</i> field of the current reference to the
runtime environment with 
appropriate data associated with the exception and by returning the error <i>SOAP_FAULT</i>.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;soap_receiver_fault(soap, "Stack dump", NULL); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap-&#62;version == 2) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>SOAP_ENV__Detail = sp; // SOAP 1.2: point to stack <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>fault<tt>-&gt;</tt>detail = sp; // SOAP 1.1: point to stack <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_Fault; // return from remote method call
</td></tr></table><br></i>
When <i>soap_fault</i> allocates a fault struct, this data is removed with the <i>soap_end</i> call (or <i>soap_dealloc</i>).
Note that the <i>soap_receiver_fault</i> function is called to allocate the fault struct and set the fault string and detail
fields, i.e. <i>soap_receiver_fault(soap, "Stack dump", NULL)</i>. The advantage is that this is independent of SOAP 1.1 and
SOAP 1.2.  However, setting the custom detail fields requires inspecting the SOAP version used, using the <i>soap-&#62;version</i>
attribute which is 1 for SOAP 1.1 and 2 for SOAP 1.2.

<p>
Each remote method implementation in a service application can return a SOAP Fault upon an exception by returning an error code,
see Section&nbsp;<a href="#sec:example7">6.2.1</a> for details and an example.
In addition, a SOAP Fault can be returned by a service application through calling the <i>soap_send_fault</i> function.
This is useful in case the initialization of the application fails, as illustrated in the example below:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;some initialization code <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(initialization failed) <br />
&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.error = soap_receiver_fault(&amp;soap, &#207;nit failed", "..."); // set the error condition (SOAP_FAULT) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_send_fault(&amp;soap); // Send SOAP Fault to client <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; // Terminate <br />
&nbsp;&nbsp;&nbsp;} <br />
}
</td></tr></table><br></i>

<p>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;<font color="#0000FF">SOAP Header Processing</font></h2><a name="sec:header">
</a>

<p>
A predeclared standard SOAP Header data structure is generated by the gSOAP stub and skeleton compiler for exchanging SOAP
messages with SOAP Headers.
This predeclared data structure is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <b>void</b>&nbsp;*dummy; <br />
};
</td></tr></table><br></i>
which declares and empty header (some C and C++ compilers don't accept empty structs so a transient dummy field is provided).

<p>
To adapt the data structure to a specific need for SOAP Header processing, a
new <i><b>struct</b>&nbsp;SOAP_ENV__Header</i> can be added to the header file input to the gSOAP
compiler.  A <i><b>class</b></i> for the SOAP Header data structure can be used instead of a <i><b>struct</b></i>.

<p>
For example, the following header can be used for transaction control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <b>char</b>&nbsp;*t__transaction; <br />
};
</td></tr></table><br></i>
with client-side code:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
... <br />
soap.header = NULL; // do not use a SOAP Header for the request (as set with soap_init) <br />
soap.actor = NULL; // do not use an actor (receiver is actor) <br />
soap_call_method(&amp;soap, ...); <br />
<b>if</b>&nbsp;(soap.header) // a SOAP Header was received <br />
&nbsp;&nbsp;&nbsp;cout  &lt;&lt;  soap.header<tt>-&gt;</tt>t__transaction; <br />
// Can reset, modify, or set soap.header here before next call <br />
soap_call_method(&amp;soap, ...); // reuse the SOAP Header of the service response for the request <br />
...
</td></tr></table><br></i>
The SOAP Web service response can include a SOAP Header with a transaction number that the client is supposed to use for the next remote method invocation to the service. Therefore, the next request includes a transaction number:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
... <br />
&lt;SOAP-ENV:Envelope ...&#62; <br />
&lt;SOAP-ENV:Header&#62; <br />
&lt;t:transaction xsi:type="int"&#62;12345&lt;/t:transaction&#62; <br />
&lt;/SOAP-ENV:Header&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
... <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>
This is just an example and the transaction control is not a feature of SOAP but can be added on by the application layer
to implement stateful transactions between clients and services.
At the client side, the <i>soap.actor</i> attribute can be set to
indicate the recipient of the header (the SOAP <tt>SOAP-ENV:actor</tt> attribute).

<p>
A Web service can read and set the SOAP Header as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap.actor = NULL; // use this to accept all headers (default) <br />
&nbsp;&nbsp;&nbsp;soap.actor = "http://some/actor"; // accept headers destined for "http://some/actor" only <br />
&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap);<br />
} <br />
... <br />
<b>int</b>&nbsp;method(<b>struct</b>&nbsp;soap *soap, ...) <br />
{<br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>header) // a Header was received <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... = soap<tt>-&gt;</tt>header<tt>-&gt;</tt>t__transaction; <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>header = soap_malloc(<b>sizeof</b>(<b>struct</b>&nbsp;SOAP_ENV__Header)); // alloc new header <br />
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>header<tt>-&gt;</tt>t__transaction = ...; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>
See Section&nbsp;<a href="#sec:directives">13.2</a> on how to generate WSDL with the proper method-to-header-part bindings.

<p>
The <tt>SOAP-ENV:mustUnderstand</tt> attribute indicates the requirement that the recipient of the SOAP Header (who must
correspond to the <tt>SOAP-ENV:actor</tt> attribute when present or when the attribute has the value
<tt>SOAP-ENV:actor="http://schemas.xmlsoap.org/soap/actor/next"</tt>) MUST handle the Header part that carries the attribute.
gSOAP handles this automatically on the background. However, an application still needs to inspect the header part's value
and handle it appropriately. If a remote method in a Web service is not able to do this, it should return
<i>SOAP_MUSTUNDERSTAND</i> to indicate this failure.

<p>
The syntax for the header file input to the gSOAP compiler is extended with a special storage qualifier <i>mustUnderstand</i>.
This qualifier can be used in the SOAP Header declaration to indicate which parts should carry a <i>SOAP-ENV:mustUnderstand="1"</i>
attrbute. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t__transaction; <br />
&nbsp;&nbsp;&nbsp;mustUnderstand <b>char</b>&nbsp;*t__authentication; <br />
};
</td></tr></table><br></i>
When both fields are set and <i>soap.actor="http://some/actor"</i> then the message contains:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;SOAP-ENV:Envelope ...&#62; <br />
&lt;SOAP-ENV:Header&#62; <br />
&lt;t:transaction&#62;5&lt;/t:transaction&#62; <br />
&lt;t:authentication SOAP-ENV:actor="http://some/actor" SOAP-ENV:mustUnderstand="1"&#62;XX&lt;/t:authentication&#62; <br />
&lt;/SOAP-ENV:Header&#62; <br />
&lt;SOAP-ENV:Body&#62; <br />
... <br />
&lt;/SOAP-ENV:Body&#62; <br />
&lt;/SOAP-ENV:Envelope&#62;
</td></tr></table><br></tt>

<p>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;<font color="#0000FF">DIME Attachment Processing</font></h2><a name="sec:DIME">
</a>

<p>
gSOAP can transmit binary data with DIME attachments with or without streaming.
With DIME output streaming, the binary data is retrieved from an application's
data source at run time in parts without storing the entire content. With DIME
input streaming, the binary data will be handed to the application in parts.
DIME streaming is implemented with function callbacks. See
Section&nbsp;<a href="#sec:DIMEstreaming">12.2</a> for more details.

<p>
	     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;<font color="#0000FF">Non-Streaming DIME</font></h3>

<p>
Without streaming, the binary data is stored in augmented
<tt>xsd:base64Binary</tt> and <tt>xsd:hexBinary</tt> structs/classes.  These
structs/classes have three additional fields: an <i>id</i> field for attachment
referencing (typically a content id (CID) or UUID), a <i>type</i> field to
specify the MIME type of the binary data, and an <i>options</i> field to
piggy-back additional information with a DIME attachment. DIME attachment
support is fully automatic, which means that gSOAP will test for the presence
of attachments at run time and use SOAP in DIME accordingly.

<p>
A <tt>xsd:base64Binary</tt> type with DIME attachment support is declared by
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*id; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*type; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*options; <br />
};
</td></tr></table><br></i>
The specification order of the fields is significant. In addition, no other
fields or methods may be declared before any of these fields in the
struct/class, but additional fields and methods can appear after the field
declarations.  A <i>xsd:hexBinary</i> declaration is similar. When the <i>id</i>
field and/or <i>type</i> field is non-NULL during run-time serialization of the
data, DIME attachment transmission is used for the <em>entire</em> SOAP message,
as per SOAP in DIME specifications.  When only the <i>type</i> field is set,
gSOAP will assign a default DIME id to the attachment (see also below).  The
<i>options</i> field is an optional string with a special layout: the first two
bytes are reserved for the option type, the next two bytes store the size of
the option data, followed by the option data. The function
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;*soap_option(<b>struct</b>&nbsp;soap *soap, <b>unsigned</b>&nbsp;<b>short</b>&nbsp;type, <b>const</b>&nbsp;<b>char</b>&nbsp;*option)
</td></tr></table><br></i>
returns a string with this encoding. For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;xsd__base64Binary image; <br />
image.__ptr = ...; <br />
image.__size = ...; <br />
image.id = "uuid:09233523-345b-4351-b623-5dsf35sgs5d6"; <br />
image.type = "image/jpeg"; <br />
image.options = soap_option(soap, 0, "My wedding picture");
</td></tr></table><br></i>
When receiving DIME attachments, the fields will be set according to the DIME
attachment content. If binary data is received without attachments, the
<i>id</i>, <i>type</i>, <i>options</i> fields are all NULL. Note that SOAP
messages may contain binary data that references external resources not
provided as attachments. In that case, the <i>__ptr</i> field is NULL and the
<i>id</i> field refers to the external data source. Non-augmented binary data
types <tt>xsd:base64Binary</tt> and <tt>xsd:hexBinary</tt> can be used to receive
DIME attachments, but the <i>id</i>, <i>type</i>, and <i>options</i> information
are absent. Also DIME attachments can be received and stored in strings, but
not send from strings.

<p>
When necessary, the <tt>xsd:base64Binary</tt> schema type and its attachment-based
counterpart can be specified with class inheritance. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>class</b>&nbsp;xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>char</b>&nbsp;*__ptr; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size; <br />
}; <br />
<b>class</b>&nbsp;xsd__base64Binary_ : xsd__base64Binary <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*id; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*type; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*options; <br />
};
</td></tr></table><br></i>
The <i>dime_id_format</i> attribute of the current gSOAP run-time environment
can be set to the default format of DIME id fields.  The format string MUST
contain a <i>%d</i> format specifier (or any other <i><b>int</b></i>-based format
specifier). The value of this specifier is a non-negative integer, with zero
being the value of the DIME attachment id for the SOAP message.  For example,
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap;<br />soap_init(&amp;soap); <br />
soap.dime_id_format
= "uuid:09233523-345b-4351-b623-5dsf35sgs5d6-%x"; <br />
</td></tr></table><br></i>
As a result, all attachments with a NULL <i>id</i> field will use a
gSOAP-generated id value based on the format string.

<p>
	     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;<font color="#0000FF">Streaming DIME</font></h3><a name="sec:DIMEstreaming">
</a>

<p>
Three function callbacks for streaming DIME output and three callbacks for
streaming DIME input are available. These callbacks are used to access
application data resources during transmission.

<p>
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b>Callback (function pointer)</b></font> </td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;*(*soap.fdimereadopen)(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>const</b>&nbsp;<b>char</b>&nbsp;*id, <b>const</b>&nbsp;<b>char</b>&nbsp;*type, <b>const</b>&nbsp;<b>char</b>&nbsp;*options)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment sender to start reading from a
(binary) data source for outbound transmission. The content will be read from the
application's data source in chunks using the <i>fdimeread</i> callback and
streamed into the SOAP/XML/DIME output stream. The <i>handle</i> contains the
value of the <i>__ptr</i> field of an attachment struct/class, which could be a
pointer to specific information such as a file descriptor or a pointer to a
string to be passed to this callback.  Both <i>__ptr</i> and <i>__size</i>
fields should have been set by the application prior to the serialization of
the content. The <i>id</i>, <i>type</i>, and <i>options</i> arguments are the DIME
id, type, and options, respectively. The callback should return <i>handle</i>,
or another pointer value which will be passed as a handle to <i>fdimeread</i>
and <i>fdimereadclose</i>.  The callback should return NULL and set
<i>soap</i><tt>-&gt;</tt><i>error</i> when an error occurred. The callback should return
NULL (and not set <i>soap</i><tt>-&gt;</tt><i>error</i>) when this particular DIME
attachment is not to be streamed.
</td></tr>
<tr><td width="602"><i>size_t (*soap.fdimeread)(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>char</b>&nbsp;*buf, size_t len)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment sender to read more data from a
(binary) data source for streaming into the output stream.  The <i>handle</i>
contains the value returned by the <i>fdimereadopen</i> callback.  The <i>buf</i>
argument is the buffer of length <i>len</i> into which a chunk of data should be
stored.  The actual amount of data stored in the buffer might be less than
<i>len</i> and the amount should be returned by the application.  A return value
of 0 indicates an error.  The <i>__size</i> field of the attachment
struct/class should have been set by the application prior to the serialization
of the content.  The value of <i>__size</i> indicates the total size of the
content to be transmitted.
</td></tr>
<tr><td width="602"><i><b>void</b>(*soap.fdimereadclose)(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment sender at the end of the
streaming process to close the data source.  The <i>handle</i> contains the
value returned by the <i>fdimereadopen</i> callback.  The <i>fdimewriteclose</i>
callback is called after successfully transmitting the data or when an error
occurred.
</td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;*(*soap.fdimewriteopen)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*id, <b>const</b>&nbsp;<b>char</b>&nbsp;*type, <b>const</b>&nbsp;<b>char</b>&nbsp;*options)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment receiver to start writing an
inbound DIME attachment to an application's data store. The content is streamed
into an application data store through multiple <i>fdimewrite</i> calls from the
gSOAP attachment receiver.  The <i>id</i>, <i>type</i>, and <i>options</i>
arguments are the DIME id, type, and options, respectively. The callback should
return a handle which is passed to the <i>fdimewrite</i> and
<i>fdimewriteclose</i> callbacks. The <i>__ptr</i> field of the attachment
struct/class is set to the value of this handle. The <i>__size</i> field is set
to the total size of the attachment after receving the entire content. The size
is unknown in advance because a DIME attachment may be chunked.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fdimewrite)(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>const</b>&nbsp;<b>char</b>&nbsp;*buf, size_t len)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment receiver to write part of
an inbound DIME attachment to an application's data store.
The <i>handle</i>
contains the value returned by the <i>fdimewriteopen</i> callback.  The <i>buf</i>
argument contains the data of length <i>len</i>.
The callback should return a gSOAP error code (e.g.&nbsp;<i>SOAP_OK</i> when no error occurred).
</td></tr>
<tr><td width="602"><i><b>void</b>(*soap.fdimewriteclose)(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle)</i> </td></tr>
<tr><td width="602">Called by the gSOAP run-time DIME attachment receiver at the end of the
streaming process to close the data store.  The <i>fdimewriteclose</i> callback
is called after successfully receiving the data or when an error occurred.  The
<i>handle</i> contains the value returned by the <i>fdimewriteopen</i> callback.
</td></tr></table>

</td></tr></table><br></span>
In addition, a <i><b>void</b>*user</i> field in the <i><b>struct</b>&nbsp;soap</i> data structure is available to pass user-defined data to the callbacks.

<p>
The following example illustrates the client-side initialization of an image attachment struct to stream a file into a DIME attachment:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;xsd__base64Binary image; <br />
&nbsp;&nbsp;&nbsp;FILE *fd; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;stat sb; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!fstat(fileno(fd), &amp;sb) &amp;&amp; sb.st_size  &gt;  0) <br />
&nbsp;&nbsp;&nbsp;{ // because we can get the length of the file, we can stream it <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fdimereadopen = dime_read_open; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fdimereadclose = dime_read_close; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.fdimeread = dime_read; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.__ptr = (<b>unsigned</b>&nbsp;<b>char</b>*)fd; // must set to non-NULL (this is our fd handle which we need in the callbacks) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.__size = sb.st_size; // must set size <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ // don't know the size, so buffer it <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t i; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;c; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.__ptr = (<b>unsigned</b>&nbsp;<b>char</b>*)soap_malloc(&amp;soap, MAX_FILE_SIZE); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(i = 0; i  &lt;  MAX_FILE_SIZE; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;((c = fgetc(fd)) == EOF) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.__ptr[i] = c; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(fd); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.__size = i; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;image.type = "image/jpeg"; <br />
&nbsp;&nbsp;&nbsp;image.options = soap_dime_option(&amp;soap, 0, "My picture"); <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method(&amp;soap, ...); <br />
&nbsp;&nbsp;&nbsp;... <br />
} <br />
<b>void</b>&nbsp;*dime_read_open(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>const</b>&nbsp;<b>char</b>&nbsp;*id, <b>const</b>&nbsp;<b>char</b>&nbsp;*type, <b>const</b>&nbsp;<b>char</b>&nbsp;*options) <br />
{ <b>return</b>&nbsp;handle; <br />
} <br />
<b>void</b>&nbsp;dime_read_close(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle) <br />
{ fclose((FILE*)handle); <br />
} <br />
size_t dime_read(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>char</b>&nbsp;*buf, size_t len) <br />
{ <b>return</b>&nbsp;fread(buf, 1, len, (FILE*)handle); <br />
}
</td></tr></table><br></i>

<p>
The following example illustrates the streaming of a DIME attachment into a file by a client:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.fdimewriteopen = dime_write_open; <br />
&nbsp;&nbsp;&nbsp;soap.fdimewriteclose = dime_write_close; <br />
&nbsp;&nbsp;&nbsp;soap.fdimewrite = dime_write; <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__method(&amp;soap, ...); <br />
&nbsp;&nbsp;&nbsp;... <br />
} <br />
<b>void</b>&nbsp;*dime_write_open(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*id, <b>const</b>&nbsp;<b>char</b>&nbsp;*type, <b>const</b>&nbsp;<b>char</b>&nbsp;*options) <br />
{ <br />
&nbsp;&nbsp;&nbsp;FILE *handle = fopen("somefile", "wb"); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!handle) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>error = SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>errnum = errno; // get reason <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;(<b>void</b>*)handle; <br />
} <br />
<b>void</b>&nbsp;dime_write_close(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle) <br />
{ fclose((FILE*)handle); <br />
} <br />
<b>int</b>&nbsp;dime_write(<b>struct</b>&nbsp;soap *soap, <b>void</b>&nbsp;*handle, <b>const</b>&nbsp;<b>char</b>&nbsp;*buf, size_t len) <br />
{ <br />
&nbsp;&nbsp;&nbsp;size_t nwritten; <br />
&nbsp;&nbsp;&nbsp;<b>while</b>&nbsp;(len) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nwritten = fwrite(buf, 1, len, (FILE*)handle); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!nwritten) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>errnum = errno; // get reason <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len -= nwritten; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf += nwritten; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;<font color="#0000FF">Advanced Features</font></h2><a name="sec:advanced">
</a>

<p>
		     <h3><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;<font color="#0000FF">Internationalization</font></h3>

<p>
The use of wide-character strings (<i>wchar_t*</i>) in C and C++ clients and
services suffices for internationalization.  In contrast, when strings with
wide characters are received and stored in regular strings, only the lower 8
bits of the wide characters are retained.  The <i>SOAP_C_UTFSTRING</i> flag
can be set to enable send and/or receive of wide-characters with regular
strings.  With this flag set, text will be stored in UTF8 format in the strings
directly, which means that character codes 1 to 127 are treated as plain ASCII.
Codes with the MSB set are UTF8-encoded characters. Please consult the UTF8
specification for details.

<p>
		     <h3><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;<font color="#0000FF">Customizing the WSDL and Namespace Mapping Table File Contents</font></h3><a name="sec:directives">
</a>

<p>
A header file can be augmented with directives for the gSOAP Stub and Skeleton compiler to automatically generate customized WSDL and namespace mapping tables contents. The WSDL and namespace mapping table files do not need to be modified by hand (Sections&nbsp;<a href="#sec:wsdl">6.2.5</a> and&nbsp;<a href="#sec:nstable">8.4</a>).
In addition, the sample SOAP/XML request and response files generated by the compiler are valid provided that XML schema namespace
information is added to the header file with directives so that the gSOAP compiler can produce example SOAP/XML messages that are correctly namespace qualified.
These compiler directive are specified as <i>//</i>-comments.

<p>
Three directives are currently supported that can be used to specify details associated with namespace prefixes used by the remote
method names in the header file.
To specify the name of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service name: <i>service-name</i>
</td></tr></table><br></i>
where <i>namespace-prefix</i> is a namespace prefix used by identifiers in the header file and <i>service-name</i> is the name
of a Web Service (only required to create new Web Services).
The name may be followed by text up to the end of the line which is incorporated into the WSDL service documentation. Alternatively, the service documentation can be provided with the directive below.

<p>
To specify the documentation of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service documentation: <i>text</i>
</td></tr></table><br></i>
where <i>namespace-prefix</i> is a namespace prefix used by identifiers in the header file and <i>text</i> is the documentation text up to the end of the line.
The text is incorporated into the WSDL service documentation.

<p>
To specify the portType of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service portType: <i>portType</i>
</td></tr></table><br></i>
where <i>namespace-prefix</i> is a namespace prefix used by identifiers in the header file and <i>portType</i> is the portType name of the WSDL service portType.

<p>
To specify the location (or port endpoint) of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service location: <i>URL</i>
</td></tr></table><br></i>
or alternatively
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service port: <i>URL</i>
</td></tr></table><br></i>
where <i>URL</i> is the location of the Web Service (only required to create new Web Services).
The <i>URL</i> specifies the path to the service executable (so <i><i>URL</i>/<i>service-executable</i></i>
is the actual location of the executable when declared).

<p>
To specify the name of the executable of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service executable: <i>executable-name</i>
</td></tr></table><br></i>
where <i>executable-name</i> is the name of the executable of the Web Service.

<p>
To specify the namespace URI of a Web Service in the header file, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service namespace: <i>namespace-URI</i>
</td></tr></table><br></i>
where <i>namespace-URI</i> is the URI associated with the namespace prefix.

<p>
In addition, the schema namespace URI can be specified in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> schema namespace: <i>namespace-URI</i>
</td></tr></table><br></i>
where <i>namespace-URI</i> is the schema URI associated with the namespace prefix.
If present, it defines the schema-part of the generated WSDL file and the URI in the namespace mapping table.
This declaration is useful when the service declares its own data types that need to be associated with a namespace.
Furthermore, the header file for client applications do not need the full service details and the specification of the schema
namespaces for namespace prefixes suffices.

<p>
To document a method, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-documentation: <i>method-name</i> //<i>text</i>
</td></tr></table><br></i>
where <i>method-name</i> is the unqualified name of the method and <i>text</i>
is a line of text terminated by a newline. Do not use any XML reserved
characters in <i>text</i> such as  &lt;  and  &gt; . Use XML and XHTML markup instead.
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-documentation: getQuote This method returns a stock quote <br />
<b>int</b>&nbsp;ns__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;_result);
</td></tr></table><br></i>

<p>
To specify the SOAPAction for a method, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-action: <i>method-name</i> <i>action</i>
</td></tr></table><br></i>
where <i>method-name</i> is the unqualified name of the method and <i>action</i>
is a quoted or non-quoted string (spaces and blanks are not allowed).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-action: getQuote "" <br />
<b>int</b>&nbsp;ns__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;_result);
</td></tr></table><br></i>

<p>
When header processing is required, each method declared in the WSDL should provide a binding to the parts of the header that may
appear as part of a method request message. Such a binding is given by:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;SOAP_ENV__Header <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*h__transaction; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;UserAuth *h__authentication; <br />
};
</td></tr></table><br></i>
Suppose method <i>ns__login</i> uses both header parts (at most), then this is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-header-part: login transaction <br />
//gsoap ns service method-header-part: login authentication <br />
<b>int</b>&nbsp;ns__login(...);
</td></tr></table><br></i>
Suppose method <i>ns__search</i> uses only the first header part (at most), then this is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service method-header-part: search transaction <br />
int ns__search(...);
</td></tr></table><br></i>
Note that the method name and header part names in the directive are left unqualified.

<p>
To specify the header parts for the method input (method request message), use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-input-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
Similarly, to specify the header parts for the method output (method response message), use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service method-output-header-part: <i>method-name</i> <i>header-part</i>
</td></tr></table><br></i>
The declarations above only affect the WSDL. It's the application's responsibility to set and reset the header messages.

<p>
When doc/literal encoding is required, the service encoding can be specified in the header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service encoding: literal
</td></tr></table><br></i>
or when the <tt>SOAP-ENV:encodingStyle</tt> attribute is different from the SOAP 1.1 encoding style:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap <i>namespace-prefix</i> service encoding: <i>encoding-style</i>
</td></tr></table><br></i>

<p>
(Note: blanks can be used anywhere in the directive, except between <i>//</i> and <i>gsoap</i>.)

<p>
The use of these directive is best illustrated with an example.
The <i>quotex.h</i> header file of the <i>quotex</i> example in the gSOAP distribution for Unix/Linux is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns1 service namespace:	urn:xmethods-delayed-quotes <br />
<b>int</b>&nbsp;ns1__getQuote(<b>char</b>&nbsp;*symbol, <b>float</b>&nbsp;&amp;result); <br />
 <br />
//gsoap ns2 service namespace:	urn:xmethods-CurrencyExchange <br />
<b>int</b>&nbsp;ns2__getRate(<b>char</b>&nbsp;*country1, <b>char</b>&nbsp;*country2, <b>float</b>&nbsp;&amp;result); <br />
 <br />
//gsoap ns3 service name:	quotex <br />
//gsoap ns3 service location:	http://www.cs.fsu.edu/~engelen <br />
//gsoap ns3 service namespace:	urn:quotex <br />
<b>int</b>&nbsp;ns3__getQuote(<b>char</b>&nbsp;*symbol, <b>char</b>&nbsp;*country, <b>float</b>&nbsp;&amp;result);
</td></tr></table><br></i>
The <i>quotex</i> example is a new Web Service created by combining two existing Web Services:
the XMethods Delayed Stock Quote service and XMethods Currency Exchange service.

<p>
Namespace prefix <i>ns3</i> is used for the new <i>quotex</i> Web Service with namespace URI <i>urn:quotex</i>,
service name <i>quotex</i>, and location <i>http://www.cs.fsu.edu/~engelen</i>.
Since the new Web Service invokes the <i>ns1__getQuote</i> and <i>ns2__getRate</i> remote methods,
the service namespaces of these methods are given.
The service names and locations of these methods are not given because they
are only required for setting up a new Web Service for these methods
(but may also be provided in the header file for documentation purposes).
After invoking the gSOAP Stub and Skeleton compiler on the <i>quotex.h</i> header file:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>soapcpp2 quotex.h</i>
</td></tr></table><br></span>
the WSDL of the new <i>quotex</i> Web Service is saved as <i>quotex.wsdl</i>.
Since the service name (<i>quotex</i>), location (<i>http://www.cs.fsu.edu/~engelen</i>), and namespace URI
(<i>urn:quotex</i>) were provided in the header file, the generated WSDL file does not need to be changed by hand and can be published
immediately together with the compiled Web Service installed as a CGI application at the designated URL
(<i>http://www.cs.fsu.edu/~engelen/quotex.cgi</i>
and <i>http://www.cs.fsu.edu/~engelen/quotex.wsdl</i>).

<p>
The namespace mapping table for the <i>quotex.cpp</i> Web Service implementation
is saved as <i>quotex.nsmap</i>.  This file can be directly included in
<i>quotex.cpp</i> instead of specified by hand in the source of
<i>quotex.cpp</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "quotex.nsmap"
</td></tr></table><br></i>
The automatic generation and inclusion of the namespace mapping table requires
compiler directives for <b>all</b> namespace prefixes to associate each
namespace prefix with a namespace URI. Otherwise, namespace URIs have to be
manually added to the table (they appear as <i>http://tempuri.org</i>).

<p>
		     <h3><a name="tth_sEc13.3">
13.3</a>&nbsp;&nbsp;<font color="#0000FF">How to Specify minOccurs and maxOccurs Schema Attributes</font></h3>

<p>
By default, gSOAP generates WSDL and schemas with <tt>minOccurs=1</tt> and <tt>maxOccurs=1</tt> for non-array types, and
<tt>minOccurs=0</tt> and <tt>maxOccurs=unbounded</tt> for array types.
The <tt>minOccurs</tt> and <tt>maxOccurs</tt> attribute values of fields in <i><b>struct</b></i> and <i><b>class</b></i> types are specified as
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<u><span class="roman">Type</span></u> <u><span class="roman">fieldname</span></u> <font size="+1"><span class="roman">[</span></font><u><span class="roman">minOccurs</span></u><font size="+1"><span class="roman">[</span></font>:<u><span class="roman">maxOccurs</span></u><font size="+1"><span class="roman">]</span></font><font size="+1"><span class="roman">]</span></font> <font size="+1"><span class="roman">[</span></font>= value<font size="+1"><span class="roman">]</span></font>
</td></tr></table><br></i>
The minOccurs and maxOccurs values must be integer literals.

<p>
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;ns__MyRecord <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m 0; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;__size 0:10; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;*item; <br />
}
</td></tr></table><br></i>
gSOAP generates:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
&lt;complexType name="MyRecord&#187; <br />
&nbsp;&nbsp;&nbsp;&lt;all&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="n" type="xsd:int" minOccurs="1" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="m" type="xsd:int" minOccurs="0" maxOccurs="1"/&#62; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;element name="item" type="xsd:int" minOccurs="0" maxOccurs="10"/&#62; <br />
&nbsp;&nbsp;&nbsp;&lt;/all&#62; <br />
&lt;/complexType&#62;
</td></tr></table><br></tt>

<p>
		     <h3><a name="tth_sEc13.4">
13.4</a>&nbsp;&nbsp;<font color="#0000FF">Transient Data Types</font></h3><a name="sec:transient">
</a>

<p>
There are situations when certain data types have to be ignored by gSOAP for the compilation of (de)marshalling routines.
For example, in certain cases the fields in a class or struct need not be (de)serialized, or the base class of a derived class should not be
(de)serialized, and certain built-in classes such as <i>ostream</i> cannot be (de)serialized.
These data types (including fields) are called ``transient'' and can be declared outside of gSOAP's compilation window.
Transient data type and transient fields are declared with the <i><b>extern</b></i> keyword or are declared within <i>[</i> and <i>]</i> blocks in the header file
input to the gSOAP compiler.
The <i><b>extern</b></i> keyword has a special meaning to the gSOAP compiler and won't affect the generated codes.
The special <i>[</i> and <i>]</i> block construct can be used with data type declarations and within <i><b>struct</b></i> and
<i><b>class</b></i> declarations. The use of <i><b>extern</b></i> or <i>[ ]</i> achieve the same effect, but <i>[ ]</i> may be more convenient
to encapsulate transient types in a larger part of the header file. The use of <i><b>extern</b></i> with <i><b>typedef</b></i> is reserved for
the declaration of user-defined external (de)serializers for data types, see Section&nbsp;<a href="#sec:extern">13.5</a>.

<p>
First example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>extern</b>&nbsp;<b>class</b>&nbsp;ostream; // ostream can't be (de)serialized, but need to be declared to make it visible to gSOAP <br />
<b>class</b>&nbsp;ns__myClass <br />
{ ... <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;print(ostream &amp;s) <b>const</b>; // need ostream here <br />
&nbsp;&nbsp;&nbsp;... <br />
};
</td></tr></table><br></i>
Second example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
[ <br />
&nbsp;&nbsp;&nbsp;<b>class</b>&nbsp;myBase // base class need not be (de)serialized <br />
&nbsp;&nbsp;&nbsp;{ ... }; <br />
] <br />
<b>class</b>&nbsp;ns__myDerived : myBase <br />
{ ... }; <br />
</td></tr></table><br></i>
Third example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
[ <b>typedef</b>&nbsp;<b>int</b>&nbsp;transientInt; ] <br />
<b>class</b>&nbsp;ns__myClass <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;a; // will be (de)serialized <br />
&nbsp;&nbsp;&nbsp;[ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;b; // transient field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;s[256]; // transient field <br />
&nbsp;&nbsp;&nbsp;]  <br />
&nbsp;&nbsp;&nbsp;<b>extern</b>&nbsp;<b>float</b>&nbsp;d; // transient field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; // will be (de)serialized <br />
&nbsp;&nbsp;&nbsp;transientInt *n; // transient field <br />
&nbsp;&nbsp;&nbsp;[ <br />
&nbsp;&nbsp;&nbsp;<b>virtual</b>&nbsp;<b>void</b>&nbsp;method(<b>char</b>&nbsp;buf[1024]); // does not create a <b>char</b>[1024] (de)serializer <br />
&nbsp;&nbsp;&nbsp;]  <br />
};
</td></tr></table><br></i>
In this example, <i><b>class</b>&nbsp;ns__myClass</i> has three transient fields: <i>b</i>, <i>s</i>, and <i>n</i> which will not be (de)serialized in
SOAP. Field <i>n</i> is transient because the type is declared within a transient block. Pointers, references, and arrays of
transient types are transient.
The single class method is encapsulated within <i>[</i> and <i>]</i> to prevent gSOAP from creating (de)serializers for the
<i><b>char</b>[1024]</i> type. gSOAP will generate (de)serializers for all types that are not declared within a <i>[</i> and <i>]</i>
transient block.

<p>
Functions prototypes of remote methods cannot be declared transient and will result in errors when attempted.

<p>
		     <h3><a name="tth_sEc13.5">
13.5</a>&nbsp;&nbsp;<font color="#0000FF">How to Declare User-Defined Serializers and Deserializers</font></h3><a name="sec:extern">
</a>

<p>
Users can declare their own (de)serializers for specific data types instead of relying on the gSOAP-generated (de)serializers.
To declare a external (de)serializer, declare a type with <i><b>extern</b>&nbsp;<b>typedef</b></i>. gSOAP will not generate the (de)serialzers
for the type name that is declared. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>extern</b>&nbsp;<b>typedef</b>&nbsp;<b>char</b>&nbsp;*MyData; <br />
<b>struct</b>&nbsp;Sample <br />
{ <br />
&nbsp;&nbsp;&nbsp;MyData s; // use user-defined (de)serializer for this field <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*t; // use gSOAP (de)serializer for this field <br />
};
</td></tr></table><br></i>
The user is required to supply the following routines for each <i><b>extern</b>&nbsp;<b>typedef</b></i>'ed name <u>T</u>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;soap_mark_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<u><span class="roman">T</span></u> *a) <br />
<b>void</b>&nbsp;soap_default_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <u><span class="roman">T</span></u> *a) <br />
<b>void</b>&nbsp;soap_out_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <b>int</b>&nbsp;id, <b>const</b>&nbsp;<u><span class="roman">T</span></u> *a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
<u><span class="roman">T</span></u> *soap_in_<u><span class="roman">T</span></u>(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <u><span class="roman">T</span></u> *a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) 
</td></tr></table><br></i>
The function prototypes can be found in <i>soapH.h</i>.

<p>
For example, the (de)serialization of <i>MyData</i> can be done with the following code:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;soap_mark_MyData(<b>struct</b>&nbsp;soap *soap, MyData *<b>const</b>*a) <br />
{ } // no need to mark this node (for multi-ref and cycle detection) <br />
<b>void</b>&nbsp;soap_default_MyData(&amp;soap, MyData **a) <br />
{ *a = NULL } <br />
<b>void</b>&nbsp;soap_out_MyData(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, <b>int</b>&nbsp;id, MyData *<b>const</b>*a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
{ <br />
&nbsp;&nbsp;&nbsp;soap_element_begin_out(soap, tag, id, type); // print XML beginning tag <br />
&nbsp;&nbsp;&nbsp;soap_send(soap, *a); // just print the string (no XML conversion) <br />
&nbsp;&nbsp;&nbsp;soap_element_end_out(soap, tag); // print XML ending tag <br />
} <br />
MyData **soap_in_MyData(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag, MyData **a, <b>const</b>&nbsp;<b>char</b>&nbsp;*type) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_element_begin_in(soap, tag)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!a) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = (MyData**)soap_malloc(soap, <b>sizeof</b>(MyData*)); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>null) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a = NULL; // xsi:nil element <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(*soap<tt>-&gt;</tt>type &amp;&amp; soap_match_tag(soap, soap<tt>-&gt;</tt>type, type)) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>error = SOAP_TYPE_MISMATCH; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; // type mismatch <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(*soap<tt>-&gt;</tt>href) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = (MyData**)soap_id_forward(soap, soap-&#62;href, a, SOAP_MyData, <b>sizeof</b>(MyData*)) <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<b>if</b>&nbsp;(soap<tt>-&gt;</tt>body) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*s = soap_value(soap); // fill buffer <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a = (<b>char</b>*)soap_malloc(soap, strlen(s)+1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(*a, s); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap-&#62;body &amp;&amp; soap_element_end_in(soap, tag)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;a;
</td></tr></table><br></i>
More information on custom (de)serialization will be provided in this document or in a separate document in the future.
The writing of the (de)serializer code requires the use of the low-level gSOAP API.

<p>
		     <h3><a name="tth_sEc13.6">
13.6</a>&nbsp;&nbsp;<font color="#0000FF">How to Serialize Data Without XSD Type Attributes</font></h3>

<p>
gSOAP serializes data in XML with <tt>xsi:type</tt> attributes when the types are
declared with namespace prefixes to indicate the type of the data contained in
the elements. SOAP 1.1 and 1.2 requires <tt>xsi:type</tt> attributes in the
presence of polymorphic data or when the type of the data cannot be deduced
from the SOAP payload.

<p>
To omit the generation of <tt>xsi:type</tt> attributes in the serialization,
simply use type declarations that do not include namespace prefixes. The only
remaining issue is the (de)serialization of lists/vectors with typed elements.
To declare a list/vector with typed elements, use a leading underscores for
type names of the <i><b>struct</b></i> or <i><b>class</b></i>. The leading underscores in
type names makes type anonymous (invisible in XML).

<p>
		     <h3><a name="tth_sEc13.7">
13.7</a>&nbsp;&nbsp;<font color="#0000FF">Function Callbacks for Customized I/O and HTTP Handling</font></h3><a name="sec:callback">
</a>

<p>
gSOAP provides five callback functions for customized I/O and HTTP handling:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b>Callback (function pointer)</b></font> </td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fopen)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>int</b>&nbsp;port)</i> </td></tr>
<tr><td width="602">Called from a client proxy to open a connection to a Web Service located at <i>endpoint</i>.
Input parameters <i>host</i> and <i>port</i> are micro-parsed from <i>endpoint</i>.
Should return a valid file descriptor, or -1 and soap<tt>-&gt;</tt>error set to an error code.
Built-in gSOAP function: <i>tcp_connect</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fpost)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>const</b>&nbsp;<b>char</b>&nbsp;*path, <b>const</b>&nbsp;<b>char</b>&nbsp;*action, size_t
count)</i> </td></tr>
<tr><td width="602">Called from a client proxy to generate the HTTP header to connect to <i>endpoint</i>.
Input parameters <i>host</i> and <i>path</i> are micro-parsed from <i>endpoint</i>, <i>action</i> is the SOAP action,
and <i>count</i> is the length of the SOAP message or 0 when <i>SOAP_ENC_XML</i> is set or when <i>SOAP_IO_LENGTH</i> is reset.
Use function <i>soap_send(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s)</i> to write the header contents.
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>http_post</i>.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fposthdr)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*key, <b>const</b>&nbsp;<b>char</b>&nbsp;*val)</i> </td></tr>
<tr><td width="602">Called by <i>http_post</i> and <i>http_response</i> (through the callbacks).
Emits HTTP <i>key</i>: <i>val</i> header entries.
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>http_post_header</i>.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fresponse)(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;soap_error_code, size_t count)</i> </td></tr>
<tr><td width="602">Called from a service to generate the response HTTP header.
Input parameter <i>soap_error_code</i> is a gSOAP error code (see Section&nbsp;<a href="#sec:errcodes">8.2</a> and
<i>count</i> is the length of the SOAP message or 0 when <i>SOAP_ENC_XML</i> is set or when <i>SOAP_IO_LENGTH</i> is reset.
Use function <i>soap_send(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s)</i> to write the header contents.
Should return SOAP_OK, or a gSOAP error code
Built-in gSOAP function: <i>http_response</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fparse)(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td width="602">Called by client proxy and service to parse an HTTP header (if present).
When user-defined, this routine must at least skip the header.
Use function <i><b>int</b>&nbsp;soap_getline(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*buf, <b>int</b>&nbsp;len)</i> to read HTTP header lines into
a buffer <i>buf</i> of length <i>len</i> (returns empty line at end of HTTP header).
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>http_parse</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fparsehdr)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*key, <b>const</b>&nbsp;<b>char</b>&nbsp;*val)</i> </td></tr>
<tr><td width="602">Called by <i>http_parse</i> (through the <i>fparse</i> callback).
Handles HTTP <i>key</i>: <i>val</i> header entries to set gSOAP's internals.
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>http_parse_header</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fclose)(<b>struct</b>&nbsp;soap *soap)</i> </td></tr>
<tr><td width="602">Called by client proxy <b>multiple times</b>, to close a socket connection before a new socket
connection is established and at the end of communications when the <i>SOAP_IO_KEEPALIVE</i> flag is not set
and <i>soap.keep_alive</i> <font face="symbol"></font
> 0 (indicating that the other party supports keep alive).
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>tcp_disconnect</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap.fsend)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*s, size_t n)</i> </td></tr>
<tr><td width="602">Called for all send operations to emit contents of <i>s</i> of length <i>n</i>.
Should return SOAP_OK, or a gSOAP error code.
Built-in gSOAP function: <i>fsend</i>
</td></tr>
<tr><td width="602"><i>size_t (*soap.frecv)(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s, size_t n)</i> </td></tr>
<tr><td width="602">Called for all receive operations to fill buffer <i>s</i> of maximum length <i>n</i>.
Should return the number of bytes read or 0 in case of an error, e.g.&nbsp;EOF.
Built-in gSOAP function: <i>frecv</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap_fignore)(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag)</i> </td></tr>
<tr><td width="602">Called when an unknown XML element was encountered on the input and <i>tag</i> is the offending XML element tag name.
Should return SOAP_OK, or a gSOAP error code such as SOAP_MUSTUNDERSTAND to throw an exception.
Built-in gSOAP function: <i>fignore</i>
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;(*soap_faccept)(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;sockaddr *a, <b>int</b>&nbsp;*n)</i> </td></tr>
<tr><td width="602">Called by <i>soap_accept</i>. This is a wrapper routine for <i>accept</i>.
Should return a valid socket descriptor or -1 and set soap<tt>-&gt;</tt>error to an error code.
Built-in gSOAP function: <i>tcp_accept</i>
</td></tr></table>

</td></tr></table><br></span>
In addition, a <i><b>void</b>*user</i> field in the <i><b>struct</b>&nbsp;soap</i> data structure is available to pass user-defined data to the callbacks.

<p>
The following example uses I/O function callbacks for customized serialization of data into a buffer and deserialization back into a
datastructure:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>char</b>&nbsp;buf[10000]; // XML buffer <br />
<b>int</b>&nbsp;len1 = 0;	// #chars written <br />
<b>int</b>&nbsp;len2 = 0;	// #chars read <br />
// mysend: put XML in buf[] <br />
<b>int</b>&nbsp;mysend(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*s, size_t n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(len1 + n  &gt;  <b>sizeof</b>(buf)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;strcpy(buf + len1, s); <br />
&nbsp;&nbsp;&nbsp;len1 += n; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
// myrecv: get XML from buf[] <br />
size_t myrecv(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*s, size_t n) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(len2 + n  &gt;  len1) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = len1 - len2; <br />
&nbsp;&nbsp;&nbsp;strncpy(s, buf + len2, n); <br />
&nbsp;&nbsp;&nbsp;len2 += n; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;n; <br />
} <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__person p; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;len1 = len2 = 0;	// reset buffer pointers <br />
&nbsp;&nbsp;&nbsp;p.name = "John Doe"; <br />
&nbsp;&nbsp;&nbsp;p.age = 25; <br />
&nbsp;&nbsp;&nbsp;soap.fsend = mysend; // assign callback <br />
&nbsp;&nbsp;&nbsp;soap.frecv = myrecv; // assign callback <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_set_omode(&amp;soap, SOAP_XML_GRAPH); <br />
&nbsp;&nbsp;&nbsp;soap_serialize_ns__person(&amp;soap, &amp;p); <br />
&nbsp;&nbsp;&nbsp;soap_put_ns__person(&amp;soap, &amp;p, "ns:person", NULL); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_begin(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_get_ns__person(&amp;soap, &amp;p, "ns:person", NULL); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // disable callbacks <br />
}
</td></tr></table><br></i>
The <i>soap_done</i> function can be called to reset the callback to the default internal gSOAP I/O and HTTP handlers.

<p>
The following example illustrates customized I/O and (HTTP) header handling. The SOAP request is saved to a file. The client proxy
then reads the file contents as the service response. To perform this trick, the service response has exactly the same structure as the
request. This is declared by the <i><b>struct</b>&nbsp;ns__test</i> output parameter part of the remote method declaration.
This struct resembles the service request (see the generated <i>soapStub.h</i> file created from the header file).

<p>
The header file is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
//gsoap ns service name: callback <br />
//gsoap ns service namespace: urn:callback <br />
<b>struct</b>&nbsp;ns__person <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;age; <br />
}; <br />
<b>int</b>&nbsp;ns__test(<b>struct</b>&nbsp;ns__person in, <b>struct</b>&nbsp;ns__test &amp;out);
</td></tr></table><br></i>
The client program is:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "soapH.h" <br />
... <br />
<b>int</b>&nbsp;myopen(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>int</b>&nbsp;port) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(strncmp(endpoint, "file:", 5)) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("File name expected<tt>\</tt>n"); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;((soap<tt>-&gt;</tt>sendfd = soap<tt>-&gt;</tt>recvfd = open(host, O_RDWR | O_CREAT, S_IWUSR | S_IRUSR))  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
<b>void</b>&nbsp;myclose(<b>struct</b>&nbsp;soap *soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;if (soap<tt>-&gt;</tt>sendfd  &gt;  2) // still open? <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(soap<tt>-&gt;</tt>sendfd); // then close it <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>recvfd = 0; // set back to stdin <br />
&nbsp;&nbsp;&nbsp;soap<tt>-&gt;</tt>sendfd = 1; // set back to stdout <br />
} <br />
<b>int</b>&nbsp;mypost(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*endpoint, <b>const</b>&nbsp;<b>char</b>&nbsp;*host, <b>const</b>&nbsp;<b>char</b>&nbsp;*path, <b>const</b>&nbsp;<b>char</b>&nbsp;*action, size_t count) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;soap_send(soap, "Custom-generated file<tt>\</tt>n"); // writes to soap<tt>-&gt;</tt>sendfd <br />
} <br />
<b>int</b>&nbsp;myparse(<b>struct</b>&nbsp;soap *soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;buf[256]; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(lseek(soap<tt>-&gt;</tt>recvfd, 0, SEEK_SET)  &lt;  0 || soap_getline(soap, buf, 256)) // go to begin and skip custom header <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOF; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__test r; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;ns__person p; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // reset <br />
&nbsp;&nbsp;&nbsp;p.name = "John Doe"; <br />
&nbsp;&nbsp;&nbsp;p.age = 99; <br />
&nbsp;&nbsp;&nbsp;soap.fopen = myopen; // use custom open <br />
&nbsp;&nbsp;&nbsp;soap.fpost = mypost; // use custom post <br />
&nbsp;&nbsp;&nbsp;soap.fparse = myparse; // use custom response parser <br />
&nbsp;&nbsp;&nbsp;soap.fclose = myclose; // use custom close <br />
&nbsp;&nbsp;&nbsp;soap_call_ns__test(&amp;soap, "file://test.xml", "", p, r); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.error) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stdout); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;soap_end(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); // reset to default callbacks <br />
}
</td></tr></table><br></i>
SOAP 1.1 and 1.2 specify that XML elements may be ignored when present in a SOAP payload on the receiving side.
gSOAP ignores XML elements that are unknown, unless the XML attribute <tt>mustUnderstand="true"</tt> is present in the XML element.
It may be undesirable for elements to be ignored when the outcome of the omission is uncertain.
The <i>soap.fignore</i> callback can be set to a function that returns <i>SOAP_OK</i> in case the element can be safely ignored, or
<i>SOAP_MUSTUNDERSTAND</i> to throw an exception, or to perform some application-specific action.
For example, to throw an exception as soon as an unknown element is encountered on the input, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_MUSTUNDERSTAND; // never skip elements (secure) <br />
} <br />
... <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap);
</td></tr></table><br></i>
To selectively throw an exception as soon as an unknown element is encountered but element <tt>ns:xyz</tt> can be safely ignored, use:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_match_tag(soap, tag, "ns:xyz") != SOAP_OK) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_MUSTUNDERSTAND; <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
... <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) <br />
... <br />
<b>struct</b>&nbsp;Namespace namespaces[] = <br />
{ <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/"}, <br />
&nbsp;&nbsp;&nbsp;{"SOAP-ENC","http://schemas.xmlsoap.org/soap/encoding/"}, <br />
&nbsp;&nbsp;&nbsp;{"xsi", "http://www.w3.org/1999/XMLSchema-instance"}, <br />
&nbsp;&nbsp;&nbsp;{"xsd", "http://www.w3.org/1999/XMLSchema"}, <br />
&nbsp;&nbsp;&nbsp;{"ns", "some-URI"}, // the namespace of element ns:xyz <br />
&nbsp;&nbsp;&nbsp;{NULL, NULL} <br />
</td></tr></table><br></i>
Function <i>soap_match_tag</i> compares two tags. The third parameter may be a pattern where <i>*</i> is a wildcard
and <i>-</i> is a single character wildcard. So for example
<i>soap_match_tag(tag, "ns:*")</i> will match any element in namespace <i>ns</i> or when no namespace prefix is present in the XML
message.

<p>
The callback can also be used to keep track of unknown elements in an internal data structure such as a list:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;Unknown <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*tag; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;Unknown *next; <br />
}; <br />
<b>int</b>&nbsp;myignore(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*tag) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*s = (<b>char</b>*)soap_malloc(soap, strlen(tag)+1); <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;Unknown *u = (<b>struct</b>&nbsp;Unknown*)soap_malloc(soap, <b>sizeof</b>(<b>struct</b>&nbsp;Unknown)); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s &amp;&amp; u) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(s, tag); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u<tt>-&gt;</tt>tag = s; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u<tt>-&gt;</tt>next = ulist; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulist = u; <br />
&nbsp;&nbsp;&nbsp;} <br />
} <br />
... <br />
<b>struct</b>&nbsp;soap *soap; <br />
<b>struct</b>&nbsp;Unknown *ulist = NULL; <br />
soap_init(&amp;soap); <br />
soap.fignore = myignore; <br />
soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) <br />
// print the list of unknown elements <br />
soap_end(&amp;soap); // clean up
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc13.8">
13.8</a>&nbsp;&nbsp;<font color="#0000FF">HTTP 1.0 and 1.1</font></h3>

<p>
gSOAP uses HTTP 1.0 by default. gSOAP supports HTTP 1.1, but does not support all HTTP 1.1 transfer encodings such as gzipped
encodings. gSOAP does support HTTP 1.1 chunked-transfer encoding. Nevertheless, the the HTTP version used can be changed by
setting the attribute:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
... <br />
soap.http_version = "1.1";
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc13.9">
13.9</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Keep-Alive</font></h3><a name="sec:keepalive">
</a>

<p>
gSOAP supports keep-alive socket connections. To activate keep-alive support,
set the <i>SOAP_IO_KEEPALIVE</i> flag for both input and output modes, see Section&nbsp;<a href="#sec:flags">7.10</a>.
For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, SOAP_IO_KEEPALIVE); <br />
</td></tr></table><br></i>
When a client or a service communicates with another client or service that supports keep alive, the
attribute <i>soap.keep_alive</i> will be set to 1, otherwize it is reset to 0 (indicating that the other party 
will close the connection).
The connection maybe terminated on either end before the communication completed, for example when the server keep-alive
connection has timed out.
This generates a "Broken Pipe" signal on Unix/Linux platforms. This signal can be caught with a signal handler:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
signal(SIGPIPE, sigpipe_handle);
</td></tr></table><br></i>
where, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;sigpipe_handle(<b>int</b>&nbsp;x) { }
</td></tr></table><br></i>
Alternatively, broken pipes can be kept silent by setting:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap.socket_flags = MSG_NOSIGNAL;
</td></tr></table><br></i>
This setting will not generate a sigpipe but read/write operations return <i>SOAP_EOF</i> instead.
Note that Win32 systems do not support signals and lack the <i>MSG_NOSIGNAL</i> flag.
The sigpipe handling and flags are not very portable.

<p>
A connection will be kept open only if the request contains an HTTP 1.0 header
with "<tt>Connection: Keep-Alive</tt>" or an HTTP 1.1 header that does not contain
"<tt>Connection: close</tt>". This means that a gSOAP client method call should
use "<tt>http://</tt>" in the endpoint URL of the request to the stand-alone
service to ensure HTTP headers are used.

<p>
If the client does not close the connection, the server will wait forever when
no <i>recv_timeout</i> is specified.  In addition, other clients will be denied
service as long as a client keeps the connection to the server open.  To
prevent this from happening, the service should be multi-threaded such that
each thread handles the client connection:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main(<b>int</b>&nbsp;argc, <b>char</b>&nbsp;**argv) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap, *tsoap; <br />
&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;int m, s; <br />
&nbsp;&nbsp;&nbsp;soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, SOAP_IO_KEEPALIVE); <br />
&nbsp;&nbsp;&nbsp;soap.accept_timeout = 600; // optional: let server time out after ten minutes of inactivity <br />
&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, NULL, 18000, BACKLOG); // use port 18000 on the current machine <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Socket connection successful %d\n"</tt>, m); <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(count = 0; count  &gt; = 0; count++) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.socket_flags = MSG_NOSIGNAL; // use this <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap.accept_flags = SO_NOSIGPIPE; // or this to prevent sigpipe <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap.errnum) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Server timed out\n"</tt>); // Assume timeout is long enough for threads to complete serving requests <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>break</b>; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, <tt>"Accepts socket %d connection from IP %d.%d.%d.%d\n"</tt>, s, (<b>int</b>)(soap.ip &gt;&gt; 24)&amp;0xFF, (<b>int</b>)(soap.ip &gt;&gt; 16)&amp;0xFF, (<b>int</b>)(soap.ip &gt;&gt; 8)&amp;0xFF, (<b>int</b>)soap.ip&amp;0xFF); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap = soap_copy(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, (void*(*)(void*))process_request, (void*)tsoap); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>void</b>&nbsp;*process_request(<b>void</b>&nbsp;*soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;pthread_detach(pthread_self()); <br />
&nbsp;&nbsp;&nbsp;((<b>struct</b>&nbsp;soap*)soap)-&#62;recv_timeout = 300; // Timeout after 5 minutes stall on recv <br />
&nbsp;&nbsp;&nbsp;((<b>struct</b>&nbsp;soap*)soap)-&#62;send_timeout = 60; // Timeout after 1 minute stall on send <br />
&nbsp;&nbsp;&nbsp;soap_serve((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_destroy((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_end((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_done((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
}
</td></tr></table><br></i>
To prevent a malicious client from keeping a thread waiting forever by keeping
the connection open, timeouts are set in the <i>process_request</i> routine.
See Section&nbsp;<a href="#sec:timeout">13.14</a> for more details on timeout settings.

<p>
A gSOAP client call will automatically attempt to re-establish a connection to
a server when the server has terminated the connection for any reason.  This
way, a sequence of calls can be made to the server while keeping the connection
open.  Client stubs will poll the server to check if the connection is still
open.  When the connection was terminated by the server, the client will
automatically reconnect.  

<p>
A client should reset <i>SOAP_IO_KEEPALIVE</i> just before the last call to a
server to close the connection after this last call. This will close the socket
after the call and also informs the server to gracefully close the connection.

<p>
	     <h3><a name="tth_sEc13.10">
13.10</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Chunked Transfer Encoding</font></h3>

<p>
gSOAP supports HTTP chunked transfer encoding. Un-chunking of inbound messages
takes place automatically. Outbound messages are never chunked, except when the
<i>SOAP_IO_CHUNK</i> flag is set for the output mode.  Most Web services,
however, will not accept chunked inbound messages.

<p>
	     <h3><a name="tth_sEc13.11">
13.11</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Buffered Sends</font></h3>

<p>
The entire outbound message can be stored to determine the HTTP content length
rather than the two-phase encoding used by gSOAP which requires a separate pass
over the data to determine the length of the outbound message.  Setting the
flag <i>SOAP_IO_STORE</i> for the output mode will buffer the entire message.
This can speed up the transmission of messages, depending on the content, but
may require significant storage space to hold the verbose XML message.

<p>
Zlib compressed transfers require buffering. The <i>SOAP_IO_STORE</i> flag is
set when the <i>SOAP_ENC_ZLIB</i> flag is set to send compressed messages. The use of chunking
significantly reduces memory usage and may speed up the transmission of compressed SOAP/XML messages.
This is accomplished by setting the <i>SOAP_IO_CHUNK</i> flag with
<i>SOAP_ENC_ZLIB</i> for the output mode.

<p>
	     <h3><a name="tth_sEc13.12">
13.12</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Authentication</font></h3>

<p>
HTTP authentication (basic) is enabled at the client-side by setting the
<i>soap.userid</i> and <i>soap.passwd</i> strings to a username and password,
respectively.  For example, a server may request user authentication.
Otherwise, access is denied (HTTP 401 error).  Example client code fragment to
set username and password:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.userid = "guest"; <br />
soap.passwd = "guest"; <br />
...
</td></tr></table><br></i>
A client SOAP request will have the following HTTP header:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /XXX HTTP/1.0 <br />
Host: YYY <br />
User-Agent: gSOAP/2.2 <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Length: nnn <br />
Authorization: Basic Z3Vlc3Q6Z3Vlc3Q= <br />
...
</td></tr></table><br></tt>

<p>
	     <h3><a name="tth_sEc13.13">
13.13</a>&nbsp;&nbsp;<font color="#0000FF">HTTP Proxy Authentication</font></h3>

<p>
HTTP proxy authentication (basic) is enabled at the client-side by setting the
<i>soap.proxy_userid</i> and <i>soap.proxy_passwd</i> strings to a username and
password, respectively.  For example, a proxy server may request user
authentication. Otherwise, access is denied by the proxy (HTTP 407 error).
Example client code fragment to set proxy server, username, and password:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.proxy_host = "xx.xx.xx.xx"; // IP <br />
soap.proxy_port = 8080; <br />
soap.proxy_userid = "guest"; <br />
soap.proxy_passwd = "guest"; <br />
...
</td></tr></table><br></i>
A client SOAP request will have the following HTTP header:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0B0D0"><tr><td><tt>
POST /XXX HTTP/1.0 <br />
Host: YYY <br />
User-Agent: gSOAP/2.2 <br />
Content-Type: text/xml; charset=utf-8 <br />
Content-Length: nnn <br />
Proxy-Authorization: Basic Z3Vlc3Q6Z3Vlc3Q= <br />
...
</td></tr></table><br></tt>

<p>
	     <h3><a name="tth_sEc13.14">
13.14</a>&nbsp;&nbsp;<font color="#0000FF">Timeout Management for Non-Blocking Operations</font></h3><a name="sec:timeout">
</a>

<p>
Socket connect, accept, send, and receive timeout values can be set to manage
socket communication timeouts.  The <i>soap.connect_timeout</i>,
<i>soap.accept_timeout</i>, <i>soap.send_timeout</i>, and
<i>soap.recv_timeout</i> attributes of the current gSOAP runtime environment
<i>soap</i> can be set to the appropriate user-defined socket send, receive, and
accept timeout values.  A positive value measures the timeout in seconds. A
negative timeout value measures the timeout in microseconds (10<sup><font face="symbol">-</font
>6</sup> sec).

<p>
The <i>soap.connect_timeout</i> specifies the timeout value for
<i>soap_call_ns__method</i> calls.

<p>
The <i>soap.accept_timeout</i> specifies the timeout value for
<i>soap_accept(&amp;soap)</i> calls.

<p>
The <i>soap.send_timeout</i> and <i>soap.recv_timeout</i> specify the timeout
values for non-blocking socket I/O operations.

<p>
Example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.send_timeout = 10; <br />
soap.recv_timeout = 10; 
</td></tr></table><br></i>
This will result in a timeout if no data can be send in 10 seconds and no data is received within 10 seconds after initiating
a send or receive operation over the socket. A value of zero disables timeout, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap.send_timeout = 0; <br />
soap.recv_timeout = 0; 
</td></tr></table><br></i>
When a timeout occurs in send/receive operations, a <i>SOAP_EOF</i> exception will be raised (``end of file or no input'').
Negative timeout values measure timeouts in microseconds, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define uSec *-1 <br />
#define mSec *-1000 <br />
soap.accept_timeout = 10 uSec; <br />
soap.send_timeout = 20 mSec; <br />
soap.recv_timeout = 20 mSec;
</td></tr></table><br></i>
The macros improve readability.

<p>
<font color="#FF0000"><b>Caution</b></font>: Many Linux versions do not support non-blocking <i>connect()</i>. Therefore, setting <i>soap.connect_timeout</i> for
non-blocking <i>soap_call_ns__method</i> calls may not work under Linux.

<p>
	     <h3><a name="tth_sEc13.15">
13.15</a>&nbsp;&nbsp;<font color="#0000FF">Socket Options and Flags</font></h3>

<p>
gSOAP's socket communications can be controlled with socket options and flags.
The gSOAP run-time environment <i><b>struct</b>&nbsp;soap</i> flags are:
<i><b>int</b>&nbsp;soap.socket_flags</i> to control socket send() and recv() calls,
<i><b>int</b>&nbsp;soap.connect_flags</i> to set client connection socket options,
<i><b>int</b>&nbsp;soap.bind_flags</i> to set server-side port bind socket options,
<i><b>int</b>&nbsp;soap.accept_flags</i> to set server-side request message accept
socket options. See the manual pages of <i>send</i> and <i>recv</i> for
<i>soap.socket_flags</i> values and see the manual pages of
<i>setsockopt</i> for
<i>soap.connect_flags</i>, <i>soap.bind_flags</i>, and
<i>soap.accept_flags</i> (SOL_SOCKET) values.
These <i>SO_</i> socket option flags (see <i>setsockopt</i> manual pages)
can be bit-wise or-ed to set multiple
socket options at once.

<p>
For example, to disable sigpipe signals on Unix/Linux platforms use: 
<i>soap.socket_flags=MSG_NOSIGNAL</i> and/or
<i>soap.connect_flags=SO_NOSIGPIPE</i> (i.e.&nbsp;client-side connect) depending
on your platform.

<p>
Use <i>soap.bind_flags=SO_REUSEADDR</i> to enable server-side port reuse and
local port
sharing (but be aware of the security issues when the port is not blocked by a
firewall and open to the Internet).

<p>
	     <h3><a name="tth_sEc13.16">
13.16</a>&nbsp;&nbsp;<font color="#0000FF">Secure SOAP Clients with HTTPS/SSL</font></h3>

<p>
You need to install the OpenSSL library on your platform to enable secure SOAP clients to utilize HTTPS/SSL.
After installation, compile all the sources of your application with option <i>-DWITH_OPENSSL</i>. For example on Linux:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lssl -lcrypto</i>
</td></tr></table><br></span>
or Unix:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lxnet -lsocket -lnsl -lssl -lcrypto</i>
</td></tr></table><br></span>
or you can add the following line to <i>soapdefs.h</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_OPENSSL
</td></tr></table><br></i>
and compile with option <i>-DWITH_SOAPDEFS_H</i> to include <i>soapdefs.h</i> in your project.
A client program simply uses the prefix <i>https:</i> instead of <i>http:</i> in the endpoint URL of a remote method call to a
Web Service to use encrypted transfers (if the service supports HTTPS).
For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_call_ns__mymethod(&amp;soap, "https://domain/path/secure.cgi", "", ...);
</td></tr></table><br></i>

<p>
By default, server authentication is disabled. To enable server authentication, set the <i>require_server_auth</i> attribute of
the current gSOAP runtime environment (<i><b>struct</b>&nbsp;soap</i>) before a call is made:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap.require_server_auth = 1;
</td></tr></table><br></i>
This will force server authentication for all calls over HTTPS.

<p>
Make sure you have signal handlers set in your application to catch broken connections (<i>SIGPIPE</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
signal(SIGPIPE, sigpipe_handle);
</td></tr></table><br></i>
where, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;sigpipe_handle(<b>int</b>&nbsp;x) { }
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc13.17">
13.17</a>&nbsp;&nbsp;<font color="#0000FF">Secure SOAP Web Services with HTTPS/SSL</font></h3>

<p>
When a Web Service is installed as CGI, it uses standard I/O that is encryped/decrypted by the Web server that runs the CGI
application.
Therefore, HTTPS/SSL support must be configured for the Web server (not Web Service).

<p>
SSL support for stand-alone gSOAP Web services is accomplished by calling <i>soap_ssl_accept</i> after <i>soap_accept</i>.
In addition, a key file, CA file, DH file (if RSA is not used), and password need to be supplied. Instructions on how to do this can be found in the
OpenSSL documentation <i>http://www.openssl.org</i>. See also Section&nbsp;<a href="#sec:ssl">13.18</a>.
To enable OpenSSL, first install OpenSSL and use option <i>-DWITH_OPENSSL</i> to compile the sources with your C or C++ compiler, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_OPENSSL -o myprog myprog.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lssl -lcrypto</i>
</td></tr></table><br></span>
Let's take a look at an example SSL secure
multi-threaded stand-alone SOAP Web Service:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;pthread_t tid; <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap, *tsoap; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;// soap.rsa = 1; // use RSA (or use DH which requires a DH file: see below) <br />
&nbsp;&nbsp;&nbsp;soap.keyfile = "server.pem"; // must be resident key file <br />
&nbsp;&nbsp;&nbsp;soap.cafile = "cacert.pem"; // must be resident CA file <br />
&nbsp;&nbsp;&nbsp;soap.dhfile = "dh512.pem"; // if soap.rsa == 0, use DH with resident DH file <br />
&nbsp;&nbsp;&nbsp;soap.password = "password"; // password <br />
&nbsp;&nbsp;&nbsp;soap.randfile = "random.rnd"; // (optional) some file with random data to seed PRNG <br />
&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, "linprog2.cs.fsu.edu", 18000, 100); <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;fprintf(stderr, "Socket connection successful: master socket = %d<tt>\</tt>n", m); <br />
&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(;;) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, "Socket connection successful: slave socket = %d<tt>\</tt>n", s); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(soap_ssl_accept(&amp;soap)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsoap = soap_copy(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!tsoap) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;tid, NULL, &amp;process_request, (<b>void</b>*)tsoap); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
}  <br />
<b>void</b>&nbsp;*process_request(<b>void</b>&nbsp;*soap) <br />
{ <br />
&nbsp;&nbsp;&nbsp;pthread_detach(pthread_self()); <br />
&nbsp;&nbsp;&nbsp;soap_serve((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;soap_end((<b>struct</b>&nbsp;soap*)soap); <br />
&nbsp;&nbsp;&nbsp;free(soap); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;NULL; <br />
}
</td></tr></table><br></i>
In case Web services have to verify clients, use a key file, CA file, a file with random data, and password in an SSL-enabled client:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
... <br />
soap_init(&amp;soap); <br />
soap.keyfile = "client.pem"; <br />
soap.password = "password"; <br />
soap.cafile = "cacert.pem"; <br />
soap.randfile = "random.rnd"; <br />
<b>if</b>&nbsp;(soap_call_ns__method(&amp;soap, "https://linprog2.cs.fsu.edu:18000", "", ...) <br />
...
</td></tr></table><br></i>
Make sure you have signal handlers set in your service and/or client applications to catch broken connections (<i>SIGPIPE</i>):
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
signal(SIGPIPE, sigpipe_handle);
</td></tr></table><br></i>
where, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>void</b>&nbsp;sigpipe_handle(<b>int</b>&nbsp;x) { }
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc13.18">
13.18</a>&nbsp;&nbsp;<font color="#0000FF">SSL Certificates</font></h3><a name="sec:ssl">
</a>

<p>
The <i>.pem</i> files in the gSOAP distribution are examples.
Developers will have to generate certificates as needed (client
only, server only or both).
There is more than one way to generate pem files for clients and servers.
Here is the simplest/quickest one:

<p>
Create a private Certificate Authority (CA).
The CA is used in SSL to verify the authenticity of a given
certificate. The CA acts as a trusted third party who has authenticated the
user of the signed certificate as being who they say. The certificate is
signed by the CA, and if the client trusts the CA, it will trust your
certificate. For use within your organization, a private CA will probably
serve your needs. However, if you intend use your certificates for a public
service, you should probably obtain a certificate from a known CA (e.g.&nbsp;VeriSign).
In addition to identification, your certificate is also used for encryption.

<p>
Creating a private CA:

<ul><p>
<li> Go to the OpenSSL bin directory (<i>/usr/local/ssl/misc</i> by default and
<i>/System/Library/OpenSSL/misc</i> on Mac OS X).</li>
<p>
<li> There should be a script called CA.sh (and a CA.pl that does the
same stuff). This hides all the gruesome details of how this works. Without
the script this is a very annoying process.</li>
<p>
<li>       su to root</li>
<p>
<li>       Make sure that the OpenSSL bin directory is in your path.</li>
<p>
<li>       <i>./CA.sh -newca</i></li>
<p>
<li>       When prompted for CA filename hit return.</li>
<p>
<li>       Answer the rest of the questions intelligently. The common name
would be how this certificate might be referred to. For example, the
Equifax Secure CA uses the common name of Equifax Secure
Certificate Authority.
Do not forget the password!</li>
</ul>
Creating certificates should be done through a certificate authority to obtain signed certificates. But you can create your own certificates for testing purposes as follows.

<ul><p>
<li>       <i>./CA.sh -newreq</i></li>
<p>
<li>       This creates an unsigned certificate request.</li>
<p>
<li>       The procedure is the same as creating a private CA except you'll
want to use the name of the host that will use the certificate as the
common name. If they don't match, the client
will not like it when you set <i>require_server_auth=1</i>.</li>
<p>
<li>       You probably don't want to use the same passphrase for this as you
did with the CA.</li>
<p>
<li>       <i>./CA.sh -sign</i></li>
<p>
<li>       It will ask for a PEM pass phrase, that's the passphrase you set
for the private CA you created.</li>
<p>
<li>       This signs the certificate that you just created with the CA you
created just moments before.</li>
<p>
<li>       The signed certificate is now in the current directory as
newcert.pem. If you are going to create more, you should rename this or it
will be overwritten be subsequent signatures.</li>
</ul>
Now do the following at the prompt:

<p>
<i>cat newreq.pem newcert.pem  &gt;  server.pem</i> (or client.pem as needed)

<p>
You now have generated a client and a server certificate in PEM format by
repeating the same process and changing the common name for the client
(e.g.&nbsp;gSOAP client). You also need the CA certificate.

<p>
Finally you need to generate Diffie-Helmann parameters for the server.
Do the following at the prompt:

<p>
<i>openssl dhparam -outform PEM -out dh.pem 1024</i>

<p>
File <i>dh.pem</i> is the output file and 1024 is the number of
bits used (this will take a long time, you can safely use 512).

<p>
Of course the developer using your server cert on her machine will find
that if <i>require_server_auth=1</i> the client will exit before doing
the handshake.

<p>
	     <h3><a name="tth_sEc13.19">
13.19</a>&nbsp;&nbsp;<font color="#0000FF">Zlib Compressed Messages</font></h3><a name="sec:compression">
</a>

<p>
To enable deflate and gzip compression with Zlib, install Zlib from <tt>http://www.zlib.org</tt> if not
already installed on your system.  Compile <i>stdsoap2.cpp</i> (and/or
<i>stdsoap2.c</i>) with compiler option <i>-DWITH_GZIP</i> and link your code
with the Zlib library, e.g. <i>-lz</i> on Unix/Linux platforms.

<p>
The gzip compression is orthogonal to all transport encodings such as HTTP,
SSL, DIME, and can be used with other transport layers.
You can even save and load compressed XML data to/from files.

<p>
gSOAP supports two compression formats: deflate and gzip. The gzip format is used by default. The gzip format has several benefits over deflate. Firstly, gSOAP can automatically detect gzip compressed inbound messages, even without HTTP headers, by checking for the presence of a gzip header in the message content. Secondly, gzip includes a CRC32 checksum to ensure messages have been correctly received. Thirdly, gzip compressed content can be decompressed with other compression software, so you can decompress XML data saved by gSOAP in gzip format.

<p>
Gzip compression is enabled by compiling the sources with <i>-DWITH_GZIP</i>.
To transmit gzip compressed SOAP/XML data, set the output mode flags to
<i>SOAP_ENC_ZLIB</i>. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_init(&amp;soap); <br />
... <br />
soap_set_omode(&amp;soap, SOAP_ENC_ZLIB); // enable gzip <br />
<b>if</b>&nbsp;(soap_call_ns__myMethod(&amp;soap, ...)) <br />
... <br />
soap_clr_omode(&amp;soap, SOAP_ENC_ZLIB); // disable gzip <br />
...
</td></tr></table><br></i>
This will send a compressed SOAP/XML request to a service, privided that Zlib is
installed and linked with the application and the <i>-DWITH_GZIP</i> option was used to compile the sources.
Receiving compressed SOAP/XML over HTTP either in gzip or deflate formats is automatic. The <i>SOAP_ENC_ZLIB</i> flag does not have
to be set at the server side to accept compressed messages. Reading and receiving gzip compressed SOAP/XML without HTTP headers (e.g. with other transport protocols) is also automatic.

<p>
To control the level of compression of outbound messages, set the <i>soap.z_level</i> to a value between 1 and 9, where 1 is the best speed and 9 is the best compression (default is 6).  For example
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_init(&amp;soap); <br />
... <br />
soap_set_omode(&amp;soap, SOAP_ENC_ZLIB); <br />
soap.z_level = 9; // best compression <br />
...
</td></tr></table><br></i>

<p>
To restrict compression to the deflate format, compile the sources with <i>-DWITH_ZLIB</i>. This limits compression and decompression to the deflate format only. Only plain and deflated messages can be exchanged, gzip is not supported with this option.
Receiving deflate compressed content is not automatic in the absence of HTTP headers and requires the flag
<i>SOAP_ENC_ZLIB</i> to be set for the input mode to decompress deflated data.

<p>
Compressed transfers require buffering the entire output message to determine HTTP message length.
This means that the <i>SOAP_IO_STORE</i> flag is
automatically set when the <i>SOAP_ENC_ZLIB</i> flag is set to send compressed messages. The use of HTTP chunking
significantly reduces memory usage and may speed up the transmission of compressed SOAP/XML messages.
This is accomplished by setting the <i>SOAP_IO_CHUNK</i> flag with
<i>SOAP_ENC_ZLIB</i> for the output mode.
However, some Web servers do not accept HTTP chunked request messages (even when they return HTTP chunked messages!). Stand-alone gSOAP services always accept chunked request messages.

<p>
	     <h3><a name="tth_sEc13.20">
13.20</a>&nbsp;&nbsp;<font color="#0000FF">Client-Side Cookie Support</font></h3><a name="sec:clientcookie">
</a>

<p>
Client-side cookie support is optional. To enable cookie support, compile all sources with option <i>-DWITH_COOKIES</i>, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_COOKIES -o myclient stdsoap2.cpp soapC.cpp soapClient.cpp</i>
</td></tr></table><br></span>
or add the following line to <i>stdsoap.h</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_COOKIES
</td></tr></table><br></i>
Client-side cookie support is fully automatic. So just (re)compile <i>stdsoap2.cpp</i> with <i>-DWITH_COOKIES</i> to enable
cookie-based session control in your client.

<p>
A database of cookies is kept and returned to the appropriate servers.
Cookies are not automatically saved to a file by a client. An example cookie
file manager is included as an extras in the distribution. You should
explicitly remove all cookies before terminating a gSOAP environment by
calling <i>soap_free_cookies(soap)</i> or by calling <i>soap_done(soap)</i>.

<p>
To avoid "cookie storms" caused by malicious servers that return an 
unreasonable amount of cookies, gSOAP clients/servers are restricted to
a database size that the user can limit (32 cookies by default), for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.cookie_max = 10;
</td></tr></table><br></i>
The cookie database is a linked list pointed to by <i>soap.cookies</i> where each node is declared as:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap_cookie <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*name; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*value; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*domain; <br />
&nbsp;&nbsp;&nbsp;<b>char</b>&nbsp;*path; <br />
&nbsp;&nbsp;&nbsp;<b>long</b>&nbsp;expire; /* client-side: local time to expire; server-side: seconds to expire */ <br />
&nbsp;&nbsp;&nbsp;<b>unsigned</b>&nbsp;<b>int</b>&nbsp;version; <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;secure; <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;session; /* server-side */ <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;env; /* server-side: 1 = got cookie from client */ <br />
&nbsp;&nbsp;&nbsp;<b>short</b>&nbsp;modified; /* server-side: 1 = client cookie was modified */ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap_cookie *next; <br />
};
</td></tr></table><br></i>
Since the cookie database is linked to a <i>soap</i> struct, each thread has a local cookie database in a multi-threaded
implementation.

<p>
	     <h3><a name="tth_sEc13.21">
13.21</a>&nbsp;&nbsp;<font color="#0000FF">Server-Side Cookie Support</font></h3><a name="sec:servercookie">
</a>

<p>
Server-side cookie support is optional. To enable cookie support, compile all sources with option <i>-DWITH_COOKIES</i>, for example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i>g++ -DWITH_COOKIES -o myserver ...</i>
</td></tr></table><br></span>
gSOAP provides the following cookie API for server-side cookie session control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td width="602"><font color="#FF0000"><b>Function</b></font> </td></tr>
<tr><td width="602"><i><b>struct</b>&nbsp;soap_cookie *soap_set_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*value, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Add a cookie to the database with name <i>name</i> and value <i>value</i>.
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns pointer to a cookie node in the linked list, or NULL otherwise.
</td></tr>
<tr><td width="602"><i><b>struct</b>&nbsp;soap_cookie *soap_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Find a cookie in the database with name <i>name</i> and value <i>value</i>.
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns pointer to a cookie node in the linked list, or NULL otherwise.
</td></tr>
<tr><td width="602"><i><b>char</b>&nbsp;*soap_cookie_value(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Get value of a cookie in the database with name <i>name</i>.
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns the string pointer to the value, or NULL otherwise.
</td></tr>
<tr><td width="602"><i><b>long</b>&nbsp;soap_cookie_expire(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Get expiration value of the cookie in the database with name <i>name</i> (in seconds).
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
Returns the expiration value, or -1 if cookie does not exist.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;soap_set_cookie_expire(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>long</b>&nbsp;expire, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Set expiration value <i>expire</i> of the cookie in the database with name <i>name</i> (in seconds).
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;soap_set_cookie_session(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Set cookie in the database with name <i>name</i> to be a session cookie.
This means that the cookie will be returned to the client.
(Only cookies that are modified are returned to the client).
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;soap_clr_cookie_session(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Clear cookie in the database with name <i>name</i> to be a session cookie.
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise.
</td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;soap_clr_cookie(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*name, <b>const</b>&nbsp;<b>char</b>&nbsp;*domain, <b>const</b>&nbsp;<b>char</b>&nbsp;*path);</i> </td></tr>
<tr><td width="602">Remove cookie from the database with name <i>name</i>.
<i>domain</i> and <i>path</i> may be NULL to use the current domain and path given by <i>soap_cookie_domain</i> and <i>soap_cookie_path</i>.
</td></tr>
<tr><td width="602"><i><b>int</b>&nbsp;soap_getenv_cookies(<b>struct</b>&nbsp;soap *soap);</i> </td></tr>
<tr><td width="602">Initializes cookie database by reading the 'HTTP_COOKIE' environment variable.
This provides a means for a CGI application to read cookies send by a client.
If successful, returns <i>SOAP_OK</i>, or <i>SOAP_EOF</i> otherwise.
</td></tr>
<tr><td width="602"><i><b>void</b>&nbsp;soap_free_cookies(<b>struct</b>&nbsp;soap *soap);</i> </td></tr>
<tr><td width="602">Release cookie database. </td></tr></table>

</td></tr></table><br></span>
The following global variables are used to define the current domain and path:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">

<table>
<tr><td><font color="#FF0000"><b>Attribute</b></font> </td><td><font color="#FF0000"><b>value</b></font> </td></tr>
<tr><td><i><b>const</b>&nbsp;<b>char</b>&nbsp;*cookie_domain</i> </td><td>MUST be set to the domain (host) of the service </td></tr>
<tr><td><i><b>const</b>&nbsp;<b>char</b>&nbsp;*cookie_path</i> </td><td>MAY be set to the default path to the service </td></tr>
<tr><td><i><b>int</b>&nbsp;cookie_max</i> </td><td>maximum cookie database size (default=32) </td></tr></table>

</td></tr></table><br></span>
The <i>cookie_path</i> value is used to filter cookies intended for this service according to the path prefix rules outlined in
RFC2109.

<p>
The following example server adopts cookies for session control:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>int</b>&nbsp;main() <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;soap soap; <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;m, s; <br />
&nbsp;&nbsp;&nbsp;soap_init(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;soap.cookie_domain = "..."; <br />
&nbsp;&nbsp;&nbsp;soap.cookie_path = "/"; // the path which is used to filter/set cookies with this destination <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(argc  &lt;  2) <br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_getenv_cookies(&amp;soap); // CGI app: grab cookies from 'HTTP_COOKIE' env var <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>else</b><br />
&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = soap_bind(&amp;soap, NULL, atoi(argv[1]), 100); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(m  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b>&nbsp;(<b>int</b>&nbsp;i = 1; ; i++) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = soap_accept(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(s  &lt;  0) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_serve(&amp;soap); <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_end(&amp;soap);		// clean up  <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soap_free_cookies(&amp;soap);	// remove all old cookies from database so no interference occurs with the arrival of new cookies <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;0; <br />
} <br />
<b>int</b>&nbsp;ck__demo(<b>struct</b>&nbsp;soap *soap, ...) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;n; <br />
&nbsp;&nbsp;&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;*s; <br />
&nbsp;&nbsp;&nbsp;s = soap_cookie_value(soap, "demo", NULL, NULL); // cookie returned by client? <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(!s) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = "init-value"; // no: set initial cookie value <br />
&nbsp;&nbsp;&nbsp;<b>else</b>&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... // modify 's' to reflect session control <br />
&nbsp;&nbsp;&nbsp;soap_set_cookie(soap, "demo", s, NULL, NULL); <br />
&nbsp;&nbsp;&nbsp;soap_set_cookie_expire(soap, "demo", 5, NULL, NULL); // cookie may expire at client-side in 5 seconds <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
}
</td></tr></table><br></i>

<p>
	     <h3><a name="tth_sEc13.22">
13.22</a>&nbsp;&nbsp;<font color="#0000FF">Connecting Clients Through Proxy Servers</font></h3>

<p>
When a client needs to connect to a Web Service through a proxy server, set the <i>soap.proxy_host</i> string and
<i>soap.proxy_port</i> integer attributes of the current <i>soap</i> runtime environment to the proxy's host name and port, respectively. For example:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap.proxy_host = "proxyhostname"; <br />
soap.proxy_port = 8080; <br />
<b>if</b>&nbsp;(soap_call_ns__method(&amp;soap, "http://host:port/path", "action", ...)) <br />
&nbsp;&nbsp;&nbsp;soap_print_fault(&amp;soap, stderr); <br />
<b>else</b><br />
&nbsp;&nbsp;&nbsp;...
</td></tr></table><br></i>
The attributes <i>soap.proxy_host</i> and <i>soap.proxy_port</i> keep their values throug the remove method calls,
so they only need to be set once.

<p>
	     <h3><a name="tth_sEc13.23">
13.23</a>&nbsp;&nbsp;<font color="#0000FF">FastCGI Support</font></h3>

<p>
To enable FastCGI support, install FastCGI and compile with option <i>-DWITH_FASTCGI</i> or add
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#define WITH_FASTCGI
</td></tr></table><br></i>
to <i>stdsoap2.h</i>.

<p>
	     <h3><a name="tth_sEc13.24">
13.24</a>&nbsp;&nbsp;<font color="#0000FF">How to Create Separate Client/Server DLLs</font></h3>

<p>
		      <h4><a name="tth_sEc13.24.1">
13.24.1</a>&nbsp;&nbsp;<font color="#0000FF">Create Base stdsoap2.dll</font></h4>

<p>
The first step is to create <i>stdsoap2.dll</i> which consists of the file
<i>stdsoap2.cpp</i> and <i>envC.cpp</i>. This DLL contains all common functions needed for
all other clients and servers based on gSOAP.
<i>envC.cpp</i> is a generated file from an <em>empty</em> input file to the <i>soapcpp2</i>:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
Create an empty header file <i>empty.h</i> <br />
(If necessary, add appropriate SOAP Header definitions used by all clients and services) <br />
<i>soapcpp2 -penv empty.h</i> <br />
Compile <i>envC.cpp</i> and <i>stdsoap2.cpp</i> into <i>stdsoap2.dll</i> using the compiler option <i>-DWITH_NONAMESPACES</i>
</td></tr></table><br></span>
This file contains all the envelope functions required,
so that <i>stdsoap2.dll</i> includes the appropriate function definitions.

<p>
While compiling this project, use the Pre-Processor definition:
<i>SOAP_FMAC1=__declspec(dllexport)</i>, or set the macro as an option <i>-DSOAP_FMAC1=__declspec(dllexport)</i>, or compile
with <i>-DWITH_SOAPDEFS_H</i> and put the macro definitions in <i>soapdefs.h</i>.
This exports
all functions which are preceded by the macro <i>SOAP_FMAC1</i> in the source
files.

<p>
		      <h4><a name="tth_sEc13.24.2">
13.24.2</a>&nbsp;&nbsp;<font color="#0000FF">Creating Client and Service DLLs</font></h4>

<p>
Client side DLL serves as the common code which all clients will use to
access the server. This DLL consists of the files <i>soapC.cpp</i> and <i>soapClient.cpp</i>
and other wrapper files, which if needed, to abstract the gSOAP details from
the clients. (These wrapper methods are then exported. If we dont want to
write the wrapper methods, we can directly export the functions in
<i>soapClient.cpp</i> with using the Pre-Processor definition:
<i>SOAP_FMAC1=__declspec(dllexport)</i>.
Compile the DLL with option <i>-DWITH_NOGLOBAL</i>.
This DLL links to <i>stdsoap2.dll</i>.

<p>
Clients MUST explicitly set the namespaces value of the gSOAP environment:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
soap_init(&amp;soap); <br />
soap.namespaces = namespaces;
</td></tr></table><br></i>
where the <i>namespaces[]</i> table is defined (static) in the client source.

<p>
A service side DLL is similar.
This DLL consists of the files <i>soapC.cpp</i> and <i>soapServer.cpp</i>.
Use the Pre-Processor definition:
<i>SOAP_FMAC1=__declspec(dllexport)</i>.
Compile the DLL with option <i>-DWITH_NOGLOBAL</i>.
This DLL links to <i>stdsoap2.dll</i>.
Also the namespaces table MUST be explicitly set in the service code.

<p>
		      <h4><a name="tth_sEc13.24.3">
13.24.3</a>&nbsp;&nbsp;<font color="#0000FF">gSOAP Plug-ins</font></h4>

<p>
The gSOAP plug-in feature enables a convenient extension mechanism of gSOAP
capabilities. When the plug-in registers with gSOAP, it has full access
to the run-time settings and the gSOAP function callbacks.
Upon registry, the plug-in's local data is associated with the gSOAP run-time.
By overriding gSOAP's function callbacks with the plug-in's function callbacks,
the plug-in can extend gSOAP's capabilities. The local plug-in data can be
accessed through a lookup function, usually invoked within a callback function
to access the plug-in data. 
The registry and lookup functions are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i><b>int</b>&nbsp;soap_register_plugin_arg(<b>struct</b>&nbsp;soap *soap, <b>int</b>&nbsp;(*fcreate)(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *p, <b>void</b>&nbsp;*arg), <b>void</b>&nbsp;*arg)</i> <br />
<i><b>void</b>* soap_lookup_plugin(<b>struct</b>&nbsp;soap*, <b>const</b>&nbsp;<b>char</b>*);</i>
</td></tr></table><br></span>
Other functions that deal with plug-ins are:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#D0D0D0"><tr><td><span class="roman">
<i><b>int</b>&nbsp;soap_copy(<b>struct</b>&nbsp;soap *soap);</i> <br />
<i><b>void</b>&nbsp;soap_done(<b>struct</b>&nbsp;soap *soap);</i>
</td></tr></table><br></span>
The <i>soap_copy</i> function returns a new dynamically allocated gSOAP
environment that is a copy of another, such that no data is shared between the
copy and the original environment. The <i>soap_copy</i> function invokes the
plug-in copy callbacks to copy the plug-ins' local data.
The <i>soap_copy</i> function returns a gSOAP error code or <i>SOAP_OK</i>.
The <i>soap_done</i> function de-registers all plugin-ins, so this function
should be called to cleanly terminate a gSOAP run-time environment.

<p>
An example will be used to illustrate these functions.
This example overrides the send and receive callbacks to copy all messages
that are sent and received to the terminal (stderr).

<p>
First, we write a header file <i>plugin.h</i> to define the local plug-in data
structure(s) and we define a global name to identify the plug-in:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "stdsoap2.h" <br />
#define PLUGIN_ID "PLUGIN-1.0" // some name to identify plugin <br />
<b>struct</b>&nbsp;plugin_data // local plugin data <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>int</b>&nbsp;(*fsend)(<b>struct</b>&nbsp;soap*, <b>const</b>&nbsp;<b>char</b>*, size_t); // to save and use send callback <br />
&nbsp;&nbsp;&nbsp;size_t (*frecv)(<b>struct</b>&nbsp;soap*, <b>char</b>*, size_t); // to save and use recv callback <br />
}; <br />
<b>int</b>&nbsp;plugin(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *plugin, <b>void</b>&nbsp;*arg);
</td></tr></table><br></i>
Then, we write the plugin registry function and the callbacks:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
#include "plugin.h" <br />
<b>static</b>&nbsp;<b>const</b>&nbsp;<b>char</b>&nbsp;plugin_id[] = PLUGIN_ID; // the plugin id <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_init(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;plugin_data *data); <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_copy(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *dst, <b>struct</b>&nbsp;soap_plugin *src); <br />
<b>static</b>&nbsp;<b>void</b>&nbsp;plugin_delete(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *p); <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_send(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*buf, size_t len); <br />
<b>static</b>&nbsp;size_t plugin_recv(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*buf, size_t len); <br />
// the registry function: <br />
<b>int</b>&nbsp;plugin(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *p, <b>void</b>&nbsp;*arg) <br />
{ <br />
&nbsp;&nbsp;&nbsp;p-&#62;id = plugin_id; <br />
&nbsp;&nbsp;&nbsp;p-&#62;data = (<b>void</b>*)malloc(<b>sizeof</b>(<b>struct</b>&nbsp;plugin_data)); <br />
&nbsp;&nbsp;&nbsp;p-&#62;fcopy = plugin_copy; <br />
&nbsp;&nbsp;&nbsp;p-&#62;fdelete = plugin_delete; <br />
&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(p-&#62;data) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b>&nbsp;(plugin_init(soap, (<b>struct</b>&nbsp;plugin_data*)p-&#62;data)) <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(p-&#62;data); // error: could not init <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_EOM; // return error <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;SOAP_OK; <br />
} <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_init(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;plugin_data *data) <br />
{ <br />
&nbsp;&nbsp;&nbsp;data-&#62;fsend = soap-&#62;fsend; // save old recv callback <br />
&nbsp;&nbsp;&nbsp;data-&#62;frecv = soap-&#62;frecv; // save old send callback <br />
&nbsp;&nbsp;&nbsp;soap-&#62;fsend = plugin_send; // replace send callback with new <br />
&nbsp;&nbsp;&nbsp;soap-&#62;frecv = plugin_recv; // replace recv callback with new <br />
&nbsp;&nbsp;&nbsp;return SOAP_OK; <br />
} <br />
// copy plugin data, called by soap_copy()
// This is important: we need a deep copy to avoid data sharing by two run-time environments <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_copy(<b>struct</b>&nbsp;soap *soap, struct soap_plugin *dst, <b>struct</b>&nbsp;soap_plugin *src) <br />
{ *dst = *src; <br />
} <br />
// plugin deletion, called by soap_done() <br />
<b>static</b>&nbsp;<b>void</b>&nbsp;plugin_delete(<b>struct</b>&nbsp;soap *soap, <b>struct</b>&nbsp;soap_plugin *p) <br />
{ free(p-&#62;data); // free allocated plugin data <br />
} <br />
// the new send callback <br />
<b>static</b>&nbsp;<b>int</b>&nbsp;plugin_send(<b>struct</b>&nbsp;soap *soap, <b>const</b>&nbsp;<b>char</b>&nbsp;*buf, size_t len) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;plugin_data *data = (<b>struct</b>&nbsp;plugin_data*)soap_lookup_plugin(soap, plugin_id); // fetch plugin's local data <br />
&nbsp;&nbsp;&nbsp;fwrite(buf, len, 1, stderr); // write message to stderr <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;data-&#62;fsend(soap, buf, len); // pass data on to old send callback <br />
} <br />
// the new receive callback <br />
<b>static</b>&nbsp;size_t plugin_recv(<b>struct</b>&nbsp;soap *soap, <b>char</b>&nbsp;*buf, size_t len) <br />
{ <br />
&nbsp;&nbsp;&nbsp;<b>struct</b>&nbsp;plugin_data *data = (<b>struct</b>&nbsp;plugin_data*)soap_lookup_plugin(soap, plugin_id); // fetch plugin's local data <br />
&nbsp;&nbsp;&nbsp;size_t res = data-&#62;frecv(soap, buf, len); // get data from old recv callback <br />
&nbsp;&nbsp;&nbsp;fwrite(buf, res, 1, stderr); <br />
&nbsp;&nbsp;&nbsp;<b>return</b>&nbsp;res; <br />
}
</td></tr></table><br></i>
The <i>fcopy</i> and <i>fdelete</i> callbacks of <i><b>struct</b>&nbsp;soap_plugin</i>
MUST be set to register the plugin. It is the responsibility of the plug-in to
handle registry (init), copy, and deletion of the plug-in data and callbacks.

<p>
The example plug-in should be used as follows:
<br><br><table border=0 width="100%" cellpadding="8" bgcolor="#B0D0B0"><tr><td><i>
<b>struct</b>&nbsp;soap soap; <br />
soap_init(&amp;soap); <br />
soap_register_plugin(&amp;soap, plugin); <br />
... <br />
soap_done(&amp;soap);
</td></tr></table><br></i>
Note: <i>soap_register_plugin(...)</i> is an alias for
<i>soap_register_plugin_arg(..., NULL)</i>. That is, it passes NULL as an
argument to plug-in's registry callback.

<p>
</body>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.00.<br />On 27 Jan 2003, 08:24.</small>
</html>
