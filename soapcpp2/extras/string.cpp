/*	string.cpp

	Provide std::string support (see stringtest.h and stringtest.cpp)

	Copyright (C) 2000-2002 Robert A. van Engelen. All Rights Reserved.

To use std::string, add the following lines to the header file for gSOAP:

#include <string>
extern class std::string;
extern typedef std::string xsd__string;

Run the gSOAP compiler on this header file:
soapcpp2 -i file.h
Compile and then link this file (string.cpp) with your application.
Note that this file requires the definition of the xsd__string type, which
is provided in soapH.h generated by soapcpp2 from your header file.  

*/

#include "soapH.h"

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, const std::string *s)
{ }

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(struct soap *soap, std::string *s)
{ /* When classes are used within structs, there is no guarantee that the VMTs of these classes are initialized when the struct is dynamically allocated. Therefore, pointers to class instances should be used when possible. gSOAP uses a trick with static class instances to initialize dynamically allocated class instances within structs as follows: */
  static std::string a;
  memcpy(s, &a, sizeof(std::string));
  s->erase();
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{ soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__string), type);
  soap_string_out(soap, s->c_str());
  soap_element_end_out(soap, tag);
  return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{ if (soap_element_begin_in(soap, tag))	// match inbound tag, return if mismatch
    return NULL;
  if (!s)	// allocate object
    s = soap_new_xsd__string(soap, -1);
  if (soap->null)	// inbound xsi:nil element:
    if (s)
      s->erase();
  if (*soap->type && soap_match_tag(soap, soap->type, type))	// check inbound xsi:type
  { soap->error = SOAP_TYPE_MISMATCH;
    soap_revert(soap);	// reject this already accepted XML element, so others can try to match it
    return NULL;
  }
  if (soap->body && !*soap->href)	// XML element has a body (and no ref)
  { s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, soap->type, soap->arrayType);
    if (s)
      s->assign(soap_string_in(soap, 1));	// read string, convert (param 0=take literal XML 1=convert), and assign
  }
  else
    s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, soap->type, soap->arrayType), SOAP_TYPE_xsd__string, sizeof(std::string));	// if a ref is present, forward location for backpatching
  if (soap->body && soap_element_end_in(soap, tag))	// match inbound tag end, if present
    return NULL;
  return s;
}
