/*

wsaapi.c

WS-Addressing plugin for stand-alone services.

gSOAP XML Web services tools
Copyright (C) 2000-2006, Robert van Engelen, Genivia Inc., All Rights Reserved.
This part of the software is released under one of the following licenses:
GPL, the gSOAP public license, or Genivia's license for commercial use.
--------------------------------------------------------------------------------
gSOAP public license.

The contents of this file are subject to the gSOAP Public License Version 1.3
(the "License"); you may not use this file except in compliance with the
License. You may obtain a copy of the License at
http://www.cs.fsu.edu/~engelen/soaplicense.html
Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the License.

The Initial Developer of the Original Code is Robert A. van Engelen.
Copyright (C) 2000-2006, Robert van Engelen, Genivia Inc., All Rights Reserved.
--------------------------------------------------------------------------------
GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org
--------------------------------------------------------------------------------
A commercial use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

/**

@mainpage

- @ref wsa documents the wsa plugin for WS-Addressing (2004 spec) support.

*/

/**

@page wsa The wsa plugin for stand-alone services

@section wsa_1 WS-Addressing Setup

The material in this section relates to the WS-Addressing specification 2004.

To use the wsa plugin:
-# Run wsdl2h -t typemap.dat on a WSDL of a service that requires WS-Addressing
   headers. The typemap.dat file included in the gSOAP package is used to
   recognize and translate Addressing header blocks.
-# Run soapcpp2 on the header file produced by wsdl2h. To enable
   addressing-based service operation selection, you MUST use soapcpp2 option
   -a. This allows the service to dispatch methods based on the WS-Addressing
   action information header value (assuming the wsa plugin is registered).
-# (Re-)compile stdsoap2.c/pp, dom.c/pp, wsaapi.c and the generated
   source files.
-# Use the wsa plugin API functions described below.

An example wsa client/server application can be found in samples/wsa.

To use WS-Addressing, the gSOAP header file for a service should declare a SOAP
Header with the required WS-Addressing information headers. The header file is
automatically generated by wsdl2h for a set of WSDLs. The gSOAP header file is
further processed by soapcpp2 to generate the binding codes.

The SOAP Header structure contains the WS-Addressing information headers
extracted from the WSDL and the WS-Addressing specification. For example:
@code
#import "soap12.h"
#import "wsa.h"

struct SOAP_ENV__Header
{
                 _wsa__MessageID  wsa__MessageID 0;
                 _wsa__RelatesTo *wsa__RelatesTo 0;
                 _wsa__From      *wsa__From      0;
  mustUnderstand _wsa__ReplyTo   *wsa__ReplyTo   0;
  mustUnderstand _wsa__FaultTo   *wsa__FaultTo   0;
  mustUnderstand _wsa__To         wsa__To        0;
  mustUnderstand _wsa__Action     wsa__Action    0;
};
@endcode

The SOAP Header struct is automatically generated by wsdl2h from a WSDL.
However, it must be manually defined when creating new services from gSOAP
header files. The gSOAP header file is processed with soapcpp2 to generate the
client-side and/or server-side binding code.

Note that the wsa.h header file in the import directory declares the
WS-Addressing information header elements and types. The soap12.h header
file enables SOAP 1.2 messaging. Note that the mustUnderstand qualifier
ensures that the information headers must be understood by a receiving SOAP
processor.

For developers: the WS-Addressing header blocks in wsa.h were generated from
the WS-Addressing schema with the wsdl2h tool and WS/WS-typemap.dat as follows:

@code
    $ wsdl2h -cegy -o wsa.h -t WS/WS-typemap.dat WS/WS-Addressing.xsd
@endcode

@section wsa_2 Client-side Usage

@subsection wsa_2_1 Formulating WS-Addressing Information Headers

To associate WS-Addressing information headers with service operations, the
SOAP Header struct must have been defined and for each service operation that
uses WS-Addressing method-header-part directives should be used in the gSOAP
header file of the service as follows:
@code
#import "wsa.h"

struct SOAP_ENV__Header { ... };

//gsoap ns service method-header-part: example wsa__MessageID
//gsoap ns service method-header-part: example wsa__RelatesTo
//gsoap ns service method-header-part: example wsa__From
//gsoap ns service method-header-part: example wsa__ReplyTo
//gsoap ns service method-header-part: example wsa__FaultTo
//gsoap ns service method-header-part: example wsa__To
//gsoap ns service method-header-part: example wsa__Action
//gsoap ns service method-action: example urn:example/examplePort/example
int ns__example(char *in, struct ns__exampleResponse *out);
@endcode

In the client-side code, the WS-Addressing information headers are set with
soap_wsa_request() by passing an optional message UUID string, a mandatory
destination address URI string, and a mandatory request action URI string. The
wsa plugin should be registered with the currenct soap struct context. An
optional source address information header can be added with
soap_wsa_add_From() (must be invoked after the soap_wsa_request call).

For example:
@code
soap_register_plugin(soap, soap_wsa);

soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction);
soap_wsa_add_From(soap, FromAddress); // optional: add a 'From' address

if (soap_call_ns__example(soap, ToAddress, NULL, ...))
  soap_print_fault(soap, stderr); // an error occurred
else
  // process the response 
@endcode

@subsection wsa_2_2 Information Headers for Relaying Server Responses

To relay the response to another destination, the WS-Addressing ReplyTo
information header is added with soap_wsa_add_ReplyTo() by passing a reply
address URI string. The service returns HTTP 202 ACCEPTED to the client when
the response message relay was successful.

For example:
@code
soap_register_plugin(soap, soap_wsa);

soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction);
soap_wsa_add_From(soap, FromAddress); // optional: add a 'From' address
soap_wsa_add_ReplyTo(soap, ReplyToAddress);

if (soap_call_ns__example(soap, ToAddress, NULL, ...))
{
  if (soap->error == 202) // HTTP ACCEPTED
    printf("Request was accepted and results were forwarded\n");
  else
    soap_print_fault(soap, stderr); // an error occurred
}
else
  // error: for some reason the response was not relayed
@endcode

Note: the response message will be relayed when the From address is absent or
different than the ReplyTo address

@subsection wsa_2_3 Information Headers for Relaying Server Faults

To relay a server fault message to another destination, the WS-Addressing
FaultTo information header is added with soap_wsa_add_FaultTo() by passing a
relay address URI string. The service returns HTTP 202 ACCEPTED to the client
when the fault was relayed.

For example:
@code
soap_register_plugin(soap, soap_wsa);

soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction);
soap_wsa_add_From(soap, FromAddress); // optional: add a 'From' address
soap_wsa_add_FaultTo(soap, FaultToAddress);

if (soap_call_ns__example(soap, ToAddress, NULL, ...))
{
  if (soap->error == 202) // HTTP ACCEPTED
    printf("A fault occurred and the fault details were forwarded\n");
  else
    soap_print_fault(soap, stderr); // a connection error occurred
}
else
  // process response 
@endcode

Note that the call can still return a fault, such as a connection error when
the service is not responding. In addition to the fault relay, the responses
can be relayed with soap_wsa_add_ReplyTo().

@section wsa_3 Server-side Usage

The wsa plugin should be registered with:
@code
soap_register_plugin(soap, soap_wsa);
@endcode

Once the plugin is registered, the soap_bind(), soap_accept(), and soap_serve() functions can be called to process requests.

Important: to dispatch service operations based on the WS-Addressing wsa:Action
information header, use soapcpp2 option -a. The generates a new dispatcher (in
soapServer.c) based on the action value.

A service operation implementation should use soap_wsa_check() to verify the
validity of the WS-Addressing information headers in the SOAP request message.
To allow response message to be automatically relayed based on the ReplyTo
information header, the service operation should return soap_wsa_reply() with
an optional message UUID string and a mandatory response action string.

For example:
@code
int ns__example(struct soap *soap, char *in, struct ns__exampleResponse *out)
{ if (soap_wsa_check(soap))
    return soap->error;
  // ... service logic
  return soap_wsa_reply(soap, ResponseMessageID, ResponseAction);
}
@endcode

To return a SOAP fault that is automatically relayed to a fault service based
on the FaultTo information header, the soap_wsa_sender_fault(),
soap_wsa_receiver_fault(), soap_wsa_sender_fault_subcode(), and
soap_wsa_receiver_fault_subcode() functions should be used instead of the
soap_sender_fault(), soap_receiver_fault(), soap_sender_fault_subcode(), and
soap_receiver_fault_subcode(), respectively.

For example:
@code
int ns__example(struct soap *soap, char *in, struct ns__exampleResponse *out)
{ if (soap_wsa_check(soap))
    return soap->error;
  // ... service logic
  // ... an error occurred, need to return fault possibly to fault service:
    return soap_wsa_sender_fault(soap, "Exception in service operation", NULL);
  // ... normal execution continues
  return soap_wsa_reply(soap, ResponseMessageID, ResponseAction);
}
@endcode

@section wsa_4 Implementing a Server for Handling ReplyTo Response Messages

To implement a separate server for handling relayed SOAP response messages
based on the ReplyTo information header in the request message, the gSOAP
header file should include a one-way service operation for the response
message.

For example, suppose a service operation returns an exampleResponse message. We
declare the one-way exampleResponse operation as follows:
@code
#import "wsa.h"

struct SOAP_ENV__Header { ... };

//gsoap ns service method-header-part: exampleResult wsa__MessageID
//gsoap ns service method-header-part: exampleResult wsa__RelatesTo
//gsoap ns service method-header-part: exampleResult wsa__From
//gsoap ns service method-header-part: exampleResult wsa__ReplyTo
//gsoap ns service method-header-part: exampleResult wsa__FaultTo
//gsoap ns service method-header-part: exampleResult wsa__To
//gsoap ns service method-header-part: exampleResult wsa__Action
//gsoap ns service method-action: exampleResult urn:example/examplePort/exampleResponse
int ns__exampleResponse(char *out, void);
@endcode

Note that the action information is important, because it is used by the
service dispatcher (assuming soapcpp2 option -a is used).

The implementation in the server code uses soap_wsa_check() to check the
presense and validity of the WS-Addressing information header in the message.
The soap_send_empty_response() function should be used to return an
acknowledgment HTTP header with HTTP 202 ACCEPTED to the sender:
@code
int ns__exampleResponse(struct soap *soap, char *out)
{ if (soap_wsa_check(soap))
    return soap_send_empty_response(soap, 500); // HTTP 500 Internal Server Error
  // ... service logic
  return soap_send_empty_response(soap, SOAP_OK); // HTTP 202 ACCEPTED
}
@endcode

@section wsa_5 Implementing a Server for Handling FaultTo Fault Messages

To implement a separate server for handling relayed SOAP fault messages based
on the FaultTo information header in the request message, the gSOAP header file
for soapcpp2 should include a SOAP fault service operation. This operation
accepts fault messages that are relayed by other services.

Basically, we use a trick to generate the SOAP-ENV:Fault struct via a one-way
service operation. This allows us both to implement a one-way service operation
that accepts faults and to automatically generate the fault struct for fault
data storage and manipulation. 

The fault operation in the header file should be declaraed as follows:
@code
//gsoap SOAP_ENV service method-action: Fault http://schemas.xmlsoap.org/ws/2004/08/addressing/fault
int SOAP_ENV__Fault
(       _QName			 faultcode,		// SOAP 1.1
        char			*faultstring,		// SOAP 1.1
        char			*faultactor,		// SOAP 1.1
        struct SOAP_ENV__Detail	*detail,		// SOAP 1.1
        struct SOAP_ENV__Code	*SOAP_ENV__Code,	// SOAP 1.2
        struct SOAP_ENV__Reason	*SOAP_ENV__Reason,	// SOAP 1.2
        char			*SOAP_ENV__Node,	// SOAP 1.2
        char			*SOAP_ENV__Role,	// SOAP 1.2
        struct SOAP_ENV__Detail	*SOAP_ENV__Detail,	// SOAP 1.2
	void
);
@endcode

Because each service operation has a struct to hold its input parameters, we
automatically generate the (original) SOAP_ENV__Fault struct on the fly!

Note: it is important to associate the wsa fault action with this operation as
shown above.

The implementation of the service operation in the server code is:
@code
int SOAP_ENV__Fault(struct soap *soap, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{ 
  ... = faultcode; // SOAP 1.1 fault code string (QName)
  ... = faultstring; // SOAP 1.1 fault string
  ... = faultactor; // SOAP 1.1 fault actor string
  ... = detail; // SOAP 1.1 fault detail struct
  ... = SOAP_ENV__Code; // SOAP 1.2 fault code struct
  ... = SOAP_ENV__Reason; // SOAP 1.2 reason struct
  ... = SOAP_ENV__Node; // SOAP 1.2 node string
  ... = SOAP_ENV__Role; // SOAP 1.2 role string
  ... = SOAP_ENV__Detail; // SOAP 1.2 detail struct
  return SOAP_OK;
}
@endcode

Note that SOAP 1.1 or SOAP 1.2 parameters are set based on the 1.1/1.2
messaging requirements.

*/

#include "wsaapi.h"

/** Plugin identification for plugin registry */
const char soap_wsa_id[13] = SOAP_WSA_ID;

const char *soap_wsa_anonymousURI = "http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous";
const char *soap_wsa_faultAction = "http://schemas.xmlsoap.org/ws/2004/08/addressing/fault";

/******************************************************************************\
 *
 * Static protos
 *
\******************************************************************************/

static int soap_wsa_fault_subcode(struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail);

static int soap_wsa_init(struct soap *soap, struct soap_wsa_data *data);
static void soap_wsa_delete(struct soap *soap, struct soap_plugin *p);

static int soap_wsa_header(struct soap *soap);
static void soap_wsa_set_error(struct soap *soap, const char **c, const char **s);
static int soap_wsa_response(struct soap *soap, int status, size_t count);

static int soap_wsa_alloc_header(struct soap *soap);

/******************************************************************************\
 *
 * Client-side Request
 *
\******************************************************************************/

/**
@fn int soap_wsa_request(struct soap *soap, const char *id, const char *to, const char *action)
@brief Sets the WS-Addressing information header for the next request message
with optional MessageID, To (required), and Action (required).
@param soap
context
@param[in] id is the message ID (optional)
@param[in] to is the target endpoint (required)
@param[in] action is the target action (required)
@return SOAP_OK

Note: use soap_wsa_add_From, soap_wsa_add_ReplyTo, soap_wsa_add_FaultTo to add
other addressing fields following this function call.
*/
int
soap_wsa_request(struct soap *soap, const char *id, const char *to, const char *action)
{ soap_wsa_alloc_header(soap);
  soap_default_SOAP_ENV__Header(soap, soap->header);
  soap->header->wsa__MessageID = soap_strdup(soap, id);
  soap->header->wsa__To = soap_strdup(soap, to);
  soap->header->wsa__Action = soap_strdup(soap, action);
  return SOAP_OK;
}

/**
@fn int soap_wsa_add_From(struct soap *soap, const char *from)
@brief Sets WS-Addressing From header for request message.
@param soap context
@param[in] from endpoint URI 
@return SOAP_OK or SOAP_ERR

Use soap_wsa_request to populate the WS-Addressing header first.
*/
int
soap_wsa_add_From(struct soap *soap, const char *from)
{ if (!soap->header)
    return SOAP_ERR;
  soap->header->wsa__From = (_wsa__From*)soap_malloc(soap, sizeof(_wsa__From));
  soap_default_wsa__EndpointReferenceType(soap, soap->header->wsa__From);
  soap->header->wsa__From->Address = soap_strdup(soap, from);
  return SOAP_OK;
}

/**
@fn int soap_wsa_add_ReplyTo(struct soap *soap, const char *replyTo)
@brief Sets WS-Addressing ReplyTo header for request message.
@param soap context
@param[in] replyTo endpoint URI 
@return SOAP_OK or SOAP_ERR

Use soap_wsa_request to populate the WS-Addressing header.
*/
int
soap_wsa_add_ReplyTo(struct soap *soap, const char *replyTo)
{ if (!soap->header)
    return SOAP_ERR;
  if (replyTo)
  { soap->header->wsa__ReplyTo = (_wsa__ReplyTo*)soap_malloc(soap, sizeof(_wsa__ReplyTo));
    soap_default_wsa__EndpointReferenceType(soap, soap->header->wsa__ReplyTo);
    soap->header->wsa__ReplyTo->Address = soap_strdup(soap, replyTo);
  }
  return SOAP_OK;
}

/**
@fn int soap_wsa_add_FaultTo(struct soap *soap, const char *faultTo)
@brief Sets WS-Addressing FaultTo header for request message.
@param soap context
@param[in] faultTo endpoint URI 
@return SOAP_OK or SOAP_ERR

Use soap_wsa_request to populate the WS-Addressing header first.
*/
int
soap_wsa_add_FaultTo(struct soap *soap, const char *faultTo)
{ if (!soap->header)
    return SOAP_ERR;
  if (faultTo)
  { soap->header->wsa__FaultTo = (_wsa__FaultTo*)soap_malloc(soap, sizeof(_wsa__FaultTo));
    soap_default_wsa__EndpointReferenceType(soap, soap->header->wsa__FaultTo);
    soap->header->wsa__FaultTo->Address = soap_strdup(soap, faultTo);
  }
  return SOAP_OK;
}

/******************************************************************************\
 *
 * Server-side Check
 *
\******************************************************************************/

/**
@fn int soap_wsa_check(struct soap *soap)
@brief Checks the presence and validity of WS-Addressing information headers.
@param soap context
@return SOAP_OK or fault
*/
int
soap_wsa_check(struct soap *soap)
{ if (!soap->header || !soap->header->wsa__To || !soap->header->wsa__Action)
    return soap_wsa_error(soap, wsa__MessageInformationHeaderRequired);
  return SOAP_OK;
}

/******************************************************************************\
 *
 * Server-side Reply
 *
\******************************************************************************/

/**
@fn int soap_wsa_reply(struct soap *soap, const char *id, const char *action)
@brief Sets WS-Addressing header fields for server response.
@param soap context
@param[in] id is the messageID (optional)
@param[in] action is the target action (required)
@return SOAP_OK or fault
*/
int
soap_wsa_reply(struct soap *soap, const char *id, const char *action)
{ struct soap_wsa_data *data = (struct soap_wsa_data*)soap_lookup_plugin(soap, soap_wsa_id);
  struct SOAP_ENV__Header *header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
  DBGFUN1("soap_wsa_reply", "action=%s", action?action:"");
  if (!data)
    return SOAP_PLUGIN_ERROR;
  soap_default_SOAP_ENV__Header(soap, header);
  soap_wsa_alloc_header(soap);
  if (soap->header->wsa__MessageID)
  { header->wsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship));
    soap_default_wsa__Relationship(soap, header->wsa__RelatesTo);
    header->wsa__RelatesTo->__item = soap->header->wsa__MessageID;
  }
  header->wsa__MessageID = soap_strdup(soap, id);
  header->wsa__Action = soap_strdup(soap, action);
  if (soap->header && soap->header->wsa__ReplyTo && soap->header->wsa__ReplyTo->Address && strcmp(soap->header->wsa__ReplyTo->Address, soap_wsa_anonymousURI))
  { header->wsa__To = soap->header->wsa__ReplyTo->Address;
    /* (re)connect to fault endpoint if From != ReplyTo */
    if (!soap->header->wsa__From || !soap->header->wsa__From->Address || strcmp(soap->header->wsa__From->Address, soap->header->wsa__ReplyTo->Address))
    { struct soap reply_soap;
      soap_init2(&reply_soap, soap->imode, soap->omode);
      if (soap_connect(&reply_soap, header->wsa__To, header->wsa__Action))
      { soap_end(&reply_soap);
        soap_done(&reply_soap);
        return soap_wsa_error(soap, wsa__DestinationUnreachable);
      }
      soap->keep_alive = 0;
      soap_send_empty_response(soap, SOAP_OK);	/* HTTP ACCEPTED */
      soap_closesock(soap);
      soap_copy_stream(soap, &reply_soap);
      soap_set_endpoint(soap, header->wsa__To);
      soap->action = header->wsa__Action;
      data->fresponse = soap->fresponse;
      soap->fresponse = soap_wsa_response;	/* response will be a POST */
      reply_soap.socket = SOAP_INVALID_SOCKET;	/* prevents close */
      soap_end(&reply_soap);
      soap_done(&reply_soap);
    }
  }
  else if (soap->header->wsa__From)
    header->wsa__To = soap->header->wsa__From->Address;
  else
    header->wsa__To = (char*)soap_wsa_anonymousURI;
  soap->header = header;
  return SOAP_OK;
}

/******************************************************************************\
 *
 * Server-side SOAP Fault
 *
\******************************************************************************/

/**
@fn int soap_wsa_fault_subcode(struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail)
@brief Sets sender/receiver SOAP Fault (sub)code for server fault response.
@param soap context
@param[in] flag 0=receiver, 1=sender
@param[in] faultsubcode sub code string
@param[in] faultstring fault string
@param[in] faultdetail detail string
@return SOAP_FAULT
*/
static int
soap_wsa_fault_subcode(struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail)
{ struct soap_wsa_data *data = (struct soap_wsa_data*)soap_lookup_plugin(soap, soap_wsa_id);
  struct SOAP_ENV__Header *header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
  DBGFUN2("soap_wsa_fault_subcode", "faultsubcode=%s", faultsubcode?faultsubcode:"", "faultstring=%s", faultstring?faultstring:"");
  if (!data)
    return SOAP_PLUGIN_ERROR;
  soap_default_SOAP_ENV__Header(soap, header);
  soap_wsa_alloc_header(soap);
  if (soap->header->wsa__MessageID)
  { header->wsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship));
    soap_default_wsa__Relationship(soap, header->wsa__RelatesTo);
    header->wsa__RelatesTo->__item = soap->header->wsa__MessageID;
  }
  /* header->wsa__MessageID = "..."; */
  header->wsa__Action = (char*)soap_wsa_faultAction;
  if (soap->header && soap->header->wsa__FaultTo && soap->header->wsa__FaultTo->Address && strcmp(soap->header->wsa__FaultTo->Address, soap_wsa_anonymousURI))
  { header->wsa__To = soap->header->wsa__FaultTo->Address;
    /* (re)connect to fault endpoint if To != FaultTo */
    if (!soap->header->wsa__From || !soap->header->wsa__From->Address || strcmp(soap->header->wsa__From->Address, soap->header->wsa__ReplyTo->Address))
    { soap->keep_alive = 0;
      soap_send_empty_response(soap, SOAP_OK);	/* HTTP ACCEPTED */
      if (soap_connect(soap, header->wsa__To, header->wsa__Action))
        return SOAP_STOP;	/* nowhere to go */
      soap_set_endpoint(soap, header->wsa__To);
      soap->action = header->wsa__Action;
      data->fresponse = soap->fresponse;
      soap->fresponse = soap_wsa_response;	/* response will be a POST */
    }
  }
  else if (soap->header->wsa__From)
    header->wsa__To = soap->header->wsa__From->Address;
  else
    header->wsa__To = (char*)soap_wsa_anonymousURI;
  soap->header = header;
  if (flag)
    return soap_sender_fault_subcode(soap, faultsubcode, faultstring, faultdetail);
  return soap_receiver_fault_subcode(soap, faultsubcode, faultstring, faultdetail);
}

/**
@fn int soap_wsa_sender_fault_subcode(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)
@brief Sets sender SOAP Fault (sub)code for server fault response.
@param soap context
@param[in] faultsubcode sub code string
@param[in] faultstring fault string
@param[in] faultdetail detail string
@return SOAP_FAULT
*/
int
soap_wsa_sender_fault_subcode(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)
{ return soap_wsa_fault_subcode(soap, 1, faultsubcode, faultstring, faultdetail);
}

/**
@fn int soap_wsa_receiver_fault_subcode(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)
@brief Sets receiver SOAP Fault (sub)code for server fault response.
@param soap context
@param[in] faultsubcode sub code string
@param[in] faultstring fault string
@param[in] faultdetail detail string
@return SOAP_FAULT
*/
int
soap_wsa_receiver_fault_subcode(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)
{ return soap_wsa_fault_subcode(soap, 0, faultsubcode, faultstring, faultdetail);
}

/**
@fn int soap_wsa_sender_fault(struct soap *soap, const char *faultstring, const char *faultdetail)
@brief Sets sender SOAP Fault for server fault response.
@param soap context
@param[in] faultstring fault string
@param[in] faultdetail detail string
@return SOAP_FAULT
*/
int
soap_wsa_sender_fault(struct soap *soap, const char *faultstring, const char *faultdetail)
{ return soap_wsa_fault_subcode(soap, 1, NULL, faultstring, faultdetail);
}

/**
@fn int soap_wsa_receiver_fault(struct soap *soap, const char *faultstring, const char *faultdetail)
@brief Sets receiver SOAP Fault for server fault response.
@param soap context
@param[in] faultstring fault string
@param[in] faultdetail detail string
@return SOAP_FAULT
*/
int
soap_wsa_receiver_fault(struct soap *soap, const char *faultstring, const char *faultdetail)
{ return soap_wsa_fault_subcode(soap, 0, NULL, faultstring, faultdetail);
}

/******************************************************************************\
 *
 * Server-side WS-Addressing Fault
 *
\******************************************************************************/

/**
@fn int soap_wsa_error(struct soap *soap, wsa__FaultSubcodeValues fault)
@brief Sets SOAP Fault (sub)code for server WS-Addressing fault response.
@param soap context
@param[in] fault is one of wsa:FaultSubcodeValues
@return SOAP_FAULT
*/
int
soap_wsa_error(struct soap *soap, wsa__FaultSubcodeValues fault)
{ const char *code = soap_wsa__FaultSubcodeValues2s(soap, fault);
  /* populate the SOAP Fault as per WS-Addressing spec */
  switch (fault)
  { case wsa__InvalidMessageInformationHeader:
      return soap_wsa_sender_fault_subcode(soap, code, "A message information header is not valid and the message cannot be processed. The validity failure can be either structural or semantic, e.g. a [destination] that is not a URI or a [relationship] to a [message id] that was never issued.", "Invalid header");
    case wsa__MessageInformationHeaderRequired:
      return soap_wsa_sender_fault_subcode(soap, code, "A required message information header, To, MessageID, or Action, is not present.", "Missing Header QName");
    case wsa__DestinationUnreachable:
      return soap_wsa_sender_fault_subcode(soap, code, "No route can be determined to reach the destination role defined by the WS-Addressing To.", NULL);
    case wsa__ActionNotSupported:
      return soap_wsa_sender_fault_subcode(soap, code, "The [action] cannot be processed at the receiver.", soap->action);
    case wsa__EndpointUnavailable:
      return soap_wsa_receiver_fault_subcode(soap, code, "The endpoint is unable to process the message at this time.", NULL);
  }
  return SOAP_FAULT;
}

/******************************************************************************\
 *
 * Plugin registry functions
 *
\******************************************************************************/

/**
@fn int soap_wsa(struct soap *soap, struct soap_plugin *p, void *arg)
@brief Plugin registry function, used with soap_register_plugin.
@param soap context
@param[in,out] p plugin created in registry
@param[in] arg passed from soap_register_plugin_arg
@return SOAP_OK
*/
int
soap_wsa(struct soap *soap, struct soap_plugin *p, void *arg)
{ DBGFUN("soap_wsa");
  p->id = soap_wsa_id;
  p->data = (void*)SOAP_MALLOC(soap, sizeof(struct soap_wsa_data));
  p->fcopy = NULL;
  p->fdelete = soap_wsa_delete;
  if (p->data)
  { if (soap_wsa_init(soap, (struct soap_wsa_data*)p->data))
    { SOAP_FREE(soap, p->data);
      return SOAP_EOM;
    }
  }
  return SOAP_OK;
}

/**
@fn int soap_wsa_init(struct soap *soap, struct soap_wsa_data *data)
@brief Initializes plugin data.
@param soap context
@param[in,out] data plugin data
@return SOAP_OK
*/
static int
soap_wsa_init(struct soap *soap, struct soap_wsa_data *data)
{ DBGFUN("soap_wsa_init");
  data->fheader = soap->fheader;
  data->fseterror = soap->fseterror;
  soap->fheader = soap_wsa_header;
  soap->fseterror = soap_wsa_set_error;
  return SOAP_OK;
}

/**
@fn void soap_wsa_delete(struct soap *soap, struct soap_plugin *p)
@brief Deletes plugin data.
@param soap context
@param[in,out] p plugin
@return SOAP_OK
*/
static void
soap_wsa_delete(struct soap *soap, struct soap_plugin *p)
{ DBGFUN("soap_wsa_delete");
  SOAP_FREE(soap, p->data);
}

/******************************************************************************\
 *
 * Callbacks registered by plugin
 *
\******************************************************************************/

/**
@fn int soap_wsa_header(struct soap *soap)
@brief Copies WS-Addressing action to SOAP action
@param soap context
@return SOAP_OK or fault

This callback is invoked to copy the WS-Addressing action to the SOAP action
before invoking the service operation.
*/
static int
soap_wsa_header(struct soap *soap)
{ struct soap_wsa_data *data = (struct soap_wsa_data*)soap_lookup_plugin(soap, soap_wsa_id);
  DBGFUN("soap_wsa_header");
  if (!data)
    return SOAP_PLUGIN_ERROR;
  if (data->fheader && data->fheader(soap))
    return soap->error;
  if (soap->header && soap->header->wsa__Action)
    soap->action = soap->header->wsa__Action;
  return SOAP_OK;
}

/**
@fn void soap_wsa_set_error(struct soap *soap, const char **c, const char **s)
@brief Copies WS-Addressing action to SOAP action
@param soap context
@param c fault code
@param s fault string
*/
static void
soap_wsa_set_error(struct soap *soap, const char **c, const char **s)
{ struct soap_wsa_data *data = (struct soap_wsa_data*)soap_lookup_plugin(soap, soap_wsa_id);
  DBGFUN("soap_wsa_set_error");
  if (!data)
    return;
  if (data->fseterror)
    data->fseterror(soap, c, s);
  if (soap->error == SOAP_NO_METHOD)
    soap->error = soap_wsa_error(soap, wsa__ActionNotSupported);
}

/**
@fn int soap_wsa_response(struct soap *soap, int status, size_t count)
@brief Overrides the HTTP response operations to send an HTTP POST
@param soap context
@param status code
@param count message length (if non-chunked)
*/
static int
soap_wsa_response(struct soap *soap, int status, size_t count)
{ struct soap_wsa_data *data = (struct soap_wsa_data*)soap_lookup_plugin(soap, soap_wsa_id);
  DBGFUN2("soap_wsa_response", "status=%d", status, "count=%lu", (unsigned long)count);
  if (!data)
    return SOAP_PLUGIN_ERROR;
  soap->fresponse = data->fresponse;	/* reset (HTTP response) */
  return soap->fpost(soap, soap_strdup(soap, soap->endpoint), soap->host, soap->port, soap->path, soap->action, count);
}

/******************************************************************************\
 *
 * Misc.
 *
\******************************************************************************/

/**
@fn int soap_wsa_alloc_header(struct soap *soap)
@brief Adds SOAP Header if not present.
@param soap context
@return SOAP_OK
*/
static int
soap_wsa_alloc_header(struct soap *soap)
{ if (!soap->header)
    soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
  return SOAP_OK;
}
